<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>针对 objc_exception_throw 的实用调试技巧</title>
      <link href="/2019/01/01/2019/1/zhen-dui-objc-exception-throw-de-shi-yong-diao-shi-ji-qiao/"/>
      <url>/2019/01/01/2019/1/zhen-dui-objc-exception-throw-de-shi-yong-diao-shi-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="针对-objc-exception-throw-的实用调试技巧"><a href="#针对-objc-exception-throw-的实用调试技巧" class="headerlink" title="针对 objc_exception_throw 的实用调试技巧"></a>针对 objc_exception_throw 的实用调试技巧</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>相信调试过程中发生崩溃这种事情，大家肯定都遇到过，一般也会给 Xcode 设一个全局共享的异常断点，如图1所示，（如果没有的话，可以设置一波）。当我们调试遇到抛出异常时，Xcode 会自动断点，输出一些关于 Exception 的日志信息。但是有些时候并不见得会输出有用的日志（或者压根就没有日志）只有对应的崩溃栈，如图2所示。</p><p>示例中向 NSArray 发了一条无法响应的消息，崩溃后 Xcode 自动断点到了相应的断点位置（这里其实 Xcode 已经在 console 中输入了对应的崩溃信息，因为一时半会不知道该怎么制造 Xcode 不输出日志的环境，所以将就用这个示例来代替下），同时左边也有了对应的崩溃调用栈。我们可以将调用栈切到最上方的 objc_exception_throw，然后在 console 中输入 po $arg1，因为 arg1 代表的是对象本身，在这里就是 NSException，而它又复写了 description 方法，所以对其 print 输出的是对应的崩溃信息。</p><p>以上其实我们还可以节省一个步骤，就是编辑一下这个全局异常端点，给起加一个 Debugger Command 的 Action，如图3所示，这样就可以在发生 objc_exception_throw 崩溃的时候，就可以自动输出对应的崩溃信息了，而不用再手动切换到栈顶的 objc_exception_throw 再输一遍 po $arg1。需要明确一点的是，这种方式仅适用于 objc_exception_throw 类型的崩溃（模拟器、真机都适用）。</p><p>其他几个有意思的参数值，上面说到 arg1 是当前断点所在方法的接收对象，arg2 是被调用的方法名（在 po 的时候要做一个强转，如 po (SEL)$arg2)，如果有参数则 arg 依次递增。</p><p>另外 lldb 的其它更多命令及便捷或扩展的方式，推荐 Facebook 的 <a href="https://github.com/facebook/chisel" target="_blank" rel="noopener">Chisel</a><br>个人使用频率最高的就是真机调试动画，放慢动画速度的命令，运行过程中触发任意一个断点，执行 slowanim 即可（默认10倍速慢放，可自行在后面指定慢放倍数，如 slowanim 0.2 就是慢放5倍）。</p><p>如果你有更多的小技巧欢迎分享，欢迎交流~</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/9-1.gif" alt><br><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/9-2.jpg" alt><br><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/9-3.jpg" alt></p><p>参考链接：<a href="https://www.natashatherobot.com/xcode-debugging-trick/" target="_blank" rel="noopener">Xcode: One Weird Debugging Trick That Will Save Your Life</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>聊聊 iPad 适配</title>
      <link href="/2019/01/01/2019/1/liao-liao-ipad-gua-pei/"/>
      <url>/2019/01/01/2019/1/liao-liao-ipad-gua-pei/</url>
      
        <content type="html"><![CDATA[<h2 id="聊聊-iPad-适配"><a href="#聊聊-iPad-适配" class="headerlink" title="聊聊 iPad 适配"></a>聊聊 iPad 适配</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>在最新版本中，我们为网易有道词典做了完全的 iPad 适配，你可以在 iPad 上横屏、分屏使用有道词典，也完全支持了屏幕旋转后的 UI 调整。今天来聊聊这次的适配体验。</p><p>千言万语总结成一句话：如果你正确使用了 <code>autolayout</code>（使用比例而非固定值），那么即使是原本仅支持竖屏的页面，在打开转屏开关后，页面也不会有太大的问题。况且苹果已经提升了 <code>autolayout</code> 的性能，所以如果你的 app 未来有支持 iPad 的潜在可能，那么尽可能地全部使用 <code>autolayout</code> 来布局吧。</p><p>如果现有的大量页面都已经使用了计算 <code>frame</code> 的方式来布局，也有解决办法。<code>UIView</code> 的子类 要保证在 <code>layoutSubviews</code> 方法内进行布局（根据 self 宽高而不是屏幕或 window 尺寸），这本来也是一个标准做法。对于 <code>ViewController</code>，系统提供了 <code>viewWillLayoutSubviews</code> 方法，类似于 <code>layoutSubviews</code>方法，你可以在这里进行 <code>vc.view</code> 及其子 <code>view</code> 的布局。在转屏、分屏后这些方法都会被触发。</p><p>需要注意的是，iPad 上不仅有旋转屏幕的操作，还有分屏的操作，系统也提供了进入分屏的系统通知，如果需要可以进行监听。比如大多数拍照 app 会在进入分屏后为用户弹一个分屏无法拍照的 <code>alert</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>点击cell不执行-[UITableView didSelectRowAtIndexPath:]方法的几种方式</title>
      <link href="/2019/01/01/2019/1/dian-ji-cell-bu-zhi-xing-uitableview-de-didselectrowatindexpath-fang-fa-de-ji-chong-fang-shi/"/>
      <url>/2019/01/01/2019/1/dian-ji-cell-bu-zhi-xing-uitableview-de-didselectrowatindexpath-fang-fa-de-ji-chong-fang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="点击cell不执行-UITableView-didSelectRowAtIndexPath-方法的几种方式"><a href="#点击cell不执行-UITableView-didSelectRowAtIndexPath-方法的几种方式" class="headerlink" title="点击cell不执行-[UITableView didSelectRowAtIndexPath:]方法的几种方式"></a>点击cell不执行-[UITableView didSelectRowAtIndexPath:]方法的几种方式</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>今天分享一个比较常用的知识点，点击某个UITableViewCell不执行<code>-[UITableView didSelectRowAtIndexPath:]</code>方法的几种方式：</p><ul><li><p>可以直接设置<code>cell.userInteractionEnabled = NO</code>；</p></li><li><p>可以实现UITableViewDelegate中的<code>-[UITableView shouldHighlightRowAtIndexPath:]</code>方法，设置对应indexPath返回NO；</p></li></ul><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/10-1.jpg" alt></p><ul><li>可以实现UITableViewDelegate中的<code>-[UITableView willSelectRowAtIndexPath:]</code>方法，设置对应indexPath返回nil，不过这种方式cell还是会有高亮效果，需要手动设置对应<code>cell.selectionStyle = UITableViewCellSelectionStyleNone</code>；</li></ul><p>以上三个方法，都不会进UITableViewDelegate的<code>-[UITableView didSelectRowAtIndexPath:]</code>方法。用第一种方式设置后，cell上的所有子View都不能被点击了；而第二种方式不会影响cell的子View的响应事件的传递，如果cell上有UIControl的子类，依然可以被点击；第三种方式也不会影响cell的子视图的响应事件，但是需要额外设置不显示高亮效果。当然，你也可以在<code>-[UITableView didSelectRowAtIndexPath:]</code>方法的对应indexPath直接return，只要你高兴😂，可以根据实际情况选择合适的方法。</p><p>有更优雅的方式，欢迎一起讨论。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于UIStackView的一个小知识点</title>
      <link href="/2019/01/01/2019/1/guan-yu-uistackview-de-yi-ge-xiao-zhi-shi-dian/"/>
      <url>/2019/01/01/2019/1/guan-yu-uistackview-de-yi-ge-xiao-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="关于UIStackView的一个小知识点"><a href="#关于UIStackView的一个小知识点" class="headerlink" title="关于UIStackView的一个小知识点"></a>关于UIStackView的一个小知识点</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>今天分享一个<code>UIStackView</code>的小知识点,用<code>UIStackView</code>做水平或垂直布局很方便，搜了大多数UIStackView的资料，大多是教大家如何使用的axis、alignment等属性的。最近使用时遇到了：把<code>UIStackView</code>中某个视图<code>hidden</code>后，<code>UIStackView</code>的布局会进行更新，只展示没有<code>hidden</code>的视图（官方文档截图：图1），</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/12/3-1.png" alt></p><p>例如，你有5个视图平等分显示，设置某个视图<code>hidden</code>之后，就会变成4个视图平等分了。</p><p>有的时候这是我们期许的，而有的时候并不是；如果<code>hidden</code>某个视图后，不想更改其他视图布局，那么可以设置alpha，或者使用<code>Masonry</code>的方法，之前小集也提过（图2）。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/12/3-2.png" alt></p><p>了解这个属性之后，免得大家开发过程走弯路，根据情况选择适当的方式布局。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 strong 而不是 assign 修饰 dispatch 对象</title>
      <link href="/2019/01/01/2019/1/shi-yong-strong-er-bu-shi-assign-xiu-shi-dispatch-dui-xiang/"/>
      <url>/2019/01/01/2019/1/shi-yong-strong-er-bu-shi-assign-xiu-shi-dispatch-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-strong-而不是-assign-修饰-dispatch-对象"><a href="#使用-strong-而不是-assign-修饰-dispatch-对象" class="headerlink" title="使用 strong 而不是 assign 修饰 dispatch 对象"></a>使用 strong 而不是 assign 修饰 dispatch 对象</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/3951595216" target="_blank" rel="noopener">NotFound—</a></p><p>当运行系统是在 iOS6 以下时，是需要通过 <code>dispatch_retain</code> 和 <code>dispatch_release</code> 来管理 <code>dispatch queue</code> 的生命周期的，此时应该使用 <code>assign</code> 来修饰 <code>dispatch_queue_t</code> 类型的对象。在 iOS6 及以后是通过 ARC 来管理 <code>dispatch queue</code> 对象的生命周期的，所以应该使用 strong 来修饰 <code>dispatch_queue_t</code> 类型的对象。这里以支持 iOS5 系统的 <code>SDWebImage(version:3.7.6)</code> 的代码举例：</p><pre class=" language-objc"><code class="language-objc">#if OS_OBJECT_USE_OBJC    #define SDDispatchQueueSetterSementics strong#else#define SDDispatchQueueSetterSementics assign#endif@property (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t barrierQueue;</code></pre><p><code>OS_OBJECT_USE_OBJC</code> 是一个编译器选项，当我们工程里面设置的 <code>Deployment target</code> 大于或等于 iOS 6 时，<code>OS_OBJECT_USE_OBJC</code> 的值会是 1，否则会是 0。因为我们现在的 app 普遍都是支持到 iOS9 或者 iOS8，所以 <code>dispatch_queue_t</code> 类型的对象都是使用 ARC 来进行管理的，我们使用 strong 来修饰就好了。</p><p>【示例】</p><p>在美团近期开源的 <code>UI</code> 渲染框架 <code>Graver</code> 中也发现，错误得使用 assign 来修饰 <code>dispatch_queue_t</code> 类型的属性（如图一所示），</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/7-1.jpg?raw=true" alt></p><p>对 Graver 框架实际测试时，发现将一个 dispatch_queue_t 类型的局部变量赋值给对 assign 修饰的 <code>dispatch_queue_t</code> 后（如图二所示），</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/7-2.jpg?raw=true" alt></p><p>会抛出了野指针异常（如图三所示）。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/7-3.jpg?raw=true" alt></p><p>然后去 github 上搜了一下“<code>assign dispatch_queue_t</code>”，发现很多代码也是使用这种错误的写法，所以觉得有必要写个 tip，提醒一下大家。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode更新输入账号密码，账号却不是自己的</title>
      <link href="/2019/01/01/2019/1/xcode-geng-xin-shu-ru-zhang-hao-mi-ma-zhang-hao-que-bu-shi-zi-ji-de/"/>
      <url>/2019/01/01/2019/1/xcode-geng-xin-shu-ru-zhang-hao-mi-ma-zhang-hao-que-bu-shi-zi-ji-de/</url>
      
        <content type="html"><![CDATA[<h2 id="Xcode更新输入账号密码，账号却不是自己的"><a href="#Xcode更新输入账号密码，账号却不是自己的" class="headerlink" title="Xcode更新输入账号密码，账号却不是自己的"></a>Xcode更新输入账号密码，账号却不是自己的</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>更新Xcode的时候，需要输入Apple账号和密码，以前一直正常，这次更新的时候遇到一个问题。更新的时候提示输入账号和密码，可是账号并不是我自己的账号，关键这个账号也不能修改，只能输入密码。刚开始以为是系统的问题，把Mac系统升级后发现并不管用。最后想了下，我电脑上的Xcode安装的时候是直接和同事拷贝的，那么这个账号应该就是他的。直接和同事要账号密码并不合适。</p><p>最后找到一个解决办法：</p><pre><code>在应用中找到Xcode -&gt; 显示包内容 -&gt; 找到 _MASReceipt 文件夹，把它删除 -&gt; 更新即可。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS App 异常捕获相互覆盖问题</title>
      <link href="/2019/01/01/2019/1/ios-app-yi-chang-bu-huo-xiang-hu-fu-gai-wen-ti/"/>
      <url>/2019/01/01/2019/1/ios-app-yi-chang-bu-huo-xiang-hu-fu-gai-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-App-异常捕获相互覆盖问题"><a href="#iOS-App-异常捕获相互覆盖问题" class="headerlink" title="iOS App 异常捕获相互覆盖问题"></a>iOS App 异常捕获相互覆盖问题</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>在开发和维护 App 过程中，我们通常需要去捕获并上报导致 App 崩溃的异常信息，以便于分析，一般我们会使用一些成熟的第三方 SDK，例如 Bugly 或者友盟等。</p><p>但如果我们想自己捕获异常信息，做一些相关处理，其实也很简单，苹果为开发者提供了两个异常捕获的 API，如下：</p><pre class=" language-objc"><code class="language-objc">typedef void NSUncaughtExceptionHandler(NSException *exception);NSUncaughtExceptionHandler * NSGetUncaughtExceptionHandler(void);void NSSetUncaughtExceptionHandler(NSUncaughtExceptionHandler *);</code></pre><p>其中，<code>NSSetUncaughtExceptionHandler</code> 函数用于设置异常处理的回调函数，在程序终止前的最后一刻会调用我们设置的回调函数（Handler），进行崩溃日志的记录，代码如下：</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/1-1.jpg" alt></p><p>但是，大部分第三方 SDK 也是通过这种方式来收集异常的，当我们通过 <code>NSSetUncaughtExceptionHandler</code> 设置异常处理函数时，会覆盖其它 SDK 设置的回调函数，导致它们无法上报统计，反之，也可能出现我们设置的回调函数被其他人覆盖。</p><p>那如何解决这种覆盖的问题呢？其实很简单，苹果也为我们提供了 <code>NSGetUncaughtExceptionHandler</code> 函数，用于获取之前设置的异常处理函数。</p><p>所以，我们可以在调用 <code>NSSetUncaughtExceptionHandler</code> 注册异常处理函数之前，先通过 <code>NSGetUncaughtExceptionHandler</code> 拿到已有的异常处理函数并保存下来。然后在我们自己的处理函数执行之后，再调用之前保存的处理函数就可以了。 </p><p>完整的示例代码如下图所示：</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/1-2.jpg" alt></p><p>最后，如果你的 App 接入了多个异常捕获 SDK，而出现了其中一个异常上报不生效的情况，有可能就是因为这个覆盖问题导致的。</p><p>参考连接：<a href="https://mp.weixin.qq.com/s/vmwj3Hs8JTg3WmB70xhqIQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vmwj3Hs8JTg3WmB70xhqIQ</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode 工程设置构建版本号自动递增</title>
      <link href="/2019/01/01/2019/1/xcode-gong-cheng-she-zhi-gou-jian-ban-ben-hao-zi-dong-di-zeng/"/>
      <url>/2019/01/01/2019/1/xcode-gong-cheng-she-zhi-gou-jian-ban-ben-hao-zi-dong-di-zeng/</url>
      
        <content type="html"><![CDATA[<h2 id="Xcode-工程设置构建版本号自动递增"><a href="#Xcode-工程设置构建版本号自动递增" class="headerlink" title="Xcode 工程设置构建版本号自动递增"></a>Xcode 工程设置构建版本号自动递增</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>在一个 iOS 工程中，通常有两种“版本号”，即 <code>Version</code> 和 <code>Build</code>，如图 1 所示：</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/8-1.jpg" alt></p><ul><li><p><strong>Version</strong> 为发布版本号，标识应用程序发布的正式版本号，通常为两段式或者三段式，例如：<code>1.2.1</code>、<code>1.0</code> 等，其 Key 为 <code>CFBundleShortVersionString</code>，在 Info.plist 文件中对应 “Bundle versions string, short”；</p></li><li><p><strong>Build</strong> 为构建版本号，标识应用程序构建（编译）的内部版本号，可以有多种方法表示：时间表示（e.g. “20190122080211”）、字母表示（e.g “ABC”）、以及<strong>递增的数字</strong>（e.g. “100”）等。它一般不对外公开，在开发团队内部使用。其 Key 为 <code>CFBundleVersion</code>，在 Info.plist 文件中对应 “Bundle version”；</p></li></ul><p>在 App Store 发布应用时，使用的是 “Version” 版本号，在同一个 “Version” 号下， 开发者可以上传不同 “Build” 构建版本。此外，对于 “Build” 号，我们最常使用 “递增的数字” 来表示。</p><p>同时，苹果为我们提供了一个 <code>agvtool</code> 命令行工具，用于自动增加版本号，具体使用方式如下：</p><p>首先，在 Build Settings 配置项中，设置 <code>Current Project Version</code> 为选定的值，例如 <code>100</code>（可以为整数或浮点数，新工程一般设为 <code>1</code>），<code>agvtool</code> 命令会根据这个值来递增 “Build” 号。另外需要再选择 <code>Versioning System</code> 的值为 <code>Apple Generic</code>，如图 2 所示。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/8-3.jpg" alt></p><p>然后，在 Build Phases 中，点击 “+” 号，选择 “New Run Script Phase” 添加一个执行脚本，并设置以下脚本代码，如图 3 所示：</p><blockquote><p>xcrun agvtool next-version -all</p></blockquote><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/8-2.jpg" alt></p><p>以上，我们在每次编译工程时，“Build” 号就会自动递增加 1 了。</p><p>关于 <code>agvtool</code> 命令的更多使用方式，可以参考<a href="https://segmentfault.com/a/1190000004678950" target="_blank" rel="noopener">这里</a>。</p><p>最后，上述配置在多人开发或者多分支开发时，可能会导致 “Build” 号冲突，因此，我们可以只在日常给测试人员打包的机器上配置就好了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>This block declaration is not a prototype 编译警告处理</title>
      <link href="/2019/01/01/2019/1/this-block-declaration-is-not-a-prototype-bian-yi-jing-gao-chu-li/"/>
      <url>/2019/01/01/2019/1/this-block-declaration-is-not-a-prototype-bian-yi-jing-gao-chu-li/</url>
      
        <content type="html"><![CDATA[<h2 id="This-block-declaration-is-not-a-prototype-编译警告处理"><a href="#This-block-declaration-is-not-a-prototype-编译警告处理" class="headerlink" title="This block declaration is not a prototype 编译警告处理"></a>This block declaration is not a prototype 编译警告处理</h2><p><strong>作者</strong>: <a href="https://weibo.com/3321824014" target="_blank" rel="noopener">南峰子</a></p><p>在 Objective-C 中，经常会使用到 block，在声明 block 时，如果没有参数，我们经常是会将参数省略，而不写 void，如</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>Completion<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>特别是在老代码中，这样的情况应该是多数。</p><p>而到了 Xcode 9 之后，编译器对这样的代码给出一个警告：</p><pre class=" language-c"><code class="language-c">This block declaration is not a prototype</code></pre><p>即编译器希望你把参数 void 给加上。</p><p>最直接的方法当然是声明 block 时，对无参的 block 加上 void，但对于老代码或者是第三方的代码，我想很少有人想去改。如果想过滤这种烦人的提示又想偷懒，那就只能借助编译器配置了，如下图，将 Strict Prototypes 的值设置为 NO，警告就不会再出现了。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/5-1.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift 中实现 synchronized</title>
      <link href="/2019/01/01/2019/1/swift-zhong-shi-xian-synchronized/"/>
      <url>/2019/01/01/2019/1/swift-zhong-shi-xian-synchronized/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift-中实现-synchronized"><a href="#Swift-中实现-synchronized" class="headerlink" title="Swift 中实现 synchronized"></a>Swift 中实现 synchronized</h2><p><strong>作者</strong>: <a href="https://weibo.com/3321824014" target="_blank" rel="noopener">南峰子</a></p><p>Objective-C 中的 <code>@synchronized</code> 大家都应该很熟悉，用来对一段代码块加锁。不过在 Swift 中没有提供对应的关键字执行相同的操作。所以如果要使用类似的 <code>synchronized</code>，则需要自己动手。</p><p>以下是 <code>RxSwift</code> 中的实现方式：</p><pre class=" language-c"><code class="language-c">extension Reactive where Base<span class="token punctuation">:</span> AnyObject <span class="token punctuation">{</span>    func synchronized<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>_ action<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span> <span class="token operator">-></span> T <span class="token punctuation">{</span>        <span class="token function">objc_sync_enter</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>base<span class="token punctuation">)</span>        let result <span class="token operator">=</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">objc_sync_exit</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>base<span class="token punctuation">)</span>        <span class="token keyword">return</span> result    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到是通过 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code> 来对代码块加锁。而实际上 Objective-C 中的 <code>@synchronized</code> 也是基于这两个函数来实现的。如果有兴趣，可以查看一下<a href="https://github.com/gcc-mirror/gcc/blob/master/libobjc/objc/objc-sync.h" target="_blank" rel="noopener">源代码</a></p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">关于 @synchronized，这儿比你想知道的还要多</a></li><li><a href="https://swifter.tips/lock/" target="_blank" rel="noopener">LOCK</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NSScanner 过滤字符串</title>
      <link href="/2019/01/01/2019/1/nsscanner-guo-lu-zi-fu-chuan/"/>
      <url>/2019/01/01/2019/1/nsscanner-guo-lu-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="NSScanner-过滤字符串"><a href="#NSScanner-过滤字符串" class="headerlink" title="NSScanner 过滤字符串"></a>NSScanner 过滤字符串</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/6603469503" target="_blank" rel="noopener">这个汤圆没有馅</a></p><p>在使用<code>&lt;ContactsUI/ContactsUI.h&gt;</code>框架获取通讯录手机号码时，不同的 iOS 系统最后得到的手机号码也不同。有的是<code>xxx-xxxx-xxxx</code>，有的是 <code>xxx xxxx xxxx</code>。为了得到有效的手机号码，可以用正则过滤字符串。如以下代码。</p><pre><code>NSMutableString *mobile = [NSMutableString stringWithString:@&quot;131-0000-2222&quot;];NSMutableString *phone = [NSMutableString string];for(int i =0; i &lt; [mobile length]; i++) {    NSString *temp = [mobile substringWithRange:NSMakeRange(i,1)];    NSString *regex = @&quot;^[0-9]+$&quot;;    NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex];    if ([pred evaluateWithObject:temp]) {       [phone appendString:temp];    }}</code></pre><p>除了正则外，今天要介绍的是<code>NSScanner</code>过滤器。先看一下 apple 文档里对 NSScanner 的说明。【一个字符串解析器，用于扫描字符集中的子字符或字符，以及十进制、十六进制和浮点表示形式的数值。】<br><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/10-1.jpg" alt></p><p>常用属性有以下几个：</p><p><code>charactersToBeSkipped</code>，设置忽略指定字符，默认是空格和回车。</p><p><code>isAtEnd</code>，是否扫描结束。</p><p><code>scanLocation</code>，扫描开始的位置。</p><p>用 <code>NSScanner</code> 扫描字符串得到有效的手机号码，代码如下：</p><pre><code>NSString *originalStr = @&quot;131-0000-2222&quot;;NSMutableString *stripStr = [NSMutableString stringWithCapacity:originalStr.length];NSScanner *scanner = [NSScanner scannerWithString:originalStr];NSCharacterSet *numbers = [NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789&quot;];while ([scanner isAtEnd] == NO) {    NSString *buffer;    if ([scanner scanCharactersFromSet:numbers intoString:&amp;buffer]) {        [stripStr appendString:buffer];    } else {        [scanner setScanLocation:[scanner scanLocation] + 1];    }}</code></pre><p>平时我们用的条件判断一般以 <code>if</code> 或 <code>正则表达式</code> 居多，<code>NSScanner</code> 其实也是一个陌生且又强大的条件判断器。</p><p>如有表述不当，欢迎指出~~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Framework 中混合编程时 umbrella header 设置注意事项</title>
      <link href="/2019/01/01/2019/1/framework-zhong-hun-he-bian-cheng-shi-umbrella-header-she-zhi-zhu-yi-shi-xiang/"/>
      <url>/2019/01/01/2019/1/framework-zhong-hun-he-bian-cheng-shi-umbrella-header-she-zhi-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="Framework-中混合编程时-umbrella-header-设置注意事项"><a href="#Framework-中混合编程时-umbrella-header-设置注意事项" class="headerlink" title="Framework 中混合编程时 umbrella header 设置注意事项"></a>Framework 中混合编程时 umbrella header 设置注意事项</h2><p><strong>作者</strong>: <a href="https://weibo.com/3321824014" target="_blank" rel="noopener">南峰子</a></p><p>Swift 和 Objective-C 混合编程，当需要在 Swift 中调用 Objective-C 代码时，在 App Target 中，我们依托的是 <code>Objective-C Bridging Header</code>，而在 Framework Target 中，依托的是 <code>unbrella header</code> ，即 Framework 的主头文件。我们需要做如下配置：</p><ul><li>在 Build Setting -&gt; Packaging 中将 Defines Module 设置为 YES，如下图所示；</li></ul><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/6-1.png" alt></p><ul><li>在 unbrella header  中导入需要暴露的 Objective-C 头文件</li></ul><p>如果这样配置后，发现编译器还是报 <code>Use of undeclared type &#39;**&#39;</code> 错误，则确认以下两点：</p><ul><li>unbrella header 和需要暴露的 Objective-C 头文件是否包含在 Framework Target 中，如下图所示；</li></ul><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/6-1.png" alt></p><ul><li>在 Build Phases -&gt; Headers 中，将 unbrella header 和需要暴露的 Objective-C 头文件放置在 Public 区域中，所下图所示!</li></ul><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/6-1.png" alt></p><p>这样确认后，基本就没什么问题了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Command Not Found</title>
      <link href="/2019/01/01/2019/1/command-not-found/"/>
      <url>/2019/01/01/2019/1/command-not-found/</url>
      
        <content type="html"><![CDATA[<h2 id="Command-Not-Found"><a href="#Command-Not-Found" class="headerlink" title="Command Not Found"></a>Command Not Found</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>使用终端命令的时候常会出现<code>Command Not Found</code>这个错误，我们今天聊一聊这个错误出现的基本原因，出现这个问题一般因为下面4种原因；</p><ul><li>输入命令时语法错误，命令行有语法规则，必须按语法规则写；</li><li>命令并没有安装，有时候安装的时候忽略了错误；</li><li>命令被删除或破坏了；</li><li>用户的 <code>$PATH</code> 不正确，大部分原因都是这个导致的；</li></ul><p>出现前三种错误都比较好解决，第四中错误比较常见，有时候明明安装完成了，却还会报这个错误。命令行程序之所以可以执行是因为它本身是一个可执行程序或者是一个脚本。当在终端中输入命令的时候，操作系统会找对应的可执行文件并执行。操作系统会从环境变量<code>$PATH</code>中依次查找可执行文件，直到找到，如果找不到将报 <code>Command Not Found</code> 这个错误。</p><p>查看我电脑的环境变量  <code>$PATH</code> 中包含了（每个路径通过冒号分割）：</p><pre><code>➜  ~ echo $PATH/opt/MonkeyDev/bin:/Library/Frameworks/Python.framework/Versions/3.7/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</code></pre><p>如果报 <code>Command Not Found</code> 这个错误，首先通过<code>echo $PATH</code>查看环境变量中是否已经存在了可执行文件的路径。如果没有打开<code>.bash_profile</code>把可执行文件地绝对路径写进去即可。</p><pre><code>➜ vi $HOME/.bash_profileexport PATH=&quot;$HOME/Library/Android/flutter/bin:$PATH&quot;// 想让刚配置的 PATH 生效，需要刷新终端➜  source $HOME/.bash_profile</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Debug Memory Graph检查内存泄漏</title>
      <link href="/2019/01/01/2019/1/debug-memory-graph-jian-cha-nei-cun-xie-lou/"/>
      <url>/2019/01/01/2019/1/debug-memory-graph-jian-cha-nei-cun-xie-lou/</url>
      
        <content type="html"><![CDATA[<h2 id="Debug-Memory-Graph检查内存泄漏"><a href="#Debug-Memory-Graph检查内存泄漏" class="headerlink" title="Debug Memory Graph检查内存泄漏"></a>Debug Memory Graph检查内存泄漏</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/6603469503" target="_blank" rel="noopener">这个汤圆没有馅</a></p><p>在日常检查内存泄漏时，除了 Instruments 里的 Leaks，还有一个就是 Xcode 8推出的 Debug Memory Graph。</p><p>为了能看到内存详细信息，先打开 Edit Scheme–&gt;Diagnostics, 勾选 Malloc Scribble 和 Malloc Stack。为了避免过多的性能消耗，在 Malloc Stack 中直接选择 Live Allocations Only 即可。<br><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/2-1.jpeg" alt></p><p>运行 App，找到查看视图层级 Debug View Hierarchy 边上的三个小圈圈的按钮，这个就是Debug Memory Graph按钮，点击后页面变化如下图。<br><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/2-2.jpeg" alt></p><p>左边栏会有当前运行 App 的文件信息，若有内存泄漏，边上会有一个紫色的感叹号。也可以通过下方的 show only leaked blocks 过滤文件。</p><p>中间区域内容是当前文件内存详细信息及对象之间的关联关系。黑色线条代表强引用，不过灰色的线不代表弱引用，只是一些系统级别的引用或者苹果为了优化显示效果而添加的，可直接忽略。</p><p>右边栏点击右上角的 Show the Memory Inspector，会有堆栈信息，并且能直接定位到内存泄漏的代码块。</p><p>当然，在 Runtime Issue navigator 中也可以直接看到内存泄漏的地方。<br><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/2-3.jpeg" alt></p><p>Debug Memory Graph  它能很方便的定位到内存泄漏的地方，但同时它会有误报的情况。例如，当创建 UIButton 对象并将其添加到 UIToolBars 项目数组时，会发现它被识别为内存泄漏，但我们不明白为什么。它也会将一些系统的信息识别为内存泄漏，如下图，定位到了一个叫<code>UIKeyboardPredictionView</code>的地方。代码中未用到三方键盘，纯系统键盘唤起。个人理解为系统键盘回收后，其实并没有真正被释放，等到下次唤起键盘时再次使用。我觉得类似这种内存泄漏可以不用管。<br><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/2-4.jpeg" alt></p><p>如有表述不当，欢迎指出~~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Aspects hook 类方法的正确姿势</title>
      <link href="/2019/01/01/2019/1/aspects-hook-lei-fang-fa-de-zheng-que-zi-shi/"/>
      <url>/2019/01/01/2019/1/aspects-hook-lei-fang-fa-de-zheng-que-zi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="Aspects-hook-类方法的正确姿势"><a href="#Aspects-hook-类方法的正确姿势" class="headerlink" title="Aspects hook 类方法的正确姿势 "></a>Aspects hook 类方法的正确姿势 </h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>说起 AOP，相信大家对 Aspects 都有所耳闻，这里不再做原理解读，如果对其原理感兴趣推荐自行阅读源码或者阅读网上大神写的文章。</p><p>根据其 README，我们知道它对类方法和实例方法都能 hook，那么 hook 类方法第一感觉，直接用类名去调用 Aspects 提供的分类类方法就好，大概像图1这样。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/4-1.jpg" alt></p><p>运行起来发现，没有并没有打印我们想要输出的内容，反而输出了一段 Aspects 的错误日志 “Aspects: Blog signature &lt;NSMethodSignature: 0x600001a58c00&gt; doesn’t match (null).”（我猜 Blog 应该是作者笔误，实际上是 Block）。即我们指定的 block 签名和我们要 hook 的方法签名不一致。查看源码，发现用图1这种方式，Aspects 在获取方法签名的时候，使用的是 [[object class] instanceMethodSignatureForSelector:selector]，这个时候获取到的方法签名是 nil。这是为什么呢？</p><p>这里主要是 class 方法和 object_getClass 方法的区别，前者当 object 是类时，则返回本身，当 object 为实例时，则返回类；后者则返回的是 isa 指针的指向，如图2所示。由于这里 object 是类，所以 object.class 返回自身，而自身是没有 selector 对<br>应的实例方法，所以方法签名返回了 nil。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/4-2.jpg" alt></p><p>因此，如果我们如果要 hook 类方法正确的姿势应该如图3所示。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/4-3.jpg" alt></p><p>即对其 metaClass 进行 hook，因为其实 class 也可以理解成 metaClass 的实例对象。回到上面的例子对 metaClass 调用 class 方法时，返回的是 metaClass 本身，所以 [[object class] instanceMethodSignatureForSelector:selector] 实际上是去 metaClass 的 selector 对应的实例方法，也就是类方法，而 selector 对应的类方法是存在的，所以一切流程正常。这里说的比较绕，推荐一下这张经典的图供（图4）大家参考。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/4-4.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在 UILabel 中渲染 HTML</title>
      <link href="/2019/01/01/2019/1/zai-uilabel-zhong-xuan-ran-html/"/>
      <url>/2019/01/01/2019/1/zai-uilabel-zhong-xuan-ran-html/</url>
      
        <content type="html"><![CDATA[<h2 id="在-UILabel-中渲染-HTML"><a href="#在-UILabel-中渲染-HTML" class="headerlink" title="在 UILabel 中渲染 HTML"></a>在 UILabel 中渲染 HTML</h2><p><strong>作者</strong>: <a href="https://weibo.com/3321824014" target="_blank" rel="noopener">南峰子</a></p><p>我们可以使用 NSAttributedString 在 UILabel 中渲染 HTML 字符串，不过需要使用 NSAttributedString 特定的初始化方法</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">init</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> <span class="token builtin">Data</span><span class="token punctuation">,</span> options<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">NSAttributedString</span><span class="token punctuation">.</span><span class="token builtin">DocumentReadingOptionKey</span> <span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> documentAttributes dict<span class="token punctuation">:</span> <span class="token builtin">AutoreleasingUnsafeMutablePointer</span><span class="token operator">&lt;</span><span class="token builtin">NSDictionary</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token keyword">throws</span></code></pre><p>在这个初始化方法的 options 参数中，指定 .documentType 的值为 NSAttributedString.DocumentType.html。不过大多数情况下这还不够，我们可能还需要指定文本的样式，例如指定文本的字体或颜色，这时我们就需要在 html 文本中通过 css 来设置 style，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">UIKit</span><span class="token keyword">extension</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>    <span class="token keyword">func</span> <span class="token function">htmlAttributedString</span><span class="token punctuation">(</span>with fontName<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> fontSize<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> colorHex<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">NSAttributedString</span><span class="token operator">?</span> <span class="token punctuation">{</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> cssPrefix <span class="token operator">=</span> <span class="token string">"&lt;style>* { font-family: <span class="token interpolation"><span class="token delimiter variable">\(</span>fontName<span class="token delimiter variable">)</span></span>; color: #<span class="token interpolation"><span class="token delimiter variable">\(</span>colorHex<span class="token delimiter variable">)</span></span>; font-size: <span class="token interpolation"><span class="token delimiter variable">\(</span>fontSize<span class="token delimiter variable">)</span></span>; }&lt;/style>"</span>            <span class="token keyword">let</span> html <span class="token operator">=</span> cssPrefix <span class="token operator">+</span> <span class="token keyword">self</span>            <span class="token keyword">guard</span> <span class="token keyword">let</span> data <span class="token operator">=</span> html<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span>using<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">.</span><span class="token builtin">Encoding</span><span class="token punctuation">.</span>utf8<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token constant">nil</span> <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token keyword">try</span> <span class="token function">NSAttributedString</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> data<span class="token punctuation">,</span> options<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>documentType<span class="token punctuation">:</span> <span class="token builtin">NSAttributedString</span><span class="token punctuation">.</span><span class="token builtin">DocumentType</span><span class="token punctuation">.</span>html<span class="token punctuation">,</span> <span class="token punctuation">.</span>characterEncoding<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">.</span><span class="token builtin">Encoding</span><span class="token punctuation">.</span>utf8<span class="token punctuation">.</span>rawValue<span class="token punctuation">]</span><span class="token punctuation">,</span> documentAttributes<span class="token punctuation">:</span> <span class="token constant">nil</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token constant">nil</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> html <span class="token operator">=</span> <span class="token string">"&lt;strong>Dear Friend&lt;/strong> I hope this &lt;i>tip&lt;/i> will be useful for &lt;b>you&lt;/b>."</span><span class="token keyword">let</span> attributedString <span class="token operator">=</span> html<span class="token punctuation">.</span><span class="token function">htmlAttributedString</span><span class="token punctuation">(</span>with<span class="token punctuation">:</span> <span class="token string">"Futura"</span><span class="token punctuation">,</span> fontSize<span class="token punctuation">:</span> <span class="token number">14</span><span class="token punctuation">,</span> colorHex<span class="token punctuation">:</span> <span class="token string">"ff0000"</span><span class="token punctuation">)</span></code></pre><p>效果如下图所示</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2019/01/3-1.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>几个第三方框架关于线程锁的封装小技巧</title>
      <link href="/2018/09/01/2018/9/ji-ge-di-san-fang-kuang-jia-guan-yu-xian-cheng-suo-de-feng-zhuang-xiao-ji-qiao/"/>
      <url>/2018/09/01/2018/9/ji-ge-di-san-fang-kuang-jia-guan-yu-xian-cheng-suo-de-feng-zhuang-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="几个第三方框架关于线程锁的封装小技巧"><a href="#几个第三方框架关于线程锁的封装小技巧" class="headerlink" title="几个第三方框架关于线程锁的封装小技巧"></a>几个第三方框架关于线程锁的封装小技巧</h2><p><strong>作者</strong>: <a href="https://weibo.com/cimer" target="_blank" rel="noopener">陈满iOS</a></p><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>第三方库中经常用到的这个小技巧，例如YYCache，SDWebImage等等，虽然各自封装的具体形式不太一样。</p><ul><li>YYCache</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1283539-c0ff7ce9820b0669.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YYCache"></p><ul><li>SDWebImage</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1283539-6e4ac3f974765d15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage"></p><ul><li>YYWebImage</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1283539-21876a916c88227f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YYWebImage"></p><p>我们可以借鉴到自己的项目中，在适当的位置通过宏来加锁解锁操作。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>1.YYCache版本的宏封装<pre><code>#define Lock() dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER)#define Unlock() dispatch_semaphore_signal(self-&gt;_lock)</code></pre></li><li>操作数据之前，先外面进行加锁解锁<br><code>`</code></li><li>(NSInteger)totalCount {<br>Lock();<br>int count = [_kv getItemsCount];<br>Unlock();<br>return count;<br>}<br><code>`</code></li><li>锁里面再进行真正的数据操作<br><code>`</code></li><li>(int)getItemsCount {<br>return [self _dbGetTotalItemCount];<br>}<br><code>`</code></li></ul><h4 id="2-SDWebImage版本的宏封装"><a href="#2-SDWebImage版本的宏封装" class="headerlink" title="2.SDWebImage版本的宏封装"></a>2.SDWebImage版本的宏封装</h4><ul><li>定义<pre><code>#define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);#define UNLOCK(lock) dispatch_semaphore_signal(lock);</code></pre></li><li>调用示例<br><code>`</code></li><li>(void)setValue:(nullable NSString <em>)value forHTTPHeaderField:(nullable NSString </em>)field {<br>LOCK(self.headersLock);<br>if (value) {<br>self.HTTPHeaders[field] = value;<br>} else {<br>[self.HTTPHeaders removeObjectForKey:field];<br>}<br>UNLOCK(self.headersLock);<br>}<pre><code>其中，`self.headersLock` 的定义为：</code></pre>@property (strong, nonatomic, nonnull) dispatch_semaphore_t headersLock;<br><code>`</code><h4 id="3-YYWebImage版本的宏封装"><a href="#3-YYWebImage版本的宏封装" class="headerlink" title="3. YYWebImage版本的宏封装"></a>3. YYWebImage版本的宏封装</h4></li></ul><p>相对于上面，还有更方便的宏封装，把解锁操作跟加锁封装在一块。</p><ul><li>宏定义<br><code>`</code><br>#define LOCK(…) dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER); \<br><strong>VA_ARGS</strong>; \<br>dispatch_semaphore_signal(self-&gt;_lock);</li></ul><p>#define LOCK_VIEW(…) dispatch_semaphore_wait(view-&gt;_lock, DISPATCH_TIME_FOREVER); \<br><strong>VA_ARGS</strong>; \<br>dispatch_semaphore_signal(view-&gt;_lock);</p><pre><code>- 使用示例</code></pre><ul><li>(void)didReceiveMemoryWarning:(NSNotification <em>)notification {<br>[_requestQueue cancelAllOperations];<br>[_requestQueue addOperationWithBlock: ^{<br>_incrBufferCount = -60 - (int)(arc4random() % 120); // about 1~3 seconds to grow back..<br>NSNumber </em>next = @((_curIndex + 1) % _totalFrameCount);<br>LOCK(<br>NSArray <em> keys = _buffer.allKeys;<br>for (NSNumber </em> key in keys) {<br>if (![key isEqualToNumber:next]) { // keep the next frame for smoothly animation<br>[_buffer removeObjectForKey:key];<br>}<br>}<br>)//LOCK<br>}];<br>}<br><code>`</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>给 UIView 添加阴影</title>
      <link href="/2018/08/01/2018/8/gei-uiview-tian-jia-yin-ying/"/>
      <url>/2018/08/01/2018/8/gei-uiview-tian-jia-yin-ying/</url>
      
        <content type="html"><![CDATA[<h2 id="给-UIView-添加阴影"><a href="#给-UIView-添加阴影" class="headerlink" title="给 UIView 添加阴影"></a>给 UIView 添加阴影</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>给 UIView 添加阴影看似简单，如果操作不当也可能会浪费你一些时间。有时候明明添加了阴影可是在 UI 上却没显示出来，尤其涉及到 cell 复用的情况。这里总结几条阴影不显示的原因：</p><ul><li>是否设置了 masksToBounds 为 YES，设置为 masksToBounds=YES，阴影不显示；</li><li>设置阴影时 view 的 frame 是否为 CGRectZero，如果是，即使设置阴影后修改 frame 不为 CGRectZero 时，也不会显示阴影；</li><li>使用自动布局时往往会遇到 frame 为 CGRectZero 时设置阴影无效，这时可以使用 <code>layoutIfNeeded</code> 方法；</li></ul><p><strong>通过 layer 设置阴影</strong></p><pre><code>// 阴影的颜色self.imageView.layer.shadowColor = [UIColor blackColor].CGColor;self.imageView.layer.shadowOpacity = 0.8;// 阴影的圆角self.imageView.layer.shadowRadius = 1;// 阴影偏离的位置 (100, 50) x 方向偏离 100，y 偏离 50 正向，如果是负数正好为相反的方向self.imageView.layer.shadowOffset = CGSizeMake(3, 4);</code></pre><p><strong>通过 shadowPath 设置阴影</strong></p><p>通过这种方式设置的阴影可以自定义阴影的形状，它会使用在 layer 上设置的属性，比如 shadowRadius。</p><pre><code>UIEdgeInsets edges = UIEdgeInsetsMake(15, 10, 15, 10);UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(-edges.left, -edges.top, CGRectGetWidth(self.imageView.frame) + edges.left + edges.right, CGRectGetHeight(self.imageView.frame) + edges.top + edges.bottom)];self.imageView.layer.shadowPath = path.CGPath;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>再谈数组、集合、字典与 hash、isEqual 方法的关联</title>
      <link href="/2018/08/01/2018/8/zai-tan-shu-zu-ji-he-zi-dian-yu-hash-isequal-fang-fa-de-guan-lian/"/>
      <url>/2018/08/01/2018/8/zai-tan-shu-zu-ji-he-zi-dian-yu-hash-isequal-fang-fa-de-guan-lian/</url>
      
        <content type="html"><![CDATA[<h2 id="再谈数组、集合、字典与-hash、isEqual-方法的关联"><a href="#再谈数组、集合、字典与-hash、isEqual-方法的关联" class="headerlink" title="再谈数组、集合、字典与 hash、isEqual 方法的关联"></a>再谈数组、集合、字典与 hash、isEqual 方法的关联</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>我们或多或少了解，Objective-C 中的 NSArray、NSSet、NSDictionary 与 NSObject 及其子类对象的 hash、isEqual 方法有许多联系，这篇小集讲一下其中的一些细节。</p><p>NSArray 允许添加重复元素，添加元素时不查重，所以不调用上述两个方法。在移除元素时，会对当前数组内的元素进行遍历，每个元素的 isEqual 方法都会被调用（使用 remove 方法传入的元素作为参数），<strong>所有返回真值的元素都被移除</strong>。在字典中，不涉及 hash 方法。</p><p>NSSet 不允许添加重复元素，所以添加新元素时，该元素的 hash 方法会被调用。若集合中不存在与此元素 hash 值相同的元素，则它直接被加入集合，不调用 isEqual 方法；若存在，则调用集合内的对应元素的 isEqual 方法，返回真值则判等，不加入，处理结束。若返回 false，则判定集合内不存在该元素，将其加入。</p><p>从集合中移除元素时，首先调用它的 hash 方法。若集合中存在与其 hash 值相等的元素，则调用该元素的 isEqual 方法，若真值则判等，进行移除；若不存在，则会依次调用集合中每个元素的 isEqual 方法，<strong>只要找到一个返回真值的元素，就进行移除，并结束整个过程。</strong>（所以这样会有其他满足 isEqual 方法但却被漏掉未被移除的元素）。调用 contains 方法时，过程类似。</p><p>因此，<strong>若某自定义对象会被加入到集合或作为字典的 key 时，需要同时重写 isEqual 方法和 hash 方法。</strong>这样，若集合中某元素存在，则调用它的 contains 和 remove 方法时，可以在 O(1) 完成查询。否则，查询它的时间复杂度提升为 O(n)。</p><p>值得注意的是，NSDictionary 的键和值都是对象类型即可。但是<strong>被设为键的对象需要遵守 NSCopying 协议</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>区分SDWebImage的三种缓存</title>
      <link href="/2018/08/01/2018/8/qu-fen-sdwebimage-de-san-chong-huan-cun/"/>
      <url>/2018/08/01/2018/8/qu-fen-sdwebimage-de-san-chong-huan-cun/</url>
      
        <content type="html"><![CDATA[<h2 id="区分SDWebImage的三种缓存"><a href="#区分SDWebImage的三种缓存" class="headerlink" title="区分SDWebImage的三种缓存"></a>区分SDWebImage的三种缓存</h2><p><strong>作者</strong>: <a href="https://weibo.com/cimer" target="_blank" rel="noopener">陈满iOS</a></p><p>SDWebImage的三种缓存分为：内存图片缓存，磁盘图片缓存，内存操作缓存，步骤如下</p><ul><li>先查看内存图片缓存，内存图片缓存没有，后生成操作，查看磁盘图片缓存</li><li>磁盘图片缓存有，就加载到内存缓存，没有就下载图片</li><li>在建立下载操作之前，判断下载操作是否存在</li><li>默认情况下，下载的图片数据会同时缓存到内存和磁盘中</li></ul><p>流程如下图1所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/1283539-a475c67e295bc39e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"></p><blockquote><p>关于缓存位置</p></blockquote><ul><li>内存缓存是通过 NSCache的子类AutoPurgeCache来实现的；</li><li>磁盘缓存是通过 NSFileManager 来实现文件的存储(默认路径为/Library/Caches/default/com.hackemist.SDWebImageCache.default)，是异步实现的。</li></ul><blockquote><p>关于图片下载操作</p></blockquote><p>SDWebImage的大部分工作是由缓存对象SDImageCache和异步下载器管理对象SDWebImageManager来完成的。</p><p>SDWebImage的图片下载是由SDWebImageDownloader这个类来实现的，它是一个异步下载管理器，下载过程中增加了对图片加载做了优化的处理。而真正实现图片下载的是自定义的一个Operation操作，将该操作加入到下载管理器的操作队列downloadQueue中，Operation操作依赖系统提供的NSURLConnection类实现图片的下载。</p><blockquote><p>关于SDWebImageManager与SDWebImageDownloader的分工</p><ul><li>SDWebImageManager提供的关键API是loadImageWithURL开头的，负责加载的，加载load这个词跟下载download不同，比它更广，加载负责管理下载之前的操作：</li></ul></blockquote><p>管理下载操作的开始和取消<br>下载之前查询图片的内存缓存和磁盘缓存<br>下载之后保存图片到内存缓存和磁盘缓存<br>返回一个操作对象给上级对象UIImageView+WebCache作为操作缓存数组属性中去</p><ul><li>SDWebImageDownloader提供的关键API是downloadImageWithURL开头的，可见它仅仅管理下载的操作，没有缓存的管理功能。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于IAP丢单的处理</title>
      <link href="/2018/08/01/2018/8/guan-yu-iap-diu-dan-de-chu-li/"/>
      <url>/2018/08/01/2018/8/guan-yu-iap-diu-dan-de-chu-li/</url>
      
        <content type="html"><![CDATA[<h2 id="关于IAP丢单的处理"><a href="#关于IAP丢单的处理" class="headerlink" title="关于IAP丢单的处理"></a>关于IAP丢单的处理</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>做IAP（In-App Purchase）功能都有可能遇到丢单的问题，丢单是用户已经付款，但是因为某种原因客户端没有办法处理后续的操作，比如说根本没有收到苹果支付成功的回调，或者在与服务器验证票据过程中断网等等。如果处理不好，很容易击溃用户的对产品的信用度。</p><p>苹果的推荐做法是合理使用transaction，在AppDelegate.m的<code>application:didFinishLaunchingWithOptions:</code>方法里添加<code>[[SKPaymentQueue defaultQueue] addTransactionObserver:xxx]</code>；如果还没有调用<code>[[SKPaymentQueue defaultQueue] finishTransaction:xxx]</code>，那么在你下次启动App的时候，就会在<code>paymentQueue:updatedTransactions:</code>回调里收到未完成的transaction，然后继续进行处理，所以需要你在合适的时机去调用finishTransaction方法，比如说整个支付流程已经完成（包括已经成功验证票据）的时候，这个可以根据你的业务情况来确定调用时机，这样可以大大降低丢单的概率。不要忘了removeTransactionObserver哦！</p><p>如果觉得处理丢单的时间有点久，可以根据实际情况把相关信息存到本地（如果后续处理流程有需要业务信息的，这种情况是必须要存本地的），在切换到有网或者切换用户或者你觉得合适的实际去处理后续流程，这样也可以双保险，可以把损失降到最低。</p><p>如果有更好的方案，欢迎一起分享讨论。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 Keychain 存储登录态需要注意的一个坑</title>
      <link href="/2018/08/01/2018/8/shi-yong-keychain-cun-chu-deng-lu-tai-xu-yao-zhu-yi-de-yi-ge-keng/"/>
      <url>/2018/08/01/2018/8/shi-yong-keychain-cun-chu-deng-lu-tai-xu-yao-zhu-yi-de-yi-ge-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Keychain-存储登录态需要注意的一个坑"><a href="#使用-Keychain-存储登录态需要注意的一个坑" class="headerlink" title="使用 Keychain 存储登录态需要注意的一个坑"></a>使用 Keychain 存储登录态需要注意的一个坑</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>今天要讨论的这个问题你可能永远都不会遇到，而且绝大部分情况下你很难在开发中事先预料到它未来可能会发生，但是一旦不幸发生了，可能就是一个很严重的线上问题，惨痛教训。</p><p>我们通常会在 Keychain（钥匙串）中存储一些密码、用户登录态等敏感数据，一是可以提高保存数据的安全性；二是当用户卸载 App 后重新安装，可以自动登录保留上次的登录态；三是同一开发者账号下的不同 App，如果是采用同一套账户体系，就可以通过 Keychain Groups 共享登录态。</p><p>我们的 App 之前都是只把用户的登录态保存在 Keychain 中，并在 App 启动时去读取它，这一直也都没什么问题。前一段时间我们的 App 由于业务合规的原因审核被拒，按照苹果的要求不得不把 App 从公司的 A 开发者账号转让到 B 开发者账号下（公司旗下有很多不同主体的开发者账号），转让过程很顺利，但发版后短时间内收到大面积的用户反馈说，更新新版本后提示“登录失效，需要重新登录”。</p><p>原因很容易就可以猜到，App 从 A 转让到 B，就无法读取保存在 A 账号下的 Keychain 数据了，用户更新版本覆盖安装后，打开 App 也就无法获取之前的登录态了。</p><p>而且对于这种已经发生的问题，我们似乎也没有什么有效的补救措施，临时加急再发一版似乎也解决不了问题，因为之前的 Keychain 数据就是读取不到了，总不能再把 App 转让回去吧，😂</p><p>那么如何未雨绸缪预防以后再发生这种因为转让 App 导致存储在 Keychain 中的登录态丢失读取不到呢？（虽然出现转让 App 的概率非常低）</p><p>我们在新版本中采用了一种兼容的方法：把用户的登录态同时加密存储在本地缓存（Sandbox）和 Keychain 中，在 App 启动时，优先从 Keychain 中读取，如果 Keychain 中取不到，就从本地缓存中取（然后再把本地缓存的同步到 Keychain 中，因为即使 App 转让了，用户更新版本覆盖安装后 Sandbox 中的数据是不会变的），如果两处都取不到，就认为未登录。</p><p>你有没有更好的解决方案？欢迎留言讨论。</p><p>另外，有很多人通过 Keychain 来存储设备唯一标示符，也需要注意这个问题。</p><p>关于 Keychain 如何使用，可以参考苹果官方文档：<a href="https://developer.apple.com/library/archive/samplecode/GenericKeychain/Introduction/Intro.html" target="_blank" rel="noopener">GenericKeychain</a>，而关于 Keychain 滥用问题的讨论，可以看 V2EX 的<a href="https://www.v2ex.com/t/471254" target="_blank" rel="noopener">这个帖子</a>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>比较三种网络框架上传图片过程中的不同点？</title>
      <link href="/2018/08/01/2018/8/bi-jiao-san-chong-wang-luo-kuang-jia-shang-chuan-tu-pian-guo-cheng-zhong-de-bu-tong-dian/"/>
      <url>/2018/08/01/2018/8/bi-jiao-san-chong-wang-luo-kuang-jia-shang-chuan-tu-pian-guo-cheng-zhong-de-bu-tong-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="比较三种网络框架上传图片过程中的不同点？"><a href="#比较三种网络框架上传图片过程中的不同点？" class="headerlink" title="比较三种网络框架上传图片过程中的不同点？"></a>比较三种网络框架上传图片过程中的不同点？</h2><p><strong>作者</strong>: <a href="https://weibo.com/cimer" target="_blank" rel="noopener">陈满iOS</a></p><p>AFNetworking上传图片的步骤是利用图片设置到request的HTTPBodyStream中去，然后利用带有图片的request新建task上传。HYNetworking内部实现上传图片的时候，其实就是采用AFNetworking关于上传图片的API，都是AFNetworking里面一个API。XMNetworking上传图片请求也是基于AFNetworking上传进行的封装，不过比HYNetworking更加隐晦而已，另外它封装了上次图片数组的方法。</p><p><strong>AFNetworking</strong></p><ol><li>压缩转换：UIImage实例对象通过UIImageJPEGRepresentation(压缩)转换为NSData，下面称之为imageData。</li><li>信息整合：将imageData与文件名fileName，文件路径name，类型名mimeType整合成图片模型（AFHTTPBodyPart）的一个对象bodyPart中去。</li><li>添加图片模型：将上面新建好的图片模型对象bodyPart，向图片输入流（AFMultipartBodyStream）的对象bodyStream的数组属性（HTTPBodyParts）添加。</li><li>设置request的HTTPBodyStream属性为bodyStream：封装为requestByFinalizingMultipartFormData</li><li>将图片模型对象formData用AFNetwork的POST请求与uploadTaskWithStreamedRequest方法进行上传。</li></ol><p><strong>HYBNetworking</strong></p><ol><li>压缩转换：UIImage实例对象通过UIImageJPEGRepresentation压缩转换为NSData，下面称之为imageData。</li><li>信息整合：利用AFNetwork的appendPartWithFileData，将imageData与文件名fileName，文件路径name，类型名mimeType整合成图片模型（AFStreamingMultipartFormData）的一个对象formData中去。</li><li>将图片模型对象formData用AFNetwork的POST请求与uploadTaskWithStreamedRequest方法进行上传。</li></ol><p><strong>XMNetworking</strong></p><ol><li>压缩转换：UIImage实例对象通过UIImageJPEGRepresentation压缩转换为NSData，下面称之为imageData。</li><li>信息整合：利用AFNetwork的appendPartWithFileData，将imageData与文件名fileName，文件路径name，类型名mimeType整合成图片模型（XMUploadFormData）的一个对象formData中去。</li><li>添加图片模型：向管理器的图片模型数组uploadFormDatas添加上面新建好的图片模型对象formData。</li><li>遍历图片模型数组，获得图片模型，利用AFNetwork的POST请求与uploadTaskWithStreamedRequest方法进行上传。</li></ol><p>【总结】<br>可见，上面三种框架都是基于AFNetworking进行的封装，实质的流程还是一样的。上传图片的流程图1所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/1283539-18e0592dea5a8abc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>配置 xcodebuild 命令打包支持 Bitcode</title>
      <link href="/2018/07/01/2018/7/pei-zhi-xcodebuild-ming-ling-da-bao-zhi-chi-bitcode/"/>
      <url>/2018/07/01/2018/7/pei-zhi-xcodebuild-ming-ling-da-bao-zhi-chi-bitcode/</url>
      
        <content type="html"><![CDATA[<h2 id="配置-xcodebuild-命令打包支持-Bitcode"><a href="#配置-xcodebuild-命令打包支持-Bitcode" class="headerlink" title="配置 xcodebuild 命令打包支持 Bitcode"></a>配置 xcodebuild 命令打包支持 Bitcode</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>我们通常会把一些公用的模块抽离出来打成一个 .a 静态库或者 .framework 动态库，然后再嵌入到宿主工程中。</p><p>最近我们的 App 工程开启 Bitcode 编译选项后（Enable Bitcode = YES），发现在进行 Archive 归档打 Release 包时，报如下错误，提示说工程使用的 libTestStaticSDK.a 静态库不支持 Bitcode：</p><pre class=" language-sh"><code class="language-sh">ld: bitcode bundle could not be generated because '/.../TestApp/TestStaticSDKLib/libTestStaticSDK.a(TestStaticSDK.o)' was built without full bitcode. All object files and libraries for bitcode must be generated from Xcode Archive or Install build for architecture armv7</code></pre><p>但是我们的 libTestStaticSDK 静态库工程的 Build Settings 中同样是有配置开启 Bitcode 的，为什么打出来的 .a 包却不支持 Bitcode 呢？</p><p>通过查阅 StackOverflow 我们发现，原来开启 Bitcode 后，在 Xcode 中进行 “Build” 或 “Archive” 时，Xcode 会自动在编译命令后面添加 <code>-fembed-bitcode</code> 标识，而如果使用 <code>xcodebuild</code> 命令进行打包，则需要手动添加一个 <code>OTHER_CFLAGS</code>，如下：</p><pre class=" language-sh"><code class="language-sh">xcodebuild build OTHER_CFLAGS="-fembed-bitcode" -target libTestStaticSDK ...</code></pre><p>另外一种解决方案是，在静态库 Xcode 工程的 Build Settings 中，添加一个 “User-Define Setting”，内容为：<code>&#39;BITCODE_GENERATION_MODE&#39; =&gt; &#39;bitcode&#39;</code>，如下图所示：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/9-1.png" alt></p><p>这样在使用 <code>xcodebuild</code> 命令时就不用添加 <code>OTHER_CFLAGS=&quot;-fembed-bitcode&quot;</code> 了。</p><p>综上，为了通用，我们可以在 <code>xcodebuild</code> 命令后同时添加上述两种标识，因此一个完整的静态库打包脚本大致如下（同样适用于 Framework 的打包）：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/9-2.png" alt></p><p><strong>参考链接</strong></p><ul><li><p><a href="https://stackoverflow.com/questions/31486232/how-do-i-xcodebuild-a-static-library-with-bitcode-enabled" target="_blank" rel="noopener">How do I xcodebuild a static library with Bitcode enabled?</a></p></li><li><p><a href="https://juejin.im/post/5ab311c76fb9a028c42e18a9" target="_blank" rel="noopener">iOS 中动/静态库支持 Bitcode 的问题</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>让人怀疑人生的一段代码</title>
      <link href="/2018/07/01/2018/7/rang-ren-huai-yi-ren-sheng-de-yi-duan-dai-ma/"/>
      <url>/2018/07/01/2018/7/rang-ren-huai-yi-ren-sheng-de-yi-duan-dai-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="让人怀疑人生的一段代码"><a href="#让人怀疑人生的一段代码" class="headerlink" title="让人怀疑人生的一段代码"></a>让人怀疑人生的一段代码</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>大家可以看一下下面两段代码（图1和图2）</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/06/5-1.jpg" alt></p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/06/5-2.jpg" alt></p><p>如果已经显示了一张沙盒里的图片，这个时候对相同路径的文件进行修改和删除，通常我们认为_imageView应该不受到影响，因为图片已经完成渲染，但事实并非如此，_imageView竟然会跟着发生变化，并且变化的结果也是不可预期的，比如说删除对应的路径的文件，_imageView可能全部黑屏或者一些黑屏，如果不想因为后续操作而影响_imageView的显示，那么就需要用<code>NSData</code>中转一下(图3)。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/06/5-3.jpg" alt></p><p>对于不需要及时删除图片或者修改图片路径的情况，建议在dispath_asyn到main queue里执行图片删除或者文件更改工作，因为此时图片已经完成渲染，再进行删除或者修改操作就没问题了</p><p>是不是感觉有点怀疑人生？在WWDC 2018 Lab中我咨询了相关的苹果工程师，结果是为了性能，内部会有一些同步机制。以后大家遇到这样的问题可以参考一下。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>获取 ipa 包三种姿势</title>
      <link href="/2018/07/01/2018/7/huo-qu-ipa-bao-san-chong-zi-shi/"/>
      <url>/2018/07/01/2018/7/huo-qu-ipa-bao-san-chong-zi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="获取-ipa-包三种姿势"><a href="#获取-ipa-包三种姿势" class="headerlink" title="获取 ipa 包三种姿势"></a>获取 ipa 包三种姿势</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>以前获取一个应用的 ipa 包轻而易举，然而今天想获取一个 ipa 包，如果没有适当的方法，非常费劲。今天我们就聊聊如何获取 ipa 包，下面这三种方式都经过亲自验证，可能由于不同环境会出现异常，若遇到问题可以到【知识小集】gong-Zhong-Hao 留言。如果你有更好的方式，不妨分享出来。</p><h3 id="方式一：iTunes"><a href="#方式一：iTunes" class="headerlink" title="方式一：iTunes"></a>方式一：iTunes</h3><p>苹果既然在高版本的 iTunes 取消了获取 ipa 包的入口，那我们就想办法降级处理。需要下载低版本的 iTunes。 <a href="http://secure-appldnld.apple.com/itunes12/091-33628-20170922-EF8F0FE4-9FEF-11E7-B113-91CF9A97A551/iTunes12.6.3.dmg" target="_blank" rel="noopener">下载</a>。</p><p>下载完后，安装，第一次启动的时候按住 option 键，这样才不会报错，安装完成后，即可下载应用的 ipa 包。下载完成后，在应用的图标上按右键，show in finder 即可找到 ipa 包。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/06/4-1.jpg" alt></p><h3 id="方式二：pp助手"><a href="#方式二：pp助手" class="headerlink" title="方式二：pp助手"></a>方式二：pp助手</h3><p>电脑安装一个 pp助手客户端，直接下载越狱应用，下载完成后，即可在“本地应用”中找打 APP 的 ipa 包。需要强调一点，这种方式下载的应用是解密后的 ipa。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/06/4-2.jpg" alt></p><h3 id="方式三：抓包"><a href="#方式三：抓包" class="headerlink" title="方式三：抓包"></a>方式三：抓包</h3><p>在 Mac 中的 iTunes 中下载应用，通过 Charles 抓包获取到 ipa 包的下载地址，直接在浏览器中下载，下载地址是在 p52-buy.itunes 这个域名下。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/06/4-3.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用 NSDecimalNumber 处理 iOS 中的货币金额</title>
      <link href="/2018/07/01/2018/7/yong-nsdecimalnumber-chu-li-ios-zhong-de-huo-bi-jin-e/"/>
      <url>/2018/07/01/2018/7/yong-nsdecimalnumber-chu-li-ios-zhong-de-huo-bi-jin-e/</url>
      
        <content type="html"><![CDATA[<h2 id="用-NSDecimalNumber-处理-iOS-中的货币金额"><a href="#用-NSDecimalNumber-处理-iOS-中的货币金额" class="headerlink" title="用 NSDecimalNumber 处理 iOS 中的货币金额"></a>用 NSDecimalNumber 处理 iOS 中的货币金额</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>在iOS开发中，经常遇到货币金额的表示与计算，你可能会使用 double 或 float 这样的浮点数，也可能使用 NSString 。无论用哪个，都需要再编写繁琐的精度控制、小数位数控制等代码。其实，苹果为我们提供了一个标准类 NSDecimalNumber 来处理这样的需求。</p><p>NSDecimalNumber 是 NSNumber 的子类，它提供了完善的初始化方法。对于令人头疼的金额计算，它还提供了贴心的加、减、乘、除运算方法。在进行这些运算的时候，你还可以通过 NSDecimalNumberHandler 对象来对运算的处理策略进行设置，比如舍入模式的选择，数据溢出、除零等异常情况的处理等。</p><p>下次遇到货币金额的需求，不妨了解一下 NSDecimalNumber。</p><p>参考资料：</p><ul><li><a href="https://www.jianshu.com/p/ea4da259a062" target="_blank" rel="noopener">https://www.jianshu.com/p/ea4da259a062</a></li><li><a href="https://www.jianshu.com/p/25d24a184016" target="_blank" rel="noopener">https://www.jianshu.com/p/25d24a184016</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>添加沙箱技术测试员报错的问题</title>
      <link href="/2018/07/01/2018/7/tian-jia-sha-xiang-ji-zhu-ce-shi-yuan-bao-cuo-de-wen-ti/"/>
      <url>/2018/07/01/2018/7/tian-jia-sha-xiang-ji-zhu-ce-shi-yuan-bao-cuo-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="添加沙箱技术测试员报错的问题"><a href="#添加沙箱技术测试员报错的问题" class="headerlink" title="添加沙箱技术测试员报错的问题"></a>添加沙箱技术测试员报错的问题</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>在测试IAP的时候需要添加沙箱技术测试员，相当于创建一个虚拟的AppleID，填写的邮箱是不能写真实AppleID邮箱的，要不然就会报错，可以随意写一个不存在的邮箱，为了方便，创建一个简短的密码就会报错误:</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/12-1.jpg" alt></p><p>按照提示改好后，依然报错:</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/12-2.jpg" alt></p><p>并且没有任何的提示，感觉这点好坑，尝试了N遍之后发现是密码的复杂度不够，要包含大小写和数字，虽然是虚拟的AppleID，但是密码规则要和正式的AppleID一样，希望以后苹果把错误提示做的更好吧！😂</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>提高Shortcuts调试效率的小技巧</title>
      <link href="/2018/07/01/2018/7/ti-gao-shortcuts-diao-shi-xiao-lu-de-xiao-ji-qiao/"/>
      <url>/2018/07/01/2018/7/ti-gao-shortcuts-diao-shi-xiao-lu-de-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="提高Shortcuts调试效率的小技巧"><a href="#提高Shortcuts调试效率的小技巧" class="headerlink" title="提高Shortcuts调试效率的小技巧"></a>提高Shortcuts调试效率的小技巧</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>iOS12提供了<code>Shortcuts</code>的功能，今天给大家介绍2个苹果提供的提高<code>Shortcuts</code>调试效率的小技巧。</p><ul><li><code>Shortcuts</code>是可以通过Siri唤起的，如果每次调试的时候都要和Siri说一次短语，既浪费时间又打扰旁边正在工作的同事，Xcode提供了<code>Siri Intent Query</code>功能，在调试<code>Intents Extension</code>或者<code>Intens UI Extension</code>的target时，直接在里面输入你要说的短语，就可去省去调戏Siri的时间啦。</li></ul><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/4-1.png" alt></p><ul><li>在<code>iPhone设置</code>-&gt;<code>开发者</code>里面提供了<code>Display Recent Shorts</code>和<code>Display Donations on Lock Screen</code>的开关，可以忽略系统当前的建议和预测，显示我们需要调试的<code>Shortcuts</code>；同时还支持<code>Force Sync Shortcuts to Watch</code>的功能，手动去强制同步到Watch，会节省很多时间哦！</li></ul><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/4-2.png" alt></p><p>我觉得这2个小技巧还是很实用的，如果有其它小技巧欢迎一起交流！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>怎么解决网络请求的依赖关系</title>
      <link href="/2018/07/01/2018/7/zen-me-jie-jue-wang-luo-qing-qiu-de-yi-lai-guan-xi/"/>
      <url>/2018/07/01/2018/7/zen-me-jie-jue-wang-luo-qing-qiu-de-yi-lai-guan-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么解决网络请求的依赖关系"><a href="#怎么解决网络请求的依赖关系" class="headerlink" title="怎么解决网络请求的依赖关系"></a>怎么解决网络请求的依赖关系</h2><p><strong>作者</strong>: <a href="https://weibo.com/cimer" target="_blank" rel="noopener">蒋匿</a></p><p>怎么解决网络请求的依赖关系：当一个接口的请求需要依赖于另一个网络请求的结果﻿?</p><p>1) 思路 1：操作依赖：NSOperation 操作依赖和优先级。</p><p>例如<code>[operationB addDependency:operationA]</code>; 虽然这个想法很好，但不适用异步，异步网络请求并不是立刻返回，无法保证回调时再开启下一个网络请求。</p><p>2) 思路 2：逻辑判断：在上一个网络请求的响应回调中进行下一网络请求的激活。</p><p>这是最原始的想法，但还是有 BUG：可能拿不到回调无法执行到 block 块里面的代码。</p><p>3) 思路 3：线程同步 – 组队列（<code>dispatch_group</code>）。</p><p>先建一个全局队列 queue，并新建一个 group(用 dispatch_group_create())，然后向 Group Queue 依次追加 block，最后用 dispatch_group_notify 添加 block。当前面的 block 全部执行完，就会执行最后的 block。例如下图。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/10-1.jpg" alt></p><p>4) 思路4：线程同步 –任务阻塞（<code>dispatch_barrier</code>）。</p><p>通过 dispatch_barrier_async 添加的操作会暂时阻塞当前队列，即等待前面的并发操作都完成后执行该阻塞操作，待其完成后后面的并发操作才可继续。使用 dispatch_barrier_async 可以实现类似组队列的效果。例如图2。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/10-2.jpg" alt></p><p>5) 思路5：线程同步 – 信号量机制（dispatch_semaphore）。</p><p>除了任务阻塞，还可以利用信号量实现这种阻塞效果：在异步开启任务 1 和任务 2 之前，初始化一个信号量并设置为 0，然后在任务 1 的 block 中写好请求操作，操作执行完后对前面的信号量加 1，在任务 2 的 block 中，需要在开始请求之前加上等待信号量的操作。这样一来，只有任务 1 中的请求执行完后，任务 2 等到了信号量加 1 才接着执行它的请求。例如图 3。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/10-3.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对AppStore在蜂窝网150MB的下载限制的理解</title>
      <link href="/2018/07/01/2018/7/dui-appstore-zai-feng-wo-wang-150mb-de-xia-zai-xian-zhi-de-li-jie/"/>
      <url>/2018/07/01/2018/7/dui-appstore-zai-feng-wo-wang-150mb-de-xia-zai-xian-zhi-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="对AppStore在蜂窝网150MB的下载限制的理解"><a href="#对AppStore在蜂窝网150MB的下载限制的理解" class="headerlink" title="对AppStore在蜂窝网150MB的下载限制的理解"></a>对AppStore在蜂窝网150MB的下载限制的理解</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>大家应该都有这样的一个印象：在蜂窝网下，<code>150MB</code>的包在AppStore是不能下载的，每当看到AppStore下面展示的Size接近<code>150MB</code>的时候就会很紧张，这意味着又要来一波艰难的减包操作了。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/8-1.png" alt></p><p>那么这个<code>150MB</code>指的是什么呢?是AppStore展示的Size么？我做了一个小小的调研，发现并非如此，<code>150MB</code>是包的下载大小，而AppStore里展示的Size是安装后（有解压操作）的大小，对几个App进行了抓包操作:（这个是前段时间的调研，因为版本迭代可能数据会有出入，但足以说明问题）</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/8-2.png" alt></p><p>从苹果之前的官方新闻也能看出端倪:</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/8-3.png" alt></p><p>所以说AppStore蜂窝下载限制指的是下载的实际大小而非AppStore展示的Size。</p><p>在ITC构建版本处理完成后，可以看到详细信息：在各个机型上的下载大小以及安装大小，同时也会提示你是<code>150MB</code>下载限制，超过限制还会给你一个黄色警告哦。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/8-4.png" alt></p><p>减包是一个任重而道远的事情，不要等到在<code>150MB</code>的危险边缘再去处理哦！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何更容易看懂宏</title>
      <link href="/2018/07/01/2018/7/ru-he-geng-rong-yi-kan-dong-hong/"/>
      <url>/2018/07/01/2018/7/ru-he-geng-rong-yi-kan-dong-hong/</url>
      
        <content type="html"><![CDATA[<h2 id="如何更容易看懂宏"><a href="#如何更容易看懂宏" class="headerlink" title="如何更容易看懂宏"></a>如何更容易看懂宏</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>相信你和我一样，也遇到过特别难理解的宏定义，比如宏与宏之间嵌套、带参数的宏。我们看个例子(这个宏并不是特别难，但也很绕)：</p><pre><code>#define JPBOXING_GEN(_name, _prop, _type) \+ (instancetype)_name:(_type)obj  \{   \    JPBoxing *boxing = [[JPBoxing alloc] init]; \    boxing._prop = obj;   \    return boxing;  \}JPBOXING_GEN(boxObj, obj, id)</code></pre><p>这个例子看着总是怪怪的，如果把上面的宏转换成实际代码，相信你会很容易看懂。</p><pre><code>+ (instancetype)boxObj:(id)obj{    JPBoxing *boxing = [[JPBoxing alloc] init];    boxing.obj = obj;    return boxing;}</code></pre><p>其实就是各种参数的替换导致阅读起来比较困难。我们都知道程序经过预处理后就会把宏转换为实际的代码，而 Xcode 为我们提供了对单个文件进行预处理（Produce -&gt; Perform Action -&gt; Preprocess ‘xxxx.m’），这样处理后，上面的宏就变成了：</p><pre><code>+ (instancetype)boxObj:(id)obj {    JPBoxing *boxing = [[JPBoxing alloc] init];    boxing.obj = obj;    return boxing; }</code></pre><p>经过预处理后和我们手动翻译的结果一样。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>你的项目中还用热修复吗？</title>
      <link href="/2018/07/01/2018/7/ni-de-xiang-mu-zhong-huan-yong-re-xiu-fu-ma/"/>
      <url>/2018/07/01/2018/7/ni-de-xiang-mu-zhong-huan-yong-re-xiu-fu-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="你的项目中还用热修复吗？"><a href="#你的项目中还用热修复吗？" class="headerlink" title="你的项目中还用热修复吗？"></a>你的项目中还用热修复吗？</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>前两天知识小集群里有人讨论关于热修复的问题，对此我非常感兴趣，今天作为一个小集和大家探讨一下。虽然目前苹果严禁带有热修复功能的 APP 上线，一旦发现，将增加审核时间（大约是一周的时间）。苹果主要考虑到了安全问题，避免给自己找事，所以干脆禁用了 JSPatch。但是 JSPatch 使用的 API 并没有违反苹果的规定，他也就没有一个十足的理由拒绝你的 APP 上线。这样就导致还有很多公司在悄悄地用 JSPatch。不过原理基本都是对 JSPatch 进行混淆后使用，当然如果你有能力自己实现一个 JSPatch 也可以。</p><p>被拒苹果的拒绝理由大概是这样的：</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/07/1-1.jpeg" alt></p><p>目前我了解到市面上主要通过以下几种方式进行混淆（如果对这个话题感兴趣，后续我们会在【知识小集】gong-zhong-hao 进一步探讨）：</p><h3 id="方式一：使用官方提供的混淆方式"><a href="#方式一：使用官方提供的混淆方式" class="headerlink" title="方式一：使用官方提供的混淆方式"></a>方式一：使用官方提供的混淆方式</h3><p>目前使用官方提供的 JSPatch 服务任然可以过审，据说也是通过静态混淆-宏定义 这中方式。</p><h3 id="方式二：Bugly（静态混淆-宏定义）"><a href="#方式二：Bugly（静态混淆-宏定义）" class="headerlink" title="方式二：Bugly（静态混淆-宏定义）"></a>方式二：Bugly（静态混淆-宏定义）</h3><p>Bugly 提供了热修复功能，它提供了一种对 JSPatch 混淆的方式。在 <code>BuglyHotfixConfuse_pch.h</code> 文件中把需要混淆的类名方法名替换掉。有兴趣的读者可以 <a href="https://bugly.qq.com/v2/downloads" target="_blank" rel="noopener">下载</a> 查看详细代码。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/07/1-2.jpeg" alt></p><h3 id="方式三：自己混淆"><a href="#方式三：自己混淆" class="headerlink" title="方式三：自己混淆"></a>方式三：自己混淆</h3><p>自己混淆当然是最保守的，苹果很难察觉。某天网上爆出一个 ZipArchive 安全漏洞，而这个漏洞的一个条件就是使用了类似 JSPatch 这种可以动态执行脚本的功能，而被爆出的 APP 经查确实使用混淆后 JSPatch，而他们采用的混淆方式也就是自己混淆。所以自己混淆 JSPatch 这条路是通的。自己混淆主要是理解 JSPatch 的原理，换一种方式来实现。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>两种 App 启动连续闪退检测策略</title>
      <link href="/2018/07/01/2018/7/liang-chong-app-qi-dong-lian-xu-shan-tui-jian-ce-ce-lue/"/>
      <url>/2018/07/01/2018/7/liang-chong-app-qi-dong-lian-xu-shan-tui-jian-ce-ce-lue/</url>
      
        <content type="html"><![CDATA[<h2 id="两种-App-启动连续闪退检测策略"><a href="#两种-App-启动连续闪退检测策略" class="headerlink" title="两种 App 启动连续闪退检测策略"></a>两种 App 启动连续闪退检测策略</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>当我们要做 App 日志上报时，需要考虑到一种行为：App 在启动时就崩溃闪退了，而且当遇到连续启动闪退（也就是每次打开 App 必崩）时，那几乎是灾难，但更可怕是，如果没有有效的监测手段，我们可能对已发生的这种线上严重问题毫不知情。</p><p>WeRead 团队博客的<a href="http://wereadteam.github.io/2016/05/23/GYBootingProtection/" target="_blank" rel="noopener">《iOS 启动连续闪退保护方案》</a>和 MrPeak 老师的<a href="http://mrpeak.cn/blog/ios-instacrash-reporting/" target="_blank" rel="noopener">《iOS App 连续闪退时如何上报 crash 日志》</a>分别介绍了两种简易的如何检测连续闪退的策略，在这里跟大家分享一下。</p><ul><li>计时器方法</li></ul><p>1）App 本地缓存维护一个计数变量，用于表示连续闪退的次数；</p><p>2）在启动入口方法 <code>application:didFinishLaunchingWithOptions:</code> 里判断 App 之前是否发生过连续闪退，如果有，则启动保护流程，自我修复，日志上报等，否则正常启动。判断的逻辑如下：</p><p>3）先取出缓存中的启动闪退计数 crashCount，然后把 crashCount 加 1 并保存；</p><p>4）接着使用 <code>dispatch_after</code> 方法在 5s 后清零计数，如果 App 活不过 5 秒计数就不会被清零，下次启动就可以读取到；</p><p>5）如果发现计数变量 &gt; maxCount，表明 App 连续 maxCount 次连续闪退，启动保护流程，重置计数。</p><p>具体的代码如下图所示：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/3-1.png" alt></p><p>这种计数器方法逻辑简单，与原有的代码耦合小。但存在误报可能（用户在启动 App 后又立即 kill 掉，会被误认为是 crash），不过可以通过设置时间阈值或者在 <code>applicationWillTerminate:</code> 里标记 App 是被手动 kill 来减少误报。</p><ul><li>时间数组比对</li></ul><p>我们可以在本地保存一个 App 每次启动时间、闪退时间、手动关闭时间的时间数组，然后在 App 启动时根据分析各个时间戳判断是否存在连续闪退（当闪退时间减去启动时间小于阈值 5 秒时，则认为是启动闪退），具体如下：</p><p>1）App 每次启动时，记录当前时间 launchTs，写入时间数组；</p><p>2）App 每次启动时，通过 crash 采集库，获取上次 crash report 的时间戳 crashTs，写入时间数组；</p><p>3）App 在接收到 <code>UIApplicationWillTerminateNotification</code> 通知时，记录当前时间戳 terminateTs，写入时间数组。注意，之所以要记录 terminateTs，是为了排除一种特殊情况，即用户启动 App 之后立即手动 kill app。</p><p>如果我们正确记录了上面三个时间戳，那么我们可以得到一个与 App crash 行为相关的时间线，如下图：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/3-2.png" alt></p><p>根据各种时间线的行为特征，我们只需要加上时间间隔判断，就能得知是否为连续两次闪退了。注意，如果两个 crashTs 之间如果存在 terminateTs，则不能被认为是连续闪退。</p><p>以上，介绍了两种检测 App 是否存在启动连续闪退的策略。</p><p>此外，对于连续闪退的保护方案以及连续闪退如何上报日志，请详细阅读开头提到的两篇博文。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一次内存泄漏后的思考</title>
      <link href="/2018/07/01/2018/7/yi-ci-nei-cun-xie-lou-hou-de-si-kao/"/>
      <url>/2018/07/01/2018/7/yi-ci-nei-cun-xie-lou-hou-de-si-kao/</url>
      
        <content type="html"><![CDATA[<h2 id="一次内存泄漏后的思考"><a href="#一次内存泄漏后的思考" class="headerlink" title="一次内存泄漏后的思考"></a>一次内存泄漏后的思考</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>最近项目中遇到一个内存泄漏的问题，SecondViewController 这个类在 pop 后并没有执行 dealloc 方法，也就没有被正常被释放。使用内存泄漏工具排查，并没有发现有循环引用的地方，手动查了一下也没发现异常。正在迷茫的时候，突然看到了一个注册监听的地方。实现方式类似下面这样：</p><pre><code>- (void)dealloc {    [[Manager sharedInstance] removeObserver:self];}- (void)viewDidLoad {    [super viewDidLoad];    self.view.backgroundColor = [UIColor whiteColor];    [[Manager sharedInstance] addObserver:self];}</code></pre><p>看到这里你应该已经猜到 SecondViewController 为什么没被释放，它被 Manager 持有了，而 Manager 是一个单例，自然 SecondViewController 也不会被释放，dealloc 方法也不会执行。</p><p>这种设计很常见，往往给某个服务注册监听，达到类似通知的效果。如果使用数组保存监听者，监听者将会被数组持有。有同学可能说，可以在 viewDidAppear 注册，在 viewWillDisappear 移除，这样 SecondViewController 就会被释放。但是，这样设计很糟糕，我们尽量不去约束调用者如何调用某个 API。</p><p>其实正确的做法是使用一个弱引用容器，我们可以使用 NSHashTable 来保存监听者，这样当监听者释放后，将自动从 NSHashTable 中移除，也不需要主动调用移除监听者的方法（也可以调用，视情况而定）。下面是一个简单的实现，你也可以参考 YYTextKeyboardManager 的实现：</p><pre><code>_listenerTable = [NSHashTable weakObjectsHashTable];- (void)addObserver:(NSObject *)obj {    [self.listenerTable addObject:obj];}- (void)removeObserver:(NSObject *)obj {    [self.listenerTable removeObject:obj];}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>静态 UITableView 两种 style 的差异</title>
      <link href="/2018/07/01/2018/7/jing-tai-uitableview-liang-chong-style-de-chai-yi/"/>
      <url>/2018/07/01/2018/7/jing-tai-uitableview-liang-chong-style-de-chai-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="静态-UITableView-两种-style-的差异"><a href="#静态-UITableView-两种-style-的差异" class="headerlink" title="静态 UITableView 两种 style 的差异"></a>静态 UITableView 两种 style 的差异</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>想必设置页应该是各大应用所必备的，相信大部分还是采用静态 <code>UITableView</code> 的方式在构建，我们项目中也用到了。最近测试反馈一个问题就是一些配置项的描述文案会盖住单元格内容，如图所示。由于之前配置项比较少，所以没有发现，最近新增了好几个配置，所以问题暴露出来了。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/7-1.png" alt></p><p>图中【接收哪些人】的私信是一个 <code>SectionFooter</code>，由于 <code>SectionFooter</code>是悬停的，内容超过一屏的情况下，<code>SectionFooter</code> 会将单元格挡住，由于 footer 背景是透明的，所以看起来是重叠的。由于 <code>tableView</code> 设置的 <code>style</code> 是 <code>Plain</code> 的，这种情况下 <code>SectionFooter</code> 和 <code>SectionHeader</code> 都是悬停的。如果要想他们不悬停，只需要把 <code>tableView</code> 的 <code>style</code> 设置成 <code>Grouped</code> 即可。</p><p>但是需要注意的是 <code>Grouped</code> 样式的 <code>SectionFooter</code> 是自带间隔的，会比 <code>Plain</code> 样式下的 <code>SectionFooter</code> 高 18pt，所以改成 <code>Grouped</code> 样式之后如果要同步 <code>Plain</code> 样式的间隔，这个 <code>tableView:heightForFooterInSection:</code> 代理方法返回的高度要减小18。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一个关于 GCD group 使用的小 tip</title>
      <link href="/2018/07/01/2018/7/yi-ge-guan-yu-gcd-group-shi-yong-de-xiao-tip/"/>
      <url>/2018/07/01/2018/7/yi-ge-guan-yu-gcd-group-shi-yong-de-xiao-tip/</url>
      
        <content type="html"><![CDATA[<h2 id="一个关于-GCD-group-使用的小-tip"><a href="#一个关于-GCD-group-使用的小-tip" class="headerlink" title="一个关于 GCD group 使用的小 tip"></a>一个关于 GCD group 使用的小 tip</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>在项目中看到一段使用 GCD group 处理的代码，简化下来大概如图1，dispatch_group_notify 的调用放在了 dispatch_group_async 的 block 中，乍一看会有是否产生永久阻塞的疑问，因为子任务完成后的派发任务被放在了一个子任务中。然而其实这是不会阻塞的，代码会按编写人的预期进行执行，即 log1 输出之后，输出 log2。这是因为 dispatch_group_notify 的 block 是异步执行的。<br><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/6-1.png" alt></p><p>再举个例子，如图2，执行结果依次会是：log 1，log 2 ，log 4 ，log 5 ，log 3。<br><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/6-2.png" alt></p><p>虽然此处结果正确，但这种将 dispatch_group_notify 的调用放在某一个子任务的执行块中的写法是不被推荐的，它不但反逻辑，而且并不总能保证结果正确。比如此例中，在调用了 dispatch_group_notify 的子任务之后，又为该任务组使用 dispatch_group_async 语句添加后续子任务，这时代码的执行结果是不确定的。</p><p>既然最开始的例子中执行结果是正确的，有的同学会问，如果把 dispatch_group_notify 的调用放在所有子任务的最前面，如图3，是否也能获得预期的结果呢？答案是否定的，因为在最开始调用 dispatch_group_notify 时，子任务数量为0，它的代码块会立即执行。而后为该组派发了多个子任务，当这些子任务都执行完毕后，也并不会再次触发 dispatch_group_notify 的代码块。<br><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/6-3.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vc多层push后回到指定页面的几种方法</title>
      <link href="/2018/07/01/2018/7/vc-duo-ceng-push-hou-hui-dao-zhi-ding-ye-mian-de-ji-chong-fang-fa/"/>
      <url>/2018/07/01/2018/7/vc-duo-ceng-push-hou-hui-dao-zhi-ding-ye-mian-de-ji-chong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="vc多层push后回到指定页面的几种方法"><a href="#vc多层push后回到指定页面的几种方法" class="headerlink" title="vc多层push后回到指定页面的几种方法"></a>vc多层push后回到指定页面的几种方法</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/6603469503" target="_blank" rel="noopener">这个汤圆没有馅</a></p><p>场景如下：<br>RootVC – &gt; A – &gt; B – &gt; C，然后现在要求C直接pop回到A。</p><p>方法一：C返回到B的时候写个回调，B接收到回调再自己pop到A，但是这个方法B的页面会闪现一下，用户体验不好，不推荐。</p><p>方法二：在B push 到C的时候，直接把B从导航控制器的堆栈中移除，如图一。<br><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/15-1.jpg" alt></p><p>方法三：写一个UIViewController的catrgory，方法实现如图二。在C的backAct方法中使用，如图三。有的同学可能会怀疑B会不会内存泄露，可以在B中打印dealloc。<br><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/15-2.jpg" alt><br><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/15-3.jpg" alt></p><p>这里比较推荐方法三。不论有多少级的push，只要传入指定页面的类名，都能回到该页面。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 内存泄露工具</title>
      <link href="/2018/07/01/2018/7/ios-nei-cun-xie-lu-gong-ju/"/>
      <url>/2018/07/01/2018/7/ios-nei-cun-xie-lu-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-内存泄露工具"><a href="#iOS-内存泄露工具" class="headerlink" title="iOS 内存泄露工具"></a>iOS 内存泄露工具</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>在日常开发中总会遇到内存泄漏的的问题，而排除内存泄漏一般会依靠以下这些工具：</p><ul><li><a href="http://wereadteam.github.io/2016/02/22/MLeaksFinder/" target="_blank" rel="noopener">MLeaksFinder</a></li></ul><p>这个 WeRead 团队开发的一个内存泄漏检测工具，主要用来检测 UIViewController 和 UIView 中存在的内存泄漏。如果检查到内存泄漏，会弹出 Alert 提示存在内存泄漏。当然，如果某个 UIViewController 是单例，将会误检。</p><p>如果检查出内存泄漏，点击 Alert 上的 <code>Retain Cycle</code> 将使用 FBRetainCycleDetector 检查存在循环引用的对象。比如：</p><pre><code>-&gt; DownloadAudioListViewController ,-&gt; _callblock -&gt; __NSMallocBlock__ </code></pre><ul><li><a href="https://github.com/facebook/FBRetainCycleDetector" target="_blank" rel="noopener">FBRetainCycleDetector</a></li></ul><p>这是 facebook 开源的一个内存泄漏检测工具，它可以检测出循环引用：</p><pre><code>FBRetainCycleDetector *detector = [FBRetainCycleDetector new];[detector addCandidate:myObject];NSSet *retainCycles = [detector findRetainCycles];</code></pre><p>检查出的内存泄漏将打印出来：</p><pre><code>-&gt; DownloadAudioListViewController ,-&gt; _callblock -&gt; __NSMallocBlock__ </code></pre><ul><li><a href="https://juejin.im/entry/58b105b48ac24728d53e28cf" target="_blank" rel="noopener">Instrument 的 Leak 工具</a></li></ul><p>Instrument 中的 Leak 工具主要用来“突袭”，开发者定期地使用它来检测内存泄漏。而上面介绍的工具主要在开发过程中即可发现内存问题，提前暴露给开发者。</p><ul><li>[Xcode 中的 Debug Memory Graph]</li></ul><p>这个工具主要以图表的形式显示了当前内存的使用情况，可以查看循环引用，如果有内存问题会显示一个叹号。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git 恢复误删的 stash</title>
      <link href="/2018/07/01/2018/7/git-hui-fu-wu-shan-de-stash/"/>
      <url>/2018/07/01/2018/7/git-hui-fu-wu-shan-de-stash/</url>
      
        <content type="html"><![CDATA[<h2 id="git-恢复误删的-stash"><a href="#git-恢复误删的-stash" class="headerlink" title="git 恢复误删的 stash"></a>git 恢复误删的 stash</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>日常开发过程中，相信大家都使用 git，团队协作使用 git-flow。也经常会遇到需求做到一半，产品或者测试反馈一个线上问题，不得不 stash 当前已经写了一半的代码，然后切回到 master 查看问题，然后又恢复回原来的 stash。但是这样操作有时候可能会把之前 stash 的代码误删，辛辛苦苦写的代码说没就没了。那么问题来了，stash 能否像 commit 那样可以随时恢复？</p><p>答案当然是肯定的。我们知道只要有提交记录，git 肯定能恢复。其实 stash 某种程度上也可以看做一种 commit，如果还记得当时 stash 的名称，就更加容易恢复了。可以使用如下命令行来恢复，其中 ‘your stash name’ 处填入 stash 操作时留的名称</p><pre><code>$ git fsck 2&gt; /dev/null | awk &#39;/commit/{print $3}&#39; | git show --stdin --grep &#39;your stash name&#39;</code></pre><p>最终可以在终端中看到一些 commit 信息和日期，找到对应想恢复的 SHA，然后执行</p><pre><code>$ git stash apply your-commit-sha</code></pre><p>关于第一处代码的解释：</p><blockquote><ol><li>The funny 2&gt; /dev/null part ignores all error messages (they are thrown to /dev/null a dark hole in every UNIX system).</li><li>git fsck checks your repo for orphaned commits.</li><li>This prints a list of information, containing the id of the commit and it’s type, for example:</li></ol></blockquote><pre><code>   dangling commit 6108663eaaac4b7e850f6d492cf83e7b65db2c97   dangling commit b526a825c7730075eb5938917c8b8b7a98f63cdf   dangling commit 04479ae959fc7470d04e1743f1c7149414c366fa   dangling blob c6609e5099056da80ea1cdf5bea302225bd6b7ed   dangling commit 9d65fa867f23d28ce618fcb5d7988180efb67f9c</code></pre><blockquote><ol start="4"><li>We’re after commit ids, which is the third part of each line, so we run: awk ‘/commit/{print $3}’ to obtain the third part of each line.</li><li>git show shows information about that particular commit. So if we filter and print those containing the bug number… voilà!</li></ol></blockquote><p><strong>参考</strong> </p><p><a href="https://mobilejazz.com/blog/how-to-recover-a-deleted-git-stash/" target="_blank" rel="noopener">How to recover a deleted git stash</a></p><p><a href="https://stackoverflow.com/a/34751863" target="_blank" rel="noopener">Can we recover deleted commits? </a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode 断点调试时打印变量值报错的问题（编译优化相关）</title>
      <link href="/2018/07/01/2018/7/xcode-duan-dian-diao-shi-shi-da-yin-bian-liang-zhi-bao-cuo-de-wen-ti-bian-yi-you-hua-xiang-guan/"/>
      <url>/2018/07/01/2018/7/xcode-duan-dian-diao-shi-shi-da-yin-bian-liang-zhi-bao-cuo-de-wen-ti-bian-yi-you-hua-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="Xcode-断点调试时打印变量值报错的问题（编译优化相关）"><a href="#Xcode-断点调试时打印变量值报错的问题（编译优化相关）" class="headerlink" title="Xcode 断点调试时打印变量值报错的问题（编译优化相关）"></a>Xcode 断点调试时打印变量值报错的问题（编译优化相关）</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>在日常开发中，我们经常会在 Debug 模式下打断点进行调试，并通过 LLDB 的 <code>po</code> 命令在控制台打印一些变量的值，以方便排查问题。</p><p>今天在 Release 模式下编译运行项目，发现要打印某一变量的值时（<code>po xxx</code>），报如下错误：</p><pre><code>error: Couldn&#39;t materialize: couldn&#39;t get the value of variable xxx: no location, value may have been optimized outerror: errored out in DoExecute, couldn&#39;t PrepareToExecuteJITExpression</code></pre><p>大致意思是说，<code>xxx</code> 的值不存在，可能已经被编译优化了。而且在断点模式下当我们把鼠标的箭头移到某一变量上要进行快速浏览时，发现它们的值都是 <code>nil</code>。</p><p>查了一下才发现，原来这与 Xcode 工程的编译选项 <code>Optimization Level</code> 设置有关，它是指编译器的优化级别，优化后的代码效率比较高，但是可读性比较差，且编译时间更长，它有 6 个选项值如下图：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/5-1.png" alt></p><p>上述每选项值的详细说明可以参考<a href="https://www.jianshu.com/p/b38052ee56af" target="_blank" rel="noopener">《Xcode 中 Optimization Level 的设置》</a>和<a href="https://www.zybuluo.com/qidiandasheng/note/587124" target="_blank" rel="noopener">《如何加快编译速度》</a>两篇文章，我们这里不再赘述。</p><p>Xcode 工程的 <code>Optimization Level</code> 值在 Debug 模式下默认为 <code>None [-O0]</code>，表示编译器不会尝试优化代码，保证调试时输出期望的结果；而在 Release 模式下默认为 <code>Fastest, Smallest[-Os]</code>，表示编译器将执行所有优化，且不会增加代码的长度，它是可执行文件占用更少内存的首选方案。</p><p>这也是为什么我们在 Release 模式下断点打印变量会报错，因为编译器已经给代码做了优化，它将不在调试时记录变量的值了。</p><p>此外，有时候遇到一些线上 Bug 但是在 Debug 调试时却无法复现，我猜有可能会跟编译优化有关，你觉得呢？欢迎留言讨论。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WWDC 2018 苹果推荐的大图加载方式</title>
      <link href="/2018/07/01/2018/7/wwdc-2018-ping-guo-tui-jian-de-da-tu-jia-zai-fang-shi/"/>
      <url>/2018/07/01/2018/7/wwdc-2018-ping-guo-tui-jian-de-da-tu-jia-zai-fang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="WWDC-2018-苹果推荐的大图加载方式"><a href="#WWDC-2018-苹果推荐的大图加载方式" class="headerlink" title="WWDC 2018 苹果推荐的大图加载方式"></a>WWDC 2018 苹果推荐的大图加载方式</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>在 iOS 开发中，图片载入到内存中占用的空间和它的二进制文件大小无关，而是基于图片的尺寸。在 WWDC 2018 中，苹果为我们建议了一种大家平时使用较少的大图加载方式，它的实际占用内存与理论值最为接近。下面是示例代码：</p><pre><code>func downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -&gt; UIImage{let sourceOpt = [kCGImageSourceShouldCache : false] as CFDictionary// 其他场景可以用createwithdata (data并未decode,所占内存没那么大),let source = CGImageSourceCreateWithURL(imageURL as CFURL, sourceOpt)!let maxDimension = max(pointSize.width, pointSize.height) * scalelet downsampleOpt = [kCGImageSourceCreateThumbnailFromImageAlways : true,kCGImageSourceShouldCacheImmediately : true ,kCGImageSourceCreateThumbnailWithTransform : true,kCGImageSourceThumbnailMaxPixelSize : maxDimension] as CFDictionarylet downsampleImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOpt)!return UIImage(cgImage: downsampleImage)}</code></pre><p>参考资料：<a href="https://juejin.im/post/5b2ddfa7e51d4553156be305" target="_blank" rel="noopener">https://juejin.im/post/5b2ddfa7e51d4553156be305</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UIViewController 设置导航栏和标签栏不同 title 的问题</title>
      <link href="/2018/07/01/2018/7/uiviewcontroller-she-zhi-dao-hang-lan-he-biao-qian-lan-bu-tong-title-de-wen-ti/"/>
      <url>/2018/07/01/2018/7/uiviewcontroller-she-zhi-dao-hang-lan-he-biao-qian-lan-bu-tong-title-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="UIViewController-设置导航栏和标签栏不同-title-的问题"><a href="#UIViewController-设置导航栏和标签栏不同-title-的问题" class="headerlink" title="UIViewController 设置导航栏和标签栏不同 title 的问题"></a>UIViewController 设置导航栏和标签栏不同 title 的问题</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>我们通常会在一个 <code>UIViewController</code> 的 <code>viewDidLoad</code> 方法中通过 <code>self.title = xxx</code> 的方式给一个页面设置其导航栏标题，相信大家对这再熟悉不过了。</p><p>如果一个 VC 页面中同时具有 <code>NavigationBar</code>（导航栏）和 <code>TabBar</code>（标签栏），而且我们又想让这两个地方的标题显示不一致，如下图所示，在首页顶部导航栏标题中显示“知识小集”，而在底部标签栏标题中显示“首页”：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/13-1.jpg" alt></p><p>但是，当我们在 <code>UITabBarController</code> 中初始化好上述页面结构后，且设置首页 VC 的 <code>tabBarItem.title</code> 为 “首页”，然后在首页 VC 的 <code>viewDidLoad</code> 方法中设置 <code>self.title</code> 为 “知识小集”，编译运行后我们发现首页底部标签栏的标题也变成“知识小集”了，而不是刚设置的“首页”。</p><p>查了苹果文档中关于 <code>UIViewController</code> 中 <code>title</code> 属性的定义，有如下一段描述：</p><blockquote><p>If the view controller has a valid navigation item or tab-bar item, assigning a value to this property updates the title text of those objects.</p></blockquote><p>也就是说，如果一个 VC 同时有导航栏和标签栏，那么当给 <code>title</code> 赋值时，会同时修改这两个地方的标题。所以如果我们只想设置导航栏的标题，可以通过 <code>self.navigationItem.title = xxx</code> 的方式来实现。</p><p>因此，在一个 VC 中设置相关标题简单总结如下：</p><ul><li><p><strong>self.navigationItem.title:</strong> 设置 VC 顶部导航栏的标题</p></li><li><p><strong>self.tabBarItem.title:</strong> 设置 VC 底部标签栏的标题</p></li><li><p><strong>self.title:</strong> 同时修改上述两处的标题</p></li></ul><p>参考文档：<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621364-title?language=objc" target="_blank" rel="noopener">UIViewController.title</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift 版本建私有库时需要注意的地方</title>
      <link href="/2018/07/01/2018/7/swift-ban-ben-jian-si-you-ku-shi-xu-yao-zhu-yi-de-di-fang/"/>
      <url>/2018/07/01/2018/7/swift-ban-ben-jian-si-you-ku-shi-xu-yao-zhu-yi-de-di-fang/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift-版本建私有库时需要注意的地方"><a href="#Swift-版本建私有库时需要注意的地方" class="headerlink" title="Swift 版本建私有库时需要注意的地方"></a>Swift 版本建私有库时需要注意的地方</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/6603469503" target="_blank" rel="noopener">这个汤圆没有馅</a></p><p>利用 <code>cocoapods</code> 建 <code>swift</code> 版本私有库步骤和 <code>OC</code> 版本一样，只要把语言 <code>Objc</code> 切换成 Swift 即可。一般情况下，<code>pod lib lint</code>验证会报警告，如下图，加 <code>--allow-warnings</code> 直接忽略即可。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/11-1.jpg" alt></p><p>但是如果私有库里依赖了其他三方库，且该三方库的 swift 版本不一致，则 pod lib lint 会报一堆 error，如下图。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/11-2.jpg" alt></p><p>这个时候就需要根据警告里的提示配置 <code>.swift-version</code>。该文件默认情况是不会有的，需要手动添加，如下图。这个时候再次执行 <code>pod lib lint --allow-warnings</code> 验证就能通过。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/11-3.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UIAlertView 与输入框结合使用时的一个坑</title>
      <link href="/2018/07/01/2018/7/uialertview-yu-shu-ru-kuang-jie-he-shi-yong-shi-de-yi-ge-keng/"/>
      <url>/2018/07/01/2018/7/uialertview-yu-shu-ru-kuang-jie-he-shi-yong-shi-de-yi-ge-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="UIAlertView-与输入框结合使用时的一个坑"><a href="#UIAlertView-与输入框结合使用时的一个坑" class="headerlink" title="UIAlertView 与输入框结合使用时的一个坑"></a>UIAlertView 与输入框结合使用时的一个坑</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>相信 <code>UIAlertView</code> 大家应该都很熟悉，但是最近遇到一个坑。</p><p>由于历史原因，项目中还在大量使用 <code>UIAlertView</code>。某天测试过来反馈说，评论框字符长度超过最大长度时，点击发送，弹出一个 <code>alert</code> 提示，点击确定后，评论框无法在被激活，也就是没法弹出键盘了。很是怪异，<code>debug</code> 无果，搜了一下 <code>stackoverflow</code>，发现有人遇到过类似的问题，可以点击末尾的参考链接来查看具体详情。</p><p>他给出的解决方案就是把这种情况下的 <code>UIAlertView</code> 换成 <code>UIAlertController</code>。试了下这种方式，果然是可行的，由于之前 <code>UIAlertView</code> 是不依赖其它视图层级的，创建后直接 <code>show</code> 就可以了，所以很多地方直接写在了非视图控制器类中。在换成 <code>UIAlertController</code> 之后，由于它是继承自 <code>UIViewController</code> 的，所以必须要有 VC 把它 <code>present</code> 起来。解决方案也很简单，写一个 <code>UIViewController</code> 的分类获取当前顶部可见的 <code>ViewController</code>，然后在上面 <code>present</code> 出 <code>UIAlertController</code> 即可，获取顶部可见 <code>ViewController</code> 的代码随便一搜就可以找到，这边就不贴了。</p><blockquote><p>PS：<code>UIAlertController</code> 是 <code>iOS8</code> 以后才提供的，不过相信大家也不用适配 <code>iOS8</code> 之前的系统了吧😂。如果还要适配，那就只能做版本区分了。。。</p></blockquote><p><strong>参考</strong> </p><p><a href="https://stackoverflow.com/questions/32744209/ios-9-keyboard-pops-up-after-uialertview-dismissed" target="_blank" rel="noopener">iOS 9 - Keyboard pops up after UIAlertView dismissed</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Storyboard/Xib 颜色空间的坑</title>
      <link href="/2018/07/01/2018/7/storyboard-xib-yan-se-kong-jian-de-keng/"/>
      <url>/2018/07/01/2018/7/storyboard-xib-yan-se-kong-jian-de-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="Storyboard-Xib-颜色空间的坑"><a href="#Storyboard-Xib-颜色空间的坑" class="headerlink" title="Storyboard/Xib 颜色空间的坑"></a>Storyboard/Xib 颜色空间的坑</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>今天分享一下 <code>Xcode Interface Builder</code> 设置背景色的一个坑。从 <code>Xcode8</code> 起，<code>Xib/Storyboard</code> 里的颜色空间默认从 <code>Generic RGB</code> 换成了 <code>sRGB</code>，但又不是所有的都会转换，很奇怪。所以当时在适配 <code>Xcode8</code> 的时候，颜色空间都统一全局替换了一遍。最近又遇到一次这个坑，在 <code>Storyboard</code> 把某个视图背景色从白色更改为 <code>0xf0f1f2</code>，然后 run 起来，和其 <code>superview</code> (<code>superview</code> 的背景色是用代码设置的 <code>0xf0f1f2</code>)竟然有一个明显的分割线，所以回想起当时适配时的这个问题，然后取到 <code>Storyboard</code> 里面一看，果然是颜色空间被莫名改为了 <code>Generic RGB</code>，如图所示。所以手动改变其颜色空间为 <code>sRGB</code> 即可。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/14-1.jpg" alt></p><p>参考链接：<a href="http://t.cn/RgpFOPg、http://t.cn/ReADdu7" target="_blank" rel="noopener">http://t.cn/RgpFOPg、http://t.cn/ReADdu7</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C import 第三方库头文件总结</title>
      <link href="/2018/07/01/2018/7/objective-c-import-di-san-fang-ku-tou-wen-jian-zong-jie/"/>
      <url>/2018/07/01/2018/7/objective-c-import-di-san-fang-ku-tou-wen-jian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="Objective-C-import-第三方库头文件总结"><a href="#Objective-C-import-第三方库头文件总结" class="headerlink" title="Objective-C import 第三方库头文件总结"></a>Objective-C import 第三方库头文件总结</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>当我们的 iOS 工程要引用其它第三方开源库时，一般有以下几种方式：</p><p>（1）下载源代码直接拖拽到工程中；</p><p>（2）使用 CocoaPods 管理，当开启 <code>use_frameworks!</code> 标记时，第三方库会被编译成 <code>.framework</code> 引入工程，否则就会编译成 <code>.a</code> 静态库；</p><p>（3）使用 Carthage 管理，第三方库会被编译成 <code>.framework</code> 然后导入工程；</p><p>（4）直接下载作者编译好的 <code>.framework</code> 导入工程。</p><p>但当我们在代码中要 import 第三方库的头文件时，对于这几种情况，写法都不太一样，以 <code>AFNetworking</code> 为例，总结如下：</p><ul><li>对于（1）拖拽源码，只能以 <code>&quot;&quot;</code> 引号的方式 import，</li></ul><pre class=" language-objc"><code class="language-objc">#import "AFNetworking.h"</code></pre><ul><li>对于（2）CocoaPods，如果开启 <code>use_frameworks!</code>，则将编译成 <code>.framework</code> 库，只能以 <code>&lt;&gt;</code> 尖括号的方式 import，<strong>此外，对于（3）和（4）也是这样</strong>，</li></ul><pre class=" language-objc"><code class="language-objc">#import <AFNetworking/AFNetworking.h></code></pre><ul><li>而对于 CocoaPods，如果不开启 <code>use_frameworks!</code>，则将编译成 <code>.a</code> 库，此时有如下 3 种方式 import，</li></ul><pre class=" language-objc"><code class="language-objc">#import "AFNetworking.h"// 或者#import <AFNetworking.h>// 或者#import <AFNetworking/AFNetworking.h></code></pre><p>那么问题来了，如果我们在写一个 SDK 或者私有的 Pods 库，需要宿主 App 工程引用某一个第三方库，如上所述，宿主工程有很多方式引用第三方库，这样我们就无法确定应该以哪种方式 import 头文件，怎么办呢？这时候我们就可以使用 <code>__has_include()</code> 宏来判断。</p><p><code>__has_include()</code> 宏接收一个预引入的头文件名称（引号或者尖括号都可以）作为参数，如果该头文件能够被引入则返回 <code>1</code>，否则返回 <code>0</code>，使用起来如下：</p><pre class=" language-objc"><code class="language-objc">#if __has_include(<AFNetworking/AFNetworking.h>)#import <AFNetworking/AFNetworking.h>#else#import "AFNetworking.h"#endif</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Assets的几个方便用法</title>
      <link href="/2018/07/01/2018/7/assets-de-ji-ge-fang-bian-yong-fa/"/>
      <url>/2018/07/01/2018/7/assets-de-ji-ge-fang-bian-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="Assets的几个方便用法"><a href="#Assets的几个方便用法" class="headerlink" title="Assets的几个方便用法"></a>Assets的几个方便用法</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>Assets想必大家都使用过，今天聊几个Assets比较方便的用法。</p><ul><li>在工程中，某个通用的颜色，我们可能会用宏或者全局变量来表示，这样可以方便大家的使用，但有一个弊端，在<code>storyboard</code>或者<code>xib</code>布局的时候，设置颜色依旧要去设置具体的RGB值；而Assets给我们提供了一个很方便的功能，可以创建<code>New Color Set</code>，就弥补了刚才方案的缺陷（如图1，图2），并且代码中使用也很方便。</li></ul><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/2-1.jpg" alt></p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/2-2.jpg" alt></p><ul><li>在需要拉伸图片的时候，通常会使用UIImage的API的<code>-[UIImage  resizableImageWithCapInsets:resizingMode:]</code>这个方法；而Assets为我们提供了Slicing的功能（如图3），在Assets中直接设置后，在storyboard和xib中就可以直接显示拉伸后的图片，在代码中使用也及其方便，直接用<code>-[UIImage imageNamed:]</code>方法即可。</li></ul><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/2-3.jpg" alt></p><ul><li>如果是Universal的工程，同一个UIImageView，在iPhone中显示图片A，在iPad中显示图片B，Assets可以很方便的通过<code>Devices</code>设置，会让代码看着很清爽，不会存在判断机型再去设置图片的恶心代码。在设置横竖屏的时候也可以充分利用<code>Width Class</code>和<code>Height Class</code>两个参数（如图4）。</li></ul><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/07/2-4.jpg" alt></p><p>我觉得这3个用法在工作中还是很实用的，当然Assets还有其他很好用的功能，欢迎大家一起交流。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些 UI 性能优化的 tips</title>
      <link href="/2018/07/01/2018/7/yi-xie-ui-xing-neng-you-hua-de-tips/"/>
      <url>/2018/07/01/2018/7/yi-xie-ui-xing-neng-you-hua-de-tips/</url>
      
        <content type="html"><![CDATA[<h2 id="一些-UI-性能优化的-tips"><a href="#一些-UI-性能优化的-tips" class="headerlink" title="一些 UI 性能优化的 tips"></a>一些 UI 性能优化的 tips</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><ul><li>圆角效果：圆角效果的优化老生常谈，产生性能问题的根源在于原生圆角效果带来的离屏渲染开销。通常我们推荐直接使用圆角的素材，或者提前在子线程将图片进行圆角裁剪，这两者原理相同。除此之外，还有一种思路是在需要圆角的视图最上层添加一个中空的圆角遮罩层，以此来做出圆角效果。这个遮罩层和被盖在下面的视图在显示时会由 GPU 进行图层混合，而图层混合的开销远小于离屏渲染。值得一提的是，由于圆角效果通常在一屏中频繁出现，所以这个遮罩的图片素材可以只加载一次，并且应用于每一个圆角视图，避免重复加载。</li><li>阴影效果：值得注意的是系统原生的阴影实现要求 layer 的 masksToBounds 值为 YES，所以原生的阴影效果和圆角是不兼容的。高效的阴影实现是为阴影指定 shadowPath，如果你还没用的话，不妨试一下。</li><li>适时替换轻量控件：@ibireme 在他的性能优化文章中提出在合适的时候用 CALayer 替换 UIView，这确实有效，不过盲目替换往往会造成代码维护的困难。这里举两个适合的场景：绘制线条时，完全可以替换。以及静态展示图片时，将图片对象赋值给 layer 的 content 属性，也完全可以达到效果。</li><li>图片解码：图片解码的知识不再赘述，值得一提的是，对于不同的图片格式，不同的解码算法，或者使用系统解码方法时的不同参数设置，都会影响解码性能，如果有这方面瓶颈的，不妨做多种尝试。</li></ul><p>再说一个经典的例子：为了实现一个简单的画板需求，有人会在 UIView 上频繁调用 drawRect 方法进行新笔划的绘制，殊不知有一个天生的专用图层对象 CAShapeLayer 是很适合做这件事的。CAShapeLayer 不需要像普通 CALayer 一样创建寄宿图，不会造成巨量内存的使用，并且它使用了硬件加速。</p><p>UI 性能优化时，我们常常需要实时监测帧率。这里讲一下 @ibireme 的帧率监测工具 YYFPSLabel 的实现原理：使用 CADisplayLink，在每帧的回调事件中，计数器 c 加一，并且累计时间间隔 t 也进行更新。当时间间隔够 1 秒后，使用 c/t 计算出过去 1 秒的帧率，而后计数器清零，时间戳更新为当前时间戳，再重复之前步骤。因此 YYFPSLabel 的帧率更新周期在 1 秒左右。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>提升终端体验的两把厉剑</title>
      <link href="/2018/06/01/2018/6/ti-sheng-zhong-duan-ti-yan-de-liang-ba-li-jian/"/>
      <url>/2018/06/01/2018/6/ti-sheng-zhong-duan-ti-yan-de-liang-ba-li-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="提升终端体验的两把厉剑"><a href="#提升终端体验的两把厉剑" class="headerlink" title="提升终端体验的两把厉剑"></a>提升终端体验的两把厉剑</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>在以往的小集中已介绍过 iTerm2 和 oh-my-zsh 的使用，如果你还不了解这两个工具，不妨到以往的小集中看看他们的作用，包您满意。而今天介绍另外两个提升终端体验的工具。</p><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>如果想在终端查看当前目录的层级结构，不妨了解下 tree，它可以以树状的形式显示当前的目录结构。</p><p>安装：<br>在终端输入：<code>brew install tree</code> 。</p><p>使用:<br>在当前目录下，显示树状目录结构：<code>tree -L 2 -d</code> 。其中 -L 表示遍历的深度，这里为 2；-d 表示只显示目录。更多参数可以使用 <code>man tree</code> 查看。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/06/2-1.jpg" alt></p><h3 id="Go2Shell"><a href="#Go2Shell" class="headerlink" title="Go2Shell"></a>Go2Shell</h3><p>有时候在 Finder 中的目录，想在终端中直接切换到 Finder 当前显示的目录。使用 Go2Shell 即可，一步到位，非常方便。在官网上 <a href="http://zipzapmac.com/Go2Shell" target="_blank" rel="noopener">下载</a>，安装，打开 Finder，按住 command 键，拖动 Go2Shell 的图标到 Finder 菜单，在 Finder 的菜单栏中会显示 Go2Shell 图标。下次想在终端显示当前 Finder 的目录，直接点击图标即可。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/06/2-2.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>延时动画的两种方式对比</title>
      <link href="/2018/06/01/2018/6/yan-shi-dong-hua-de-liang-chong-fang-shi-dui-bi/"/>
      <url>/2018/06/01/2018/6/yan-shi-dong-hua-de-liang-chong-fang-shi-dui-bi/</url>
      
        <content type="html"><![CDATA[<h2 id="延时动画的两种方式对比"><a href="#延时动画的两种方式对比" class="headerlink" title="延时动画的两种方式对比"></a>延时动画的两种方式对比</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>一般情况下，做延时动画有下面常见的两种方式，方式1采用 <code>UIView</code> 提供的带延迟参数的类方法，方式2则是使用 <code>NSObject</code> 的实例方法来延迟执行某个方法。如下图所示，二者都能在3秒之后做一个时长为0.3秒的渐隐动画，那区别在哪呢？</p><p>区别就在于：方式1在执行 <code>[self dismissWithDelay:3];</code> 后，<code>self</code> 的 <code>alpha</code> 会马上变成0（但还是可见的），导致点击事件不响应，方式2则可以正常响应。</p><p>原因在于 <code>UIView</code> 的动画类方法，只是对 <code>CoreAnimation</code> 的封装，在调用了该方法后，相当于给 <code>self.layer</code> 加了一个 <code>opacity</code> 的 <code>CABasicAnimation</code>。<code>self</code> 的 <code>modelLayer</code> 的透明度（<code>opacity</code>）已经被设置成了动画结束时的值（0）（<code>modelLayer</code> 的属性和 <code>view</code> 的对应属性是一致的，比如这里的 <code>modelLayer</code> 的 <code>opacity</code> 和 <code>view</code> 的 <code>alpha</code>），进而导致无法响应点击事件。<code>presentationLayer</code> 则是动画过程中近似我们实时看到的内容。</p><p>所以一般情况下，如果延时动画操作的是 <code>alpha</code> 或者 <code>hidden</code> 属性，建议采用 <code>performSelector:withObject:afterDelay:</code> 的方式，这样可以在延迟时间未到之前还是能够响应对应的交互。</p><p>PS：如果想在延时还未到的时候取消，方式1可以采用 <code>[self.layer removeAllAnimations]</code>，方式2可以采用 <code>[NSObject cancelPreviousPerformRequestsWithTarget:self]</code> 的方式。</p><p>更多关于 <code>CoreAnimation</code> 的内容可以查看 <a href="https://objccn.io/issue-12-1/" target="_blank" rel="noopener">动画解释</a> 以及 <a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques" target="_blank" rel="noopener">iOS-Core-Animation-Advanced-Techniques</a>。</p><pre class=" language-objc"><code class="language-objc">// 方式1- (void)dismissWithDelay:(NSTimeInterval)delay {    [UIView animateWithDuration:0.3                          delay:delay                        options:UIViewAnimationOptionCurveEaseInOut|UIViewAnimationOptionAllowUserInteraction                     animations:^{                         self.alpha = 0.f;                     }                     completion:^(BOOL finished) {                     }];}[self dismissWithDelay:3];NSLog(@"%f, %f, %f", self.alpha, self.layer.presentationLayer.opacity, self.layer.modelLayer.opacity);      // ---> 0.000000, 1.000000, 0.000000// 方式2- (void)dismiss {    [UIView animateWithDuration:0.3                          delay:0                        options:UIViewAnimationOptionCurveEaseInOut|UIViewAnimationOptionAllowUserInteraction                     animations:^{                         self.alpha = 0.f;                     }                     completion:^(BOOL finished) {                     }];}[self performSelector:@selector(dismiss) withObject:nil afterDelay:3 inModes:@[NSRunLoopCommonModes]];NSLog(@"%f, %f, %f", self.alpha, self.layer.presentationLayer.opacity, self.layer.modelLayer.opacity);      // ---> 1.000000, 1.000000, 1.000000</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐几个高频使用的 Xcode 小技巧</title>
      <link href="/2018/06/01/2018/6/tui-jian-ji-ge-gao-pin-shi-yong-de-xcode-xiao-ji-qiao/"/>
      <url>/2018/06/01/2018/6/tui-jian-ji-ge-gao-pin-shi-yong-de-xcode-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="推荐几个高频使用的-Xcode-小技巧"><a href="#推荐几个高频使用的-Xcode-小技巧" class="headerlink" title="推荐几个高频使用的 Xcode 小技巧"></a>推荐几个高频使用的 Xcode 小技巧</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>今天是节后上班第一天，也是 WWDC 期间知识小集微博话题暂停之后回归的第一天。欢迎关注本次 WWDC 期间 知识小集 和 老司机、SwiftGG 联合完成的掘金免费专题。</p><p>今天小集给大家推荐几个实用的 Xcode 小技巧。</p><ol><li>快速打开: <code>Command + Shift + O</code>。这个命令可以开启一个小窗格用来快速搜索浏览文件、类、算法以及函数等，且支持模糊搜索。这个命令可以说是我日常开发中最高频使用的一个了。</li><li>显示项目导航器: <code>Command + Shift + J</code>。使用快速打开命令跳转到对应文件后，如果需要在左侧显示出该文件在项目中的目录结构，只需要键入这个命令，非常方便。</li><li>显示编辑历史。如果发现一行需要膜拜或者需要吐槽的代码，不需要跑到专门的 diff 工具查看代码历史。在该代码行处右键，选择  <code>Show Blame for Line</code>，即可弹出一个小标签，显示该处代码的修改作者、commit 记录等信息。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>再谈 iOS 输入框的字数统计/最大长度限制</title>
      <link href="/2018/06/01/2018/6/zai-tan-ios-shu-ru-kuang-de-zi-shu-tong-ji-zui-da-chang-du-xian-zhi/"/>
      <url>/2018/06/01/2018/6/zai-tan-ios-shu-ru-kuang-de-zi-shu-tong-ji-zui-da-chang-du-xian-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="再谈-iOS-输入框的字数统计-最大长度限制"><a href="#再谈-iOS-输入框的字数统计-最大长度限制" class="headerlink" title="再谈 iOS 输入框的字数统计/最大长度限制"></a>再谈 iOS 输入框的字数统计/最大长度限制</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>前两周我们发了一个小集<a href="https://github.com/awesome-tips/iOS-Tips/blob/master/2018/05.md#ios-%E8%87%AA%E5%B8%A6%E4%B9%9D%E5%AE%AB%E6%A0%BC%E6%8B%BC%E9%9F%B3%E9%94%AE%E7%9B%98%E4%B8%8E-emoji-%E8%A1%A8%E6%83%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%9D%91" target="_blank" rel="noopener">「iOS 自带九宫格拼音键盘与 Emoji 表情之间的坑」</a>，介绍了如何解决由于输入框限制 Emoji 表情的输入导致中文拼音也无法输入的问题。</p><p>后面我们又有了新需求：<strong>对输入框已输入的文本字数进行实时统计，并在界面上显示剩余字数，且不能让所输入的文本超过最大限制长度</strong>。但这个简单的功能仍然有不少小坑。</p><p>在上一个小集中，我们讲到，对于 iOS 系统自带的键盘，有时候它在输入框中填入的是占位字符（已被高亮选中起来），等用户选中键盘上的候选词时，再替换为真正输入的字符，如下：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/06/1-1.jpg" alt></p><p>这会带来一个问题：比如输入框限定最多只能输入 10 位，当已经输入 9 个汉字的时候，使用系统拼音键盘则第 10 个字的拼音就打不了（因为剩余的 1 位无法输入完整的拼音）。</p><p>怎么办呢？上面提到，输入框中的拼音会被高亮选中起来，所以我们可以根据 <code>UITextField</code> 的 <code>markedTextRange</code> 属性判断是否存在高亮字符，如果有则不进行字数统计和字符串截断操作。我们通过监听 <code>UIControlEventEditingChanged</code> 事件来对输入框内容的变化进行相应处理，如下：</p><pre class=" language-objc"><code class="language-objc">[self.textField addTarget:self action:@selector(textFieldDidChange:) forControlEvents:UIControlEventEditingChanged];</code></pre><pre class=" language-objc"><code class="language-objc">- (void)textFieldDidChange:(UITextField *)textField {// 判断是否存在高亮字符，如果有，则不进行字数统计和字符串截断UITextRange *selectedRange = textField.markedTextRange;UITextPosition *position = [textField positionFromPosition:selectedRange.start offset:0];if (position) {return;}// maxWowdLimit 为 0，不限制字数if (self.maxWowdLimit == 0) {return;}// 判断是否超过最大字数限制，如果超过就截断if (textField.text.length > self.maxWowdLimit) {textField.text = [textField.text substringToIndex:self.maxWowdLimit];}// 剩余字数显示 UI 更新}</code></pre><p>对于 <code>UITextView</code> 的处理也是类似的。</p><p>另外，对于“字数”的定义是很多种理解：在 Objective-C 中字符串 <code>NSString</code> 的长度 <code>length</code>，对于一个中文汉字和一个英文字母都是 1；但如果我们要按<strong>字节</strong>来统计和限制，同一字符在不同编码下所占的字节数也是不同的；另外有时我们要统计的是所输入文本的单词个数，而不是字符串的长度，所以我们需要根据不同的使用场景进行分析。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 处理 navigationBar.titleTextAttributes 属性时机</title>
      <link href="/2018/06/01/2018/6/ios-chu-li-navigationbar.titletextattributes-shu-xing-shi-ji/"/>
      <url>/2018/06/01/2018/6/ios-chu-li-navigationbar.titletextattributes-shu-xing-shi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-处理-navigationBar-titleTextAttributes-属性时机"><a href="#iOS-处理-navigationBar-titleTextAttributes-属性时机" class="headerlink" title="iOS 处理 navigationBar.titleTextAttributes 属性时机"></a>iOS 处理 navigationBar.titleTextAttributes 属性时机</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/2629799120" target="_blank" rel="noopener">无彦主</a></p><p>笔者一般在 ViewController 的 viewWillAppear 中处理导航条的 UI 变化。比如是否隐藏导航栏、改变状态栏颜色等。但是最近发现在 viewWillAppear 中改变 navigationBar 的 <code>titleTextAttributes</code> 属性却在 pop 时出现了问题：「 从 SecondViewController 点击导航栏返回到 FirstViewController 时并没有生效，而使用滑动手势返回却可以生效。」</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">UIKit</span><span class="token keyword">class</span> <span class="token class-name">FirstViewController</span><span class="token punctuation">:</span> <span class="token builtin">UIViewController</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">viewWillAppear</span><span class="token punctuation">(</span><span class="token number">_</span> animated<span class="token punctuation">:</span> <span class="token builtin">Bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">viewWillAppear</span><span class="token punctuation">(</span>animated<span class="token punctuation">)</span>        navigationController<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">setNavgationBarTitleTextAttributes</span><span class="token punctuation">(</span>            color<span class="token punctuation">:</span> <span class="token punctuation">.</span>nav_purple<span class="token punctuation">,</span>            font<span class="token punctuation">:</span>  <span class="token punctuation">.</span>nav_regular        <span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在 iOS 系统 10 以后，UIKit 已经更新，统一后台管理 UINavigationBar，UITabBar 和 UIToolbar。特别是，对这些视图的背景属性（例如背景或阴影图像或设置条形样式）的更改可能会启动条形码的布局传递以解析新的背景外观。特别地，这意味着，试图改变的内部这些条的背景外观 </p><pre class=" language-objc"><code class="language-objc">layoutSubviews， -[UIView updateConstraints] ，viewWillLayoutSubviews，viewDidLayoutSubviews，updateViewConstraints</code></pre><p>或响应布局而调用的任何其他方法都可能导致布局循环。布局更改调用的 viewWillAppear 似乎触发了所提到的布局循环。</p><p><img src="http://" alt></p><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>比较简单的处理方法是在 SecondViewController 中重写 <code>willMove(:)</code> 方法，在这里将 titleAttribute 赋值回去，但这样的方式不够彻底，它显然不能处理两种或两种以上的状态变化。更为稳妥的的方法是重写自定义 UINavigationController 中的 <code>popViewController(:)</code> 方法。</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// NavBarTitleChangeable.swift</span><span class="token keyword">import</span> <span class="token builtin">UIKit</span><span class="token keyword">public</span> protocol <span class="token builtin">NavBarTitleChangeable</span><span class="token punctuation">:</span> <span class="token keyword">class</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> preferrdTextAttributes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">NSAttributedStringKey</span><span class="token punctuation">:</span> <span class="token builtin">AnyObject</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// Custom UINavigationController</span><span class="token keyword">import</span> <span class="token builtin">UIKit</span><span class="token keyword">class</span> <span class="token class-name">FunNavigationViewController</span><span class="token punctuation">:</span> <span class="token builtin">UINavigationController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> topViewControllerNavBarTitleAttributes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">NSAttributedStringKey</span><span class="token punctuation">:</span> <span class="token builtin">AnyObject</span><span class="token punctuation">]</span><span class="token operator">?</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>topViewController <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">NavBarTitleChangeable</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>preferrdTextAttributes    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">func</span> <span class="token function">setNavBarTitleAttributes</span><span class="token punctuation">(</span><span class="token number">_</span> attributes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">NSAttributedStringKey</span><span class="token punctuation">:</span> <span class="token builtin">AnyObject</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        navigationBar<span class="token punctuation">.</span>titleTextAttributes <span class="token operator">=</span> attributes    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> attributes <span class="token operator">=</span> topViewControllerNavBarTitleAttributes <span class="token punctuation">{</span>            <span class="token function">setNavBarTitleAttributes</span><span class="token punctuation">(</span>attributes<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">pushViewController</span><span class="token punctuation">(</span><span class="token number">_</span> viewController<span class="token punctuation">:</span> <span class="token builtin">UIViewController</span><span class="token punctuation">,</span> animated<span class="token punctuation">:</span> <span class="token builtin">Bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">pushViewController</span><span class="token punctuation">(</span>viewController<span class="token punctuation">,</span> animated<span class="token punctuation">:</span> animated<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> attributes <span class="token operator">=</span> topViewControllerNavBarTitleAttributes <span class="token punctuation">{</span>            <span class="token function">setNavBarTitleAttributes</span><span class="token punctuation">(</span>attributes<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">popViewController</span><span class="token punctuation">(</span>animated<span class="token punctuation">:</span> <span class="token builtin">Bool</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">UIViewController</span><span class="token operator">?</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> popViewController <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">popViewController</span><span class="token punctuation">(</span>animated<span class="token punctuation">:</span> animated<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> attributes <span class="token operator">=</span> topViewControllerNavBarTitleAttributes <span class="token punctuation">{</span>            <span class="token function">setNavBarTitleAttributes</span><span class="token punctuation">(</span>attributes<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        transitionCoordinator<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span>alongsideTransition<span class="token punctuation">:</span> <span class="token constant">nil</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token keyword">weak</span> <span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token number">_</span> <span class="token keyword">in</span>            <span class="token keyword">if</span> <span class="token keyword">let</span> attributes <span class="token operator">=</span> <span class="token keyword">self</span><span class="token operator">?</span><span class="token punctuation">.</span>topViewControllerNavBarTitleAttributes <span class="token punctuation">{</span>                <span class="token keyword">self</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">setNavBarTitleAttributes</span><span class="token punctuation">(</span>attributes<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> popViewController    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// MyViewController.swift</span><span class="token keyword">import</span> <span class="token builtin">UIKit</span><span class="token keyword">class</span> <span class="token class-name">FirstViewController</span><span class="token punctuation">:</span> <span class="token builtin">UIViewController</span><span class="token punctuation">,</span> <span class="token builtin">NavBarTitleChangeable</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> preferrdTextAttributes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">NSAttributedStringKey</span> <span class="token punctuation">:</span> <span class="token builtin">AnyObject</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> item <span class="token operator">=</span> <span class="token function">FunNavTitleTextAttributesItem</span><span class="token punctuation">(</span>color<span class="token punctuation">:</span> <span class="token punctuation">.</span>nav_purple<span class="token punctuation">,</span> font<span class="token punctuation">:</span>  <span class="token punctuation">.</span>nav_regular<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">getNavgationBarTitleTextAttributes</span><span class="token punctuation">(</span>with<span class="token punctuation">:</span> item<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>这里简单展示处理思路，具体代码还是要根据项目需求定制。</p><p><a href="https://github.com/wiiale/NavgationTitlePoppingDemo/tree/master" target="_blank" rel="noopener">Demo</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://developer.apple.com/library/content/releasenotes/General/RN-iOSSDK-10.0/index.html#//apple_ref/doc/uid/TP40017540-CH1-SW1" target="_blank" rel="noopener">iOS 10 SDK Release Notes</a>  </li><li><a href="https://stackoverflow.com/questions/39511088/navigationbar-coloring-in-viewwillappear-happens-too-late-in-ios-10" target="_blank" rel="noopener">stackoverflow</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode 设置代码只在 Debug 下起效的几种方式</title>
      <link href="/2018/06/01/2018/6/xcode-she-zhi-dai-ma-zhi-zai-debug-xia-qi-xiao-de-ji-chong-fang-shi/"/>
      <url>/2018/06/01/2018/6/xcode-she-zhi-dai-ma-zhi-zai-debug-xia-qi-xiao-de-ji-chong-fang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="Xcode-设置代码只在-Debug-下起效的几种方式"><a href="#Xcode-设置代码只在-Debug-下起效的几种方式" class="headerlink" title="Xcode 设置代码只在 Debug 下起效的几种方式"></a>Xcode 设置代码只在 Debug 下起效的几种方式</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>在日常开发中，我们通常会在 Debug 开发模式下写很多测试代码，或者引入一些测试专用的 <code>.a</code> 静态库或 <code>.framework</code> 动态库，也会通过 CocoaPods 引入一些第三方测试调试工具等；但我们往往不希望这些测试代码和测试用的库（Library/Framework）在 Release 正式包中被引用或导入，如何做到呢？</p><ul><li><code>.h/.m</code> 文件中的测试代码</li></ul><p>Xcode 在 Debug 模式下已经自动帮我们定义了宏 <code>DEBUG=1</code>，所以我们可以在代码文件中把相关测试代码写在编译预处理命令 <code>#ifdef DEBUG ... #endif</code> 中间即可，如下图所示，这也是我们最常见的一种用法。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/06/3-1.png" alt></p><ul><li>测试用的 <code>.a</code> 静态库或 <code>.framework</code> 动态库</li></ul><p>对于通过拖拽的方式直接在工程中添加一些用于测试 <code>.a</code> 或者 <code>.framework</code> ，我们可以在 Targets - Build Settings - Search Paths 中分别设置 <code>Library Search Paths</code> 和 <code>Framework Search Paths</code> 这两个选项，如下图所示（其中 libWeChatSDK.a 放在 WeChatSDK 目录中，而 TencentOpenAPI.framework 放在 QQSDK 目录中，假设它们只在测试时会用到），我们可以移除 Release 模式下测试用的 <code>.a</code> 或 <code>.framework</code> 所在的目录，只在 Debug 下保留，这样在打 Release 包时就不会包含这些库了。（当然在代码中使用到这些测试库的地方也要像上述一样写在 DEBUG 中间）</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/06/3-2.png" alt></p><ul><li>CocoaPods 引入的测试库</li></ul><p>对于通过 CocoaPods 方式引入的第三方测试库，就很方便了，我们可以配置 <code>configurations</code> 选项让它们只在 Debug 下生效，如下图：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/06/3-3.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>被大家忽略的UIViewController两对API</title>
      <link href="/2018/05/01/2018/5/bei-da-jia-hu-lue-de-uiviewcontroller-liang-dui-api/"/>
      <url>/2018/05/01/2018/5/bei-da-jia-hu-lue-de-uiviewcontroller-liang-dui-api/</url>
      
        <content type="html"><![CDATA[<h2 id="被大家忽略的UIViewController两对API"><a href="#被大家忽略的UIViewController两对API" class="headerlink" title="被大家忽略的UIViewController两对API"></a>被大家忽略的UIViewController两对API</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>在某个页面被pop或者dismissViewController的时候，需要执行某个操作，大家会怎么做呢？swizzle dealloc方法？这样做是没有问题的；其实UIViewController为我们提供了两对API。<br>针对add childViewController和remove childViewController:</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/13-1.jpg" alt></p><p>当然，Push和Pop也是适用的。</p><p>针对Present和Dismiss:</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/13-2.jpg" alt></p><p>那前面提到的问题就可以在viewWillDisappear:或者viewDidDisappear:里面去判断self.beingDismissed或者self.movingFromParentViewController。</p><p>虽然是iOS5之后就有了，但被很多开发童鞋忽略和遗忘了，有应用到的场景，大家可以用起来哈！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>替换系统音量提示</title>
      <link href="/2018/05/01/2018/5/ti-huan-xi-tong-yin-liang-ti-shi/"/>
      <url>/2018/05/01/2018/5/ti-huan-xi-tong-yin-liang-ti-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="替换系统音量提示"><a href="#替换系统音量提示" class="headerlink" title="替换系统音量提示"></a>替换系统音量提示</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>相信平时大家在用 iPhone 看视频调节音量时，总会被系统的音量提示所打扰，因为它会遮住一部分内容。所以很多视频应用都使用自定义音量视图的方式来替代系统的音频。比如下面三张截图，分别来自 Instagram、哔哩哔哩、即刻</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/2-1.png?raw=true" alt></p><p>其实要实现这个，主要是实现下面几个要点</p><ul><li>激活 AudioSession</li><li>创建一个 MPVolumeView，并将其添加到当前可见的视图层级当中，同时将其 frame 设置到不可见区域</li><li>监听音量按钮触发事件，改变音量提示（监听方式有两种：KVO、NSNotification）</li></ul><p>代码分别为</p><pre class=" language-objc"><code class="language-objc">// KVO- (void)dealloc {    [[AVAudioSession sharedInstance] removeObserver:self                                         forKeyPath:NSStringFromSelector(@selector(outputVolume))];}- (void)addObserver {    [[AVAudioSession sharedInstance] addObserver:self                                      forKeyPath:NSStringFromSelector(@selector(outputVolume))                                         options:NSKeyValueObservingOptionNew                                         context:nil];}- (void)observeValueForKeyPath:(NSString *)keyPath                      ofObject:(id)object                        change:(NSDictionary<NSKeyValueChangeKey,id> *)change                       context:(void *)context {    if ([change isKindOfClass:[NSDictionary class]]) {        NSNumber *volumeNum = change[@"new"];        if (volumeNum) {            [self volumeDidChange:[volumeNum floatValue]];        }    }}- (void)volumeDidChange:(CGFloat)volume {    // 显示自定义音量提示}</code></pre><pre class=" language-objc"><code class="language-objc">// Notificationstatic NSNotificationName const kSystemVolumeDidChangeNotification = @"AVSystemController_SystemVolumeDidChangeNotification";- (void)dealloc {    [[NSNotificationCenter defaultCenter] removeObserver:self];}- (void)addObserver {    [[NSNotificationCenter defaultCenter] addObserver:self                                             selector:@selector(volumeDidChange:)                                                 name:kSystemVolumeDidChangeNotification                                               object:nil];}- (void)volumeDidChange:(NSNotification *)notification {    NSString *category = notification.userInfo[@"AVSystemController_AudioCategoryNotificationParameter"];    NSString *changeReason = notification.userInfo[@"AVSystemController_AudioVolumeChangeReasonNotificationParameter"];    if (![category isEqualToString:@"Audio/Video"] || ![changeReason isEqualToString:@"ExplicitVolumeChange"]) {        return;    }    CGFloat volume = [[notification userInfo][@"AVSystemController_AudioVolumeNotificationParameter"] floatValue];    // 显示自定义音量提示}</code></pre><ul><li>KVO 在音量调节至最大/最小时，这个时候再调大/调小音量，由于 <code>outputVolume</code> 的值不变，所以不会触发 <code>KVO</code>，也就无法展示自定义音量视图，</li><li>监听系统私有(未公开的)通知，名字是 <code>AVSystemController_SystemVolumeDidChangeNotification</code>，这个监听不会受到最大/最小音量时，调大/调小音量的影响，只要音量键按下，始终都会触发。但是这个通知由于是私有的，可能存在被拒风险，而且将来系统版本该通知名字发生改变，由于是硬编码而不像其它系统通知使用的是常量，会导致监听不到的问题。</li></ul><p>参考链接：<a href="https://github.com/gizmosachin/VolumeBar" target="_blank" rel="noopener">VolumeBar</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对渐变视图的实现方案的探究</title>
      <link href="/2018/05/01/2018/5/dui-jian-bian-shi-tu-de-shi-xian-fang-an-de-tan-jiu/"/>
      <url>/2018/05/01/2018/5/dui-jian-bian-shi-tu-de-shi-xian-fang-an-de-tan-jiu/</url>
      
        <content type="html"><![CDATA[<h2 id="对渐变视图的实现方案的探究"><a href="#对渐变视图的实现方案的探究" class="headerlink" title="对渐变视图的实现方案的探究"></a>对渐变视图的实现方案的探究</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>如果想实现一个蓝色到绿色的渐变视图，大家会有怎样的方案呢？</p><ul><li>首先我想到的是CAGradientLayer来实现，效果如下图：</li></ul><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/9-1.jpg" alt></p><p>看着效果还可以，需要注意的是如果想均匀过度就不要去设置locations属性，要不然就是如下效果喽:</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/9-2.jpg" alt></p><p>这种实现方式比较简单，几行代码就可以搞定，但是放大图片会发现会有一些横杠杠，不明显，如果是视觉效果要求不严格，这种方式是完全没问题的。</p><ul><li>Core Image实现这种方案应该也不在话下，效果如下图：</li></ul><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/9-3.jpg" alt></p><p>色彩更亮丽一些，个人更喜欢这种效果，大家可以明显看出差异来。</p><ul><li>用Core Graphics来实现视图的绘制，尝试了使用CGShadingRef绘制，效果如图：</li></ul><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/9-4.jpg" alt></p><p>过度效果不够丝滑，又尝试使用了CGGradientRef去绘制，效果如下图：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/9-5.jpg" alt></p><p>效果好多了，这种效果和CAGradientLayer效果比较相近，但是使用CGGradientRef绘制视觉效果更好一些（专门请教了设计师，虽然我的肉眼凡胎并没有看出明显差异，但是放大后横条明显少一些）。</p><p>GPUImage应该也是可以实现的，大家可以尝试一下！</p><p>关于效率，我简单测试了一下(绘制200x200，蓝色到绿色渐变，绘制了10次的平均值)：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/9-6.jpg" alt></p><p>使用CGGradientRef绘制效率比其他方式要突出一些。</p><p>大家可以根据不同场景来使用不同的方式去绘制，如果有更好的方案，欢迎一起讨论！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何重写自定义对象的 hash 方法</title>
      <link href="/2018/05/01/2018/5/ru-he-chong-xie-zi-ding-yi-dui-xiang-de-hash-fang-fa/"/>
      <url>/2018/05/01/2018/5/ru-he-chong-xie-zi-ding-yi-dui-xiang-de-hash-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="如何重写自定义对象的-hash-方法"><a href="#如何重写自定义对象的-hash-方法" class="headerlink" title="如何重写自定义对象的 hash 方法"></a>如何重写自定义对象的 hash 方法</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>hash 是 NSObject 协议中定义的一个属性，也就是说，任何一个 NSObject 的子类都会有 hash 方法（对应属性的 getter，下文称哈希方法）。一般情况下，手动调用自定义对象的哈希方法，会返回当前对象的十进制内存地址，这是哈希方法的父类实现。</p><p>什么时候对象的哈希方法会被调用呢？那就是它被加入 NSSet 中，或者作为 NSDictionary 的 key 时。为什么这个时候调用呢？其实不难猜测，是为了利用哈希来加快这些无序集合的检索速度。</p><p>当我们需要重写某个类的 isEqual 方法时，配套地便要重写对象的哈希方法，因为被判等的两个对象需要有相同的哈希值，这里可以参考系统对 NSString 的实现，具有相同内容的两个 NSString 的实例 isEqual 方法会返回 true，它们的哈希值也会相同，而它们的内存地址当然是不相同的。此时，对于我们的自定义对象，若依然使用父类的哈希方法实现（返回对象内存地址）自然是不可取的。</p><p>那么，该如何正确地重写哈希方法呢？Mattt Thompson 给出了自己的建议：对关键属性的 hash 值进行位或运算作为自己的 hash 值。在我的偶像 @ibireme 的 YYModel 中，他对 yy_modelHash 方法的实现也是采用了这种方案。</p><p>参考资料：</p><ul><li><a href="https://www.jianshu.com/p/915356e280fc" target="_blank" rel="noopener">iOS开发 之 不要告诉我你真的懂isEqual与hash!</a></li><li><a href="https://www.mikeash.com/pyblog/friday-qa-2010-06-18-implementing-equality-and-hashing.html" target="_blank" rel="noopener">Implementing Equality and Hashing</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何正确使用初始化方法的标记宏</title>
      <link href="/2018/05/01/2018/5/ru-he-zheng-que-shi-yong-chu-shi-hua-fang-fa-de-biao-ji-hong/"/>
      <url>/2018/05/01/2018/5/ru-he-zheng-que-shi-yong-chu-shi-hua-fang-fa-de-biao-ji-hong/</url>
      
        <content type="html"><![CDATA[<h2 id="如何正确使用初始化方法的标记宏"><a href="#如何正确使用初始化方法的标记宏" class="headerlink" title="如何正确使用初始化方法的标记宏"></a>如何正确使用初始化方法的标记宏</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>在 Objective-C 中有 designated 和 secondary 初始化方法的观念。如果一个实例的初始化需要多个参数，那么使用所有参数进行初始化的方法可以作为 designated 初始化方法。而使用一个或多个参数的初始化方法则作为 secondary 初始化方法，并且在对应实现中调用前面的 designated 初始化方法。</p><p>在开发时，可以使用 NS_DESIGNATED_INITIALIZER 宏对 designated 初始化方法进行标记，用来向调用者明确，无论其他哪个初始化方法都会通过调用这个方法来实现。对于不想让调用者使用的初始化方法，可以使用 NS_UNAVAILABLE 宏来进行标记禁用。这样一来，Xcode 的自动补全不会索引到该方法，如果强制调用，编译器会报错（但是通过 runtime 还是可以调用的）。</p><p>需要注意的是，若为子类指定了一个 NS_DESIGNATED_INITIALIZER 宏标记的初始化方法，<strong>那么在子类中必须重写父类的 designated 初始化方法，该方法的实现是调用子类自身的 designated 初始化方法。在子类自身的  designated 初始化方法的实现中，又需要调用父类的 designated 初始化方法。</strong>这段话比较绕，下面提供一个例子说明。</p><pre class=" language-objective-c"><code class="language-objective-c">@interface AwesomeTips : NSObject//该方法被禁用- (instancetype)new NS_UNAVAILABLE;//secondary初始化方法- (instancetype)initWithName:(NSString *)aName;//designated初始化方法- (instancetype)initWithName:(NSString *)aName wish:(NSString *)ourWish NS_DESIGNATED_INITIALIZER;@end</code></pre><pre class=" language-objective-c"><code class="language-objective-c">#import "AwesomeTips.h"@interface AwesomeTips ()@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *wish;@end@implementation AwesomeTips//父类NSObject的designated方法为init，这里必须重写//否则警告“Method override for the designated initializer of the superclass '-init' not found”//在其重写实现中，调用子类指定的designated方法，并提供默认参数- (instancetype)init {    return [self initWithName:@"知识小集" wish:@"分享知识"];}//secondary初始化方法的实现，调用自身的designated方法- (instancetype)initWithName:(NSString *)aName {    return [self initWithName:aName wish:@"分享知识"];}//自身的designated初始化方法//需先调用父类的designated方法，而后使用参数赋值- (instancetype)initWithName:(NSString *)aName wish:(NSString *)ourWish {    if (self = [super init]) {        self.name = aName;        self.wish = ourWish;    }    return self;}@end</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何对NSMutableArray进行KVO</title>
      <link href="/2018/05/01/2018/5/ru-he-dui-nsmutablearray-jin-xing-kvo/"/>
      <url>/2018/05/01/2018/5/ru-he-dui-nsmutablearray-jin-xing-kvo/</url>
      
        <content type="html"><![CDATA[<h2 id="如何对NSMutableArray进行KVO"><a href="#如何对NSMutableArray进行KVO" class="headerlink" title="如何对NSMutableArray进行KVO"></a>如何对NSMutableArray进行KVO</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>我们知道，iOS 中 KVO (key-value-observing) 的原理，简单来说就是重写了被观察属性的 set 方法。自然，一般情况下只有通过调用 set 方法对值进行改变才会触发 KVO，直接访问实例变量修改值是不会触发 KVO 的。</p><p>对于 NSMutableArray 内容的变化进行观察，是我们比较常见的一个需求。但是在调用它的 addObject、removeObject 系列方法时，并不会触发它自己的 set 方法。所以，对一个可变数组进行观察，在它加减元素时不会收到期望的消息。</p><p>那么，该如何实现对 NSMutableArray 的 KVO 呢？官方为我们提供了这个方法<code>- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key</code></p><p>像之前一样，为可变数组添加 KVO。在加减元素时，使用这个方法来获取我们要进行操作的可变数组，便可以像普通的属性一样，收到它变化的消息。</p><p>举个例子，myItems 是我们要进行 KVO 的一个属性，它的定义如下：</p><p><code>@property (nonatomic, strong) NSMutableArray *myItems;</code></p><p>在它进行添加元素时，使用如下方法：</p><p><code>[[self mutableArrayValueForKey:@&quot;myItems&quot;] addObject:item];</code>这样，我们便实现了对 NSMutableArray 的 KVO。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何定制一个 UIView 类型控件的出入动画</title>
      <link href="/2018/05/01/2018/5/ru-he-ding-zhi-yi-ge-uiview-lei-xing-kong-jian-de-chu-ru-dong-hua/"/>
      <url>/2018/05/01/2018/5/ru-he-ding-zhi-yi-ge-uiview-lei-xing-kong-jian-de-chu-ru-dong-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="如何定制一个-UIView-类型控件的出入动画"><a href="#如何定制一个-UIView-类型控件的出入动画" class="headerlink" title="如何定制一个 UIView 类型控件的出入动画"></a>如何定制一个 UIView 类型控件的出入动画</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>在iOS开发中，自定义的弹层组件非常常见，比如分享框、自定义的  actionSheet 组件等。有的场景下，会选择使用 UIViewController 类型来实现，这时定制这个视图的出现、隐藏动画非常方便。然而，有时候需要选择轻量级的 UIView 类型来实现。这时该怎么定制它的出现、隐藏动画呢？这里提供一个思路：使用 UIView 的 <code>willMoveToSuperview:</code> 和 <code>didMoveToSuperview</code>这组方法，它们会在 <code>UIView</code> 作为subView 被添加到其他 UIView 中时调用。这里需要注意，自身调用 <code>removeFromSuperview</code> 方法时，同样会触发这组方法，只不过这时的参数会是一个 nil。</p><p>提供一个例子来说明：一个选择 UIView 类型实现的自定义 actionSheet 的出入动画，交互基本和微信一致。</p><pre class=" language-objective-c"><code class="language-objective-c">#pragma mark - show & dismiss- (void)didMoveToSuperview {if (self.superview) {[UIView animateWithDuration:0.35 delay:0 usingSpringWithDamping:0.9 initialSpringVelocity:10 options:UIViewAnimationOptionCurveEaseIn animations:^{_backgroundControl.alpha = 1;self.actionSheetTable.frame = CGRectMake(0, SCREEN_HEIGHT - _sheetHeight, SCREEN_WIDTH, _sheetHeight);} completion:^(BOOL finished) {[super didMoveToSuperview];}];}}- (void)hideSelf {[UIView animateWithDuration:0.35 delay:0 usingSpringWithDamping:0.9 initialSpringVelocity:10 options:UIViewAnimationOptionCurveEaseIn animations:^{_backgroundControl.alpha = 0;self.actionSheetTable.frame = CGRectMake(0, SCREEN_HEIGHT, SCREEN_WIDTH, _sheetHeight);} completion:^(BOOL finished) {[self removeFromSuperview];}];}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在 Cycript 和 LLDB 中使用私有的方法调试 iOS</title>
      <link href="/2018/05/01/2018/5/zai-cycript-he-lldb-zhong-shi-yong-si-you-de-fang-fa-diao-shi-ios/"/>
      <url>/2018/05/01/2018/5/zai-cycript-he-lldb-zhong-shi-yong-si-you-de-fang-fa-diao-shi-ios/</url>
      
        <content type="html"><![CDATA[<h2 id="在-Cycript-和-LLDB-中使用私有的方法调试-iOS"><a href="#在-Cycript-和-LLDB-中使用私有的方法调试-iOS" class="headerlink" title="在 Cycript 和 LLDB 中使用私有的方法调试 iOS"></a>在 Cycript 和 LLDB 中使用私有的方法调试 iOS</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>下面这些方法对于使用 <code>Cycript</code> 和 <code>LLDB</code> 调试第三方应用非常方便，比如想打印当前的视图层级结构，打印某个类的属性，方法，找到当前显示的 <code>ViewController</code> 等。当然，在非逆向的环境中，可以使用 <code>performSelector:</code> 执行，可以查看到同样的效果，下面的例子通过 <code>performSelector:</code> 方法获取。</p><ul><li><code>recursiveDescription</code>：打印某个视图的层级关系；</li></ul><pre><code>&lt;UIWindow: 0x7fdc86411aa0; frame = (0 0; 375 812); gestureRecognizers = &lt;NSArray: 0x600000248a60&gt;; layer = &lt;UIWindowLayer: 0x600000239e80&gt;&gt;</code></pre><ul><li><code>_printHierarchy</code>：直接获取当前显示的 <code>ViewController</code>，不必使用 <code>[view nextResponder]</code> 获取当前显示的 viewController；</li></ul><pre><code>&lt;ViewController 0x7fdc86411270&gt;, state: appeared, view: &lt;UIView 0x7fdc867085e0&gt;</code></pre><ul><li><code>_autolayoutTrace</code>：是 recursiveDescription 的精简版，忽略了关于 View 的描述信息；</li></ul><pre><code>UIWindow:0x7fdc86411aa0|   UIView:0x7fdc867085e0</code></pre><ul><li><code>_ivarDescription</code>：打印某个实例的所有变量名和值；</li></ul><pre><code>&lt;Lefex: 0x604000005a80&gt;:in Lefex:    _name (NSString*): @&quot;wsy&quot;in NSObject:    isa (Class): Lefex (isa, 0x10cde9038)</code></pre><ul><li><code>_methodDescription</code>：打印某个类的所有属性，实例方法，类方法。</li></ul><pre><code>&lt;Lefex: 0x604000005a80&gt;:in Lefex:    Class Methods:        + (id) trueName; (0x10cde6590)    Properties:        @property (copy, nonatomic) NSString* name;  (@synthesize name = _name;)    Instance Methods:        - (void) changeName; (0x10cde6580)        - (void) .cxx_destruct; (0x10cde6620)        - (id) name; (0x10cde65b0)        - (void) setName:(id)arg1; (0x10cde65e0)in NSObject:    Class Methods:    省略......</code></pre><p><a href="http://iosre.com/t/powerful-private-methods-for-debugging-in-cycript-lldb/3414" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>再谈 UITableView 的 estimatedRowHeight</title>
      <link href="/2018/05/01/2018/5/zai-tan-uitableview-de-estimatedrowheight/"/>
      <url>/2018/05/01/2018/5/zai-tan-uitableview-de-estimatedrowheight/</url>
      
        <content type="html"><![CDATA[<h2 id="再谈-UITableView-的-estimatedRowHeight"><a href="#再谈-UITableView-的-estimatedRowHeight" class="headerlink" title="再谈 UITableView 的 estimatedRowHeight"></a>再谈 UITableView 的 estimatedRowHeight</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>今天发现之前写的一个基于 <code>UITableView</code> 的列表页面存在如下问题：</p><blockquote><p>当列表在滑动过程中，特别是往下滑快接近底部时，右侧的滚动条一直在不断地抖动，并且滚动条的长度也在不断地微小变化；另外，当滑动到底部加载下一页数据并 <code>reloadData</code> 后，列表的内容会整体跳动往上偏移一段距离。这是什么原因呢？</p></blockquote><p>我们知道，在 iOS 11 发布后，<code>UITableView</code> 发生了一些变化，其中对现有项目的界面布局（列表/滚动）影响最大应该是以下两点：</p><ul><li><p>(1) <code>UIViewController</code> 中用于标记是否自动调整 <code>UIScrollView Insets</code> 的 <code>automaticallyAdjustsScrollViewInsets</code> 属性被宣布弃用，代替的是 <code>UIScrollView</code> 自己新增的 <code>contentInsetAdjustmentBehavior</code> 属性；</p></li><li><p>(2) <code>UITableView</code> 的预估 Cell 高度属性 <code>estimatedRowHeight</code> 的默认值被改为 <code>UITableViewAutomaticDimension</code>（即默认开启），而在 iOS 10 及以前，这个值默认为 0（即默认关闭行高估算）。</p></li></ul><p>对于 (1) 我们这里不再赘述；但是对于 (2) 来说既是福音也是噩耗，它确实解决了一些性能的问题，但也带来了一些令人头痛的问题。</p><p>由于 <code>UITableView</code> 继承于 <code>UIScrollView</code>，而一个 scrollView 能滚动的前提是需要设置它的 <code>contentSize</code>。当 tableView 被加载时，会调用 <code>heightForRowAtIndexPath</code> 方法计算每个 Cell 的高度，然后相加得到其 <code>contentSize</code>，这显然是耗时又耗性能的，尤其是对于那种高度可变化的 Cells 更是如此。</p><p>所以为了优化这个问题，提高 <code>UITableView</code> 的加载速度（初始化和 <code>reloadData</code> 时），苹果引入了 <code>estimatedRowHeight</code>，文档描述如下：</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/7-1.png" alt></p><p>当开启 <code>estimatedRowHeight</code> 时，一个 tableView 被加载后，它的 <code>contentSize</code> 的高度通过 <code>estimatedRowHeight</code>(默认为44) * Cells 的数量即可得，不需要遍历 <code>heightForRowAtIndexPath</code> 获取并相加来计算了，缩短其加载耗时。</p><p>但是每个 Cell 的真实高度以及 tableView 的真实 <code>contentSize</code> 是什么时候计算的呢？正如上述文档所说，<strong>推迟到滑动的时候</strong>，当每个 Cell 将要被显示出来时再计算获取，并实时更新 tableView 的 <code>contentSize</code>。</p><p>这也解释了我们开头所遇到问题：当 tableView 加载时启用了预估行高，在往下滑动时，下面的 Cells 被不断地被显示出来并更新了 tableView 的 <code>contentSize</code>，同时导致右侧的滚动条的高度和位置也要相应更新，产生“抖动”现象。此外，当加载下一页数据并重新 <code>reloadData</code> 发生跳动偏移的原因也是类似的。</p><p>在 iOS 11 中，<code>estimatedRowHeight</code> 默认是开启的，我们可以通过设置 <code>tableView.estimatedRowHeight = 0</code> 来禁用。</p><p>你在使用 <code>UITableView</code> 时遇到过类似的问题吗？你是如何解决的，欢迎留言讨论~ </p><p>参考链接：</p><ul><li><a href="https://www.jianshu.com/p/3d9c0daddcdb" target="_blank" rel="noopener">关于 iOS 11 中 estimatedRowHeight</a></li><li><a href="https://developer.apple.com/documentation/uikit/uitableview/1614925-estimatedrowheight?language=objc" target="_blank" rel="noopener">Apple Docs: estimatedRowHeight</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>你的遍历方法用对@autoreleasepool了么</title>
      <link href="/2018/05/01/2018/5/ni-de-bian-li-fang-fa-yong-dui-autoreleasepool-liao-me/"/>
      <url>/2018/05/01/2018/5/ni-de-bian-li-fang-fa-yong-dui-autoreleasepool-liao-me/</url>
      
        <content type="html"><![CDATA[<h2 id="你的遍历方法用对-autoreleasepool了么"><a href="#你的遍历方法用对-autoreleasepool了么" class="headerlink" title="你的遍历方法用对@autoreleasepool了么"></a>你的遍历方法用对@autoreleasepool了么</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>在每次遍历的时候生成了很多占内存大的对象，如果交于默认的autoreleasepool去管理生命周期，会有因为内存飙升产生crash的风险，这个时候我们就需要手动控制这些对象的生命周期。也就是需要在适当的位置上去使用@autoreleasepool()。</p><p>系统为我们提供了很多的遍历方法，比如说<strong>for循环</strong>、<strong>for-in</strong>、<strong>enumerateObjectsWithOptions:</strong>、<strong>dispatch_apply</strong>等方法，那有的同学就说都加上吧，就出现了下面这段代码：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/3-1.jpg" alt></p><p>虽然说这样写也没什么异常，但是这里真的有必要加么？其实快速遍历这几个方法系统自动为我们添加了autoreleasepool方法，从文档里可以看到蛛丝马迹：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/3-2.jpg" alt></p><p>不过，其他方法都需要加上@autoreleasepool()哈！</p><h2 id="使用-YYFPSLabel-快速检测页面滑动的流畅度"><a href="#使用-YYFPSLabel-快速检测页面滑动的流畅度" class="headerlink" title="使用 YYFPSLabel 快速检测页面滑动的流畅度"></a>使用 YYFPSLabel 快速检测页面滑动的流畅度</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p><code>FPS</code> (Frames Per Second) 是图像领域中的定义，表示每秒渲染帧数，通常用于衡量画面的流畅度，每秒帧数越多，则表示画面越流畅，<code>60fps</code> 最佳。</p><p>在 <code>iOS</code> 开发中，在复杂布局的列表页面，我们通常需要对列表的滑动进行性能优化，以保持页面流畅。对于保持流畅的优化技巧，可以参见 <code>@ibireme</code> 的这篇文章 <strong>《iOS 保持界面流畅的技巧》</strong> <a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/，我们不再赘述。" target="_blank" rel="noopener">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/，我们不再赘述。</a></p><p>这里主要介绍一下如何快速检测页面滑动的流畅度，即如何检测屏幕的 <code>FPS</code> ?</p><p><code>Xcode</code> 的 <code>Instrument</code> 提供了相关的工具，详见 <code>Core Animation/GPU Driver/Time Profile</code> 等模块，但是使用起来还是比较繁琐，不直观。</p><p>在 <strong>YYText</strong> <code>https://github.com/ibireme/YYText) 的 [Demo](https://github.com/ibireme/YYText/tree/master/Demo/YYTextDemo</code> 中提供了一个 <code>YYFPSLabel</code>，它使用系统提供的 <code>CADisplayLink</code> 的 <code>timestamp</code> 属性，配合 <code>timer</code> 的执行次数计算得出 <code>FPS</code>，实现原理详见 <code>YYFPSLabel</code> 源码和这篇文章的介绍：<code>https://www.jianshu.com/p/878bfd38666d</code></p><p>因此，我们可以在工程的 <code>DEBUG</code> 模式下，给 <code>KeyWindow</code> 添加一个 <code>YYFPSLabel</code>，如下：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/4-1.png" alt></p><p>就可以在屏幕上实时看到 <code>FPS</code> 值了：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/4-2.jpg" alt></p><p>另外，<code>FPS</code> 的值跟机器的处理器性能息息相关，不同的设备的表现往往都不同，因此我们只要能保证 <code>App</code> 在低端设备上运行的 <code>FPS</code> 为 <code>50+</code>，基本就可以认为是流畅的了。</p><p>Demo 地址：<code>https://github.com/kangzubin/XMNetworking/tree/master/Demo</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一个结构较为合理的下载模块该怎么设计</title>
      <link href="/2018/05/01/2018/5/yi-ge-jie-gou-jiao-wei-he-li-de-xia-zai-mo-kuai-gai-zen-me-she-ji/"/>
      <url>/2018/05/01/2018/5/yi-ge-jie-gou-jiao-wei-he-li-de-xia-zai-mo-kuai-gai-zen-me-she-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一个结构较为合理的下载模块该怎么设计"><a href="#一个结构较为合理的下载模块该怎么设计" class="headerlink" title="一个结构较为合理的下载模块该怎么设计"></a>一个结构较为合理的下载模块该怎么设计</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>最近负责下载组件的开发，对于如何设计一个下载模块有一些粗浅体会，今天分享一下我采用的方案，希望能够抛砖引玉。另外，最近会出两篇主题为“下载组件的设计”和“与 Hybrid 相关的下载方案”的长文，欢迎关注#知识小集#。</p><p>“下载”作为一个需要本地结构化、持久化存储的场景，使用数据库是比较自然的选择。所以，我们首先拆分出一个数据库模块，用来存储下载记录。主要字段为下载任务的信息，如 url、文件大小、时间戳等，以及最重要的文件本地存储路径。这一层可以在接口设计上认真思虑，比如仅涉及当前业务逻辑，而不涉及具体的数据库操作，相当于是较FMDB等数据库组件来说更高层的抽象。后期需要更换底层数据库引擎时，本层封装无需改动，是比较理想的实现。</p><p>数据库是用来存储下载记录的，那么所下载的具体文件呢？自然就需要一个文件管理模块，在这个模块里，负责根据文件 url 生成本地的存储路径，以及进行文件校验、存储、移除等操作。</p><p>所要下载的文件，我们可以按体积、类型等进行区分。对于网络请求的结果这类简短内容，我抽象出了一个缓存管理器，用来完成网络请求、图片等内容的缓存。网络请求的结果，可以选择 YYCache、EGOCache等缓存框架。而图片的缓存，则可以选择专注图片缓存的YYWebImage、SDWebImage等框架。</p><p>对于体积较大的文件，自然需要一个专注大文件下载的模块。这个模块不关注具体的文件类型，不关注具体的业务场景，它只需要文件url、文件管理模块生成的本地目标路径，完成下载任务即可。</p><p>在以上通用模块的基础上，有一个业务层的封装，它负责根据提交的下载任务，协调调用各基础组件。举个例子，一个下载任务包括一个视频文件、一个网络请求结果、三张图片。本模块在收到任务后，首先解析出以上的任务具体结构。使用文件管理模块，根据视频文件 url 生成本地存储目标路径，调用大文件下载器完成下载，此为一个子任务。对于网络请求结果，调用缓存模块，进行缓存，此为一个子任务。对于三张图片，使用图片缓存器完成缓存，此为一个子任务。三个子任务均完成，使用数据库模块，对下载记录、媒体文件记录等进行存储。除此之外，本模块还负责对外提供下载中任务、已下载任务等数据。</p><p>因篇幅有限，具体的细节请关注后续长文。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 自带九宫格拼音键盘与 Emoji 表情之间的坑</title>
      <link href="/2018/05/01/2018/5/ios-zi-dai-jiu-gong-ge-pin-yin-jian-pan-yu-emoji-biao-qing-zhi-jian-de-keng/"/>
      <url>/2018/05/01/2018/5/ios-zi-dai-jiu-gong-ge-pin-yin-jian-pan-yu-emoji-biao-qing-zhi-jian-de-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-自带九宫格拼音键盘与-Emoji-表情之间的坑"><a href="#iOS-自带九宫格拼音键盘与-Emoji-表情之间的坑" class="headerlink" title="iOS 自带九宫格拼音键盘与 Emoji 表情之间的坑"></a>iOS 自带九宫格拼音键盘与 Emoji 表情之间的坑</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>最近产品提了一个需求：要求某个“输入框”禁止输入 Emoji 表情，我们能想到的方案是：在 <code>UITextField</code> 的 <code>textField:shouldChangeCharactersInRange:replacementString:</code> 代理方法中判断即将输入的字符串是否包含 Emoji 表情，如果包含，就在该方法中返回 <code>NO</code>，不允许输入。</p><p>关于如何判断一字符串是否包含 Emoji 表情的方法，网上已经有很多代码片段，一般是通过 <code>Unicode</code> 编码范围来判断 ，详见这里：<a href="https://gist.github.com/cihancimen/4146056" target="_blank" rel="noopener">https://gist.github.com/cihancimen/4146056</a> ，方法名记为：</p><pre><code>- (BOOL)stringContainsEmoji:(NSString *)string;</code></pre><p>按照上述思路开发完后，Emoji 表情确实是被限制住无法输入了，但是当把键盘切换为 iOS 系统自带的九宫格拼音键盘准备输入汉字时，却发现拼音无法输入。这是怎么回事？</p><p>首先通过观察系统自带拼音键盘的行为，可以发现，当通过拼音来输入汉字时，系统会先在输入框中“预输入”拼音字母作为占位，等用户在键盘上选中汉字时，输入框中的占位“拼音字母”就会被替换为所对应的汉字，如下图：</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/10-1.jpg" alt></p><p>通过断点调试我们还发现，在输入拼音过程中，以“知识小集”（zhishixiaoji）为例，当我们通过点击第 9 个键来输入字母 <code>z</code> 时，在 UITextField 的代理方法中获取到的即将输入的字符不是 <code>z</code> ，而是一个符号 ➒ ，而输入结束后（<code>textFieldDidChange:</code>）该符号 ➒ 就会被替换为所对应的字母，然后当点击第 4 个键来输入字母 <code>h</code> 时，同样地得到即将输入的字符为 ➍ ，然后再被替换为 <code>h</code>，以此类推…</p><p>我们猜测，苹果之所以这么做是因为，对于九宫格拼音键盘，一个键代表着 3 或 4 个字母，当你点击一个键时，它并不知道你要输入那个字母，所以用一个带圆圈的数字符号作为临时占位，等输入结束时才替换为相应的字母。</p><p>在九宫格拼音键盘中，”ABC” 键 ~ “WXYZ” 键所对应的临时占位符号分别为 ➋➌ … ➒ ，表情 “^-^” 键所对应的为符号 ☻ ，而这些符号在 <code>stringContainsEmoji:</code> 方法中刚好都被判为是 Emoji，所以当输入框禁止输入 Emoji 表情时，就会导致拼音也无法输入。</p><p>解决方案就是在 Emoji 判定方法中，过滤掉上述符号（对应的 <code>Unicode</code> 编码为 <code>U+278b</code> ~ <code>U+2792</code> 和 <code>U+263b</code>），如下：</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/10-2.png" alt></p><p>但我们发现系统自带的“全键盘拼音输入”不会有上述问题，因为每个键都只代表一个字母：</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/10-3.jpg" alt></p><p>而且，国内常用的第三方输入法也不会有这个问题，因为它们不会在输入框中“预输入”拼音字符（而是把拼音显示在键盘上方），只有等用户选中汉字时，才把汉字填写到输入框中，如下（搜狗输入法）：</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/10-4.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 如何调试 WebView</title>
      <link href="/2018/05/01/2018/5/ios-ru-he-diao-shi-webview/"/>
      <url>/2018/05/01/2018/5/ios-ru-he-diao-shi-webview/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-如何调试-WebView"><a href="#iOS-如何调试-WebView" class="headerlink" title="iOS 如何调试 WebView"></a>iOS 如何调试 WebView</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>目前 iOS 端几乎都会接入 Web 页面，与前端接触也越来越多，如果不了解点前端知识，当出现问题的时候双方沟通起来非常不顺畅，便开始接触前端。我们今天聊聊如何调试 Web 页。当运行 APP 的时候，iOS 端加载 WebView（WKWebView 或 UIWebView ）时可以通过 Mac 自带的 Safari 来调试所显示的页面，其实调试 JSPatch 的时候也是这么用的。</p><p>我们来模拟加载 Web 页时的场景，首先需要开启本地的 WebServer，mac 自带 Apache 服务器，我们只需启动这个服务器，即可加载一个网页。</p><pre><code>// 开启 Apachesudo apachectl start</code></pre><p>Apache 开启后，站点的目录在 <code>/Library/WebServer/Documents</code> 下，我们把写好的网页放到这个目录下，然后直接可以根据 URL 访问对应的页面，比如在浏览器中输入：<code>http://电脑ip地址/web/index.html</code> 即可访问 <code>index.html</code> 这个页面。</p><p>使用 WKWebView 加载 <code>index.html</code> 这个页面，即可调试这个页面，调试前需要做以下两件事：</p><ul><li>手机端开启Web 检查器：设置 -&gt; 通用 -&gt; Safari -&gt; 高级 -&gt; Web 检查器</li><li>Mac端显示开发菜单：Safari 浏览器默认没有显示“开发”菜单，需要通过：Safari 浏览器  -&gt; 偏好设置 -&gt; 高级 -&gt; 勾选在菜单中显示“开发”设置。</li></ul><p>设置完后，当启动 APP ，加载 WKWebView 后即可看到 <code>index.html</code> 这个页面。这时即可通过断点进行调试，当然可以查看当前的 HTML 代码，JS 代码，网络情况等。具体如下图所示：</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/12-1.jpg" alt></p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/12-2.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 如何调试 WebView （二）</title>
      <link href="/2018/05/01/2018/5/ios-ru-he-diao-shi-webview-er/"/>
      <url>/2018/05/01/2018/5/ios-ru-he-diao-shi-webview-er/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-如何调试-WebView-（二）"><a href="#iOS-如何调试-WebView-（二）" class="headerlink" title="iOS 如何调试 WebView （二）"></a>iOS 如何调试 WebView （二）</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>上次的小集中，我主要讨论了如何调试 WebView ，小集发出后  @折腾范儿_味精 提供了另一种方法来调试 WebView。我觉得有必要再扩展一下，原话是这样的：</p><blockquote><p>真说方便还是植入一个 webview console 在 debug 环境，可以在黑盒下不连电脑不连 safari 调 dom，调js，另外在开发期间 Xcode 断点 run 的时候，js hook console.log console.alert，接管window.onerror 全都改 bridge NSLog 输出，也会方便点。</p></blockquote><p>短短几句话，信息量很大，私下向味精学习了下，这里总结一下。写完这个小集特意让味精看了下，觉得有必要再补充下第二种调试技巧，但中途踩了几个坑，一直到23:30左右才搞定。</p><p>第一，把 WebView 用来调试的 log、alert、error 显示到 NA ，在调试时会方便不少。做 WebView 与端交互的时候，主要用 <code>window.webkit.messageHandlers.xxx.postMessage(params);</code> 来给端发消息，也就是说 WebView 想给端发消息的时候直接调用这个方法即可，端会通过 <code>WKScriptMessageHandler</code> 的代理方法来接收消息，而此时端根据和 WebView 约定的规则进行通信即可。</p><pre><code>- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message</code></pre><p>而添加调试信息，无非就是给 WebView 添加了 log、alert、error 这些消息的 bridge，这样当 WebView 给端发送消息后，端根据和 WebView 约定的规则解析 log、alert、error 为端对应的事件，比如 log 直接调用端的 <code>NSLog</code>，alert 调用端的 <code>UIAlertController</code>。</p><p>第二，黑盒下调试 WebView，无需连接电脑和 safari 即可调试 DOM，这个可以参考小程序的 <a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">vConsole</a> 或者 <a href="https://github.com/liriliri/eruda" target="_blank" rel="noopener">eruda</a> 。可以直接在 WebView 中接入，或者在端中接入。这里以在端中接入 eruda 为例，这里踩到几个坑：</p><p>1.有些页面显示不出来，估计是故意屏蔽掉的，味精特意使用 JSBox 试了下其它页面，发现百度等都不可以显示调试按钮，而掘金是可以的；</p><p>2.使用本地的页面也显示不出来，这是 webview 跨域安全方面的考虑，file 协议下会禁止 js css html 以部分 file，部分网络的方式加载。</p><p>下面这段代码直接在 webview 加载完成后执行即可。</p><pre><code>NSString *js = @&quot;(function() {var script = document.createElement(&#39;script&#39;);script.type = &#39;text/javascript&#39;;script.src = &#39;https://xteko.blob.core.windows.net/neo/eruda-loader.js&#39;;document.body.appendChild(script);})();&quot;;[self.webView evaluateJavaScript:js completionHandler: nil];</code></pre><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/14-1.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UIView 的事件透传</title>
      <link href="/2018/05/01/2018/5/uiview-de-shi-jian-tou-chuan/"/>
      <url>/2018/05/01/2018/5/uiview-de-shi-jian-tou-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="UIView-的事件透传"><a href="#UIView-的事件透传" class="headerlink" title="UIView 的事件透传"></a>UIView 的事件透传</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>通常我们会遇到这种需求，一个视图除了需要响应子视图的点击事件，其它空白地方希望能将点击事件透传到，比如自定义了一个“导航栏”，除了左右两边按钮，希望其它部分点击能够透传到底下的视图。这个时候我们可以通过复写 hitTest 方法，具体实现如下。</p><pre class=" language-objc"><code class="language-objc">@implementation PassthroughView- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {if (self.hidden || self.alpha < FLT_EPSILON || self.userInteractionEnabled) {return [super hitTest:point withEvent:event];}UIView *targetView = nil;for (UIView *subview in [[self subviews] reverseObjectEnumerator]) {if ((targetView = [subview hitTest:[subview convertPoint:point fromView:self] withEvent:event])) {break;}}return targetView;}@end</code></pre><p>以上代码即可实现，只响应子视图的事件，而非子视图区域部分的交互事件则透传到响应链中的下一个响应者。<br>如果你有其它更好方式，也可以分享出来，一起交流下</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UIScrollView 拖拽滑动时收起键盘</title>
      <link href="/2018/05/01/2018/5/uiscrollview-tuo-zhuai-hua-dong-shi-shou-qi-jian-pan/"/>
      <url>/2018/05/01/2018/5/uiscrollview-tuo-zhuai-hua-dong-shi-shou-qi-jian-pan/</url>
      
        <content type="html"><![CDATA[<h2 id="UIScrollView-拖拽滑动时收起键盘"><a href="#UIScrollView-拖拽滑动时收起键盘" class="headerlink" title="UIScrollView 拖拽滑动时收起键盘"></a>UIScrollView 拖拽滑动时收起键盘</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>当一个页面的 UIScrollView/UITableView 上有一个或多个输入框时，我们经常需要做一件事就是当列表拖拽/滑动时，就收起已经弹起的键盘。</p><p>我们工程中之前一直是这么处理的：在 UIScrollView 的 <code>scrollViewWillBeginDragging</code> 代理方法（此方法在用户将要开始拖动 scrollView 时调用）中，调用 keyWindow 的 <code>endEditing:</code> 方法关闭键盘，代码如下：</p><pre><code>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView {    // 开始拖拽滑动时，收起键盘    [[[UIApplication sharedApplication] keyWindow] endEditing:YES];}</code></pre><p>今天发现，原来在 iOS 7 以后，UIScrollView 增加了一个 <strong>keyboardDismissMode</strong> 属性来完成这件事，你只需要写一行代码就可实现上述功能：</p><pre><code>self.tableView.keyboardDismissMode = UIScrollViewKeyboardDismissModeOnDrag;</code></pre><p>其中，UIScrollViewKeyboardDismissMode 有三个枚举值分别如下：</p><ul><li><p>UIScrollViewKeyboardDismissModeNone: 默认值，scrollView 的拖拽滑动对键盘状态不会有影响</p></li><li><p>UIScrollViewKeyboardDismissModeOnDrag: 当刚拖拽 scrollView 时就会收起关闭键盘</p></li><li><p>UIScrollViewKeyboardDismissModeInteractive: 当拖拽 scrollView 向下滑动时，键盘会跟随手势滑动，当又往上滑动时，键盘也会跟着向上并取消关闭。</p></li></ul><p>又涨知识了…👻</p><p>参考链接：<a href="https://developer.apple.com/documentation/uikit/uiscrollview/1619437-keyboarddismissmode?language=objc" target="_blank" rel="noopener">keyboardDismissMode</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TestFlight删除测试人员血泪史</title>
      <link href="/2018/05/01/2018/5/testflight-shan-chu-ce-shi-ren-yuan-xie-lei-shi/"/>
      <url>/2018/05/01/2018/5/testflight-shan-chu-ce-shi-ren-yuan-xie-lei-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="TestFlight删除测试人员血泪史"><a href="#TestFlight删除测试人员血泪史" class="headerlink" title="TestFlight删除测试人员血泪史"></a>TestFlight删除测试人员血泪史</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>TestFlight是苹果推荐的灰测方案，相比蒲公英，fir来说优点有和正式包是同一个包，大大降低了因为打不同包代码不一致的风险；可以覆盖安装线上包；不受证书过期的影响等。</p><p>如下图，分割线以下的分组是可以自定义的，方便给特定的用户群发灰测，后续不用可以整组删除；而分割线以上的分组是固定的，只可以批量添加用户，却不能整组删除。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/6-1.jpg" alt></p><p>然而被拒的是如果不小心批量添加了几个测试人员在分割线以上的分组里，该如何删除呢？😂😂😂信息是分页加载的，每页加载几十条。现在需要把页面全部加载出来，并且全部勾选删除。中间尝试了写脚本删除，发现并没有什么用（思路有点问题），但可以用选中第一条，然后按住Shift键，再选中最后一个解决，那么就剩下了如何把测试人员全都加载出来，😂😂😂发现选中测试人员区域，按住键盘上的向下按钮可以一直向下滑动并加载，并利用了这个很Low的方式，中午吃饭的时候把一个物体固定在键盘上按住这个按键，吃饭回来后就发现9000多条数据已经全部加载完成，然后用Shift键全选后删除了😂😂😂。</p><p>和大家交流后，又有了新的思路，又请教了前端大神，发现写脚本是可以的，大概有以下2类思路（第一种想法已验证成功）：1，把所有数据拉下来，然后再调用删除接口；2，在checbox勾选的时候，是把当前测试人员加入了一个数组中，可以利用这个来实现批量删除操作。</p><p>如果有更好的方法，欢迎分享！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RACObserve 常见用法及区别</title>
      <link href="/2018/05/01/2018/5/racobserve-chang-jian-yong-fa-ji-qu-bie/"/>
      <url>/2018/05/01/2018/5/racobserve-chang-jian-yong-fa-ji-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="RACObserve-常见用法及区别"><a href="#RACObserve-常见用法及区别" class="headerlink" title="RACObserve 常见用法及区别"></a>RACObserve 常见用法及区别</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>用过 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/tree/v2.5" target="_blank" rel="noopener"><code>ReactiveCocoa</code></a> 的应该都比较熟悉这个 <code>RACObserve</code> 这个宏，但是不知道大家有没有对这个宏具体展开，进行分析。</p><p>比较常见的用法就是 <code>RACObserve(someTarget, someProperty)</code>，但是大家了解 <code>RACObserve(target.someTarget, someProperty)</code> 和 <code>RACObserve(target, someTarget.someProperty)</code> 之间的区别么？具体可以看以下代码片段以及执行的结果</p><pre class=" language-objc"><code class="language-objc">self.label = [UILabel new];self.label.text = @"123";[RACObserve(self.label, text) subscribeNext:^(id x) {    NSLog(@"RACObserve(self.label, text) 的方式 %@", x);}];[RACObserve(self, label.text) subscribeNext:^(id x) {    NSLog(@"RACObserve(self, label.text) 的方式 %@", x);}];self.label.text = @"1234";self.label = [UILabel new];self.label.text = @"12345";// outputRACObserve(self.label, text) 的方式 123RACObserve(self, label.text) 的方式 123RACObserve(self, label.text) 的方式 1234RACObserve(self.label, text) 的方式 1234RACObserve(self, label.text) 的方式 (null)RACObserve(self, label.text) 的方式 12345</code></pre><p>以上面代码为例，<code>RACObserve(self.label, text)</code> 其实是监听 <code>self.label</code> 这个对象的 <code>text</code> 属性，所以当这个对象 <code>text</code> 发生变化时，第一个是 <code>block</code> 是能够收到回调的，但是当 <code>self.label</code> 被重新赋值后，原来的 <code>label</code> 无人持有相当于变成了 <code>nil</code>，所以第一个 <code>block</code> 将不再生效。而 <code>RACObserve(self, label.text)</code> 监听的是 self，然后 <code>keyPath</code> 是 <code>label.text</code>，所以当 <code>label</code> 或者其 <code>text</code> 发生变化都会触发这个回调。所以区别在于 <code>target</code> 以及 <code>keyPath</code> 的设置。</p><p>如果上述表达有不恰当的地方，欢迎指出，一起探讨~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Quick Look Debugging</title>
      <link href="/2018/05/01/2018/5/quick-look-debugging/"/>
      <url>/2018/05/01/2018/5/quick-look-debugging/</url>
      
        <content type="html"><![CDATA[<h2 id="Quick-Look-Debugging"><a href="#Quick-Look-Debugging" class="headerlink" title="Quick Look Debugging"></a>Quick Look Debugging</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/5-1.png" alt></p><p>上面这张图在开发中你应该经常看到，今天主要介绍快速调试的一个小技巧。有时候想知道某个 image 对象的具体对应的图片长什么样；某条贝塞尔曲线的形状；某个 View 长什么样，它上面有哪些子视图；某个 NSURL 对象是否可以访问等；想快速跳转到沙盒中的某个目录文件下。今天这个小技巧可以帮你解决这些问题。</p><p>从第一张图直接点击小眼睛即可预览图片，查看视图，跳转到网页，进入沙盒目录等。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/5-2.png" alt></p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/5-3.png" alt></p><p>系统默认支持下面这几种类型：</p><ul><li>图片： UIImage，UIImageView，和 NSBitmapImageRep 都可以快速查看。</li><li>颜色： UIColor</li><li>字符串： NSString 和 NSAttributedString。</li><li>几何： UIBezierPath 和 NSBezierPath，以及 CGPoint，CGRect，和 CGSize。</li><li>地区 CLLocation 将显示一个很大的，互动的映射位置，并显示高度和精度的细节。</li><li>URLs： NSURL 将显示 URL 所指的本地或远程的内容。</li><li>数据： NSData 将漂亮的显示出偏移的十六进制和 ASCII 值。</li><li>视图： 最后但并非最不重要的，任何 UIView 子类都将在快速查看弹出框中显示其内容，方便极了。</li></ul><p>如果想让自定义的类也支持这种快速调试可以重写方法</p><pre><code>- (id)debugQuickLookObject{    // 返回系统支持的类型    return self.avatarImage;}</code></pre><p><a href="http://nshipster.cn/quick-look-debugging/" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NSFetchedResultsController 的另一个坑</title>
      <link href="/2018/05/01/2018/5/nsfetchedresultscontroller-de-ling-yi-ge-keng/"/>
      <url>/2018/05/01/2018/5/nsfetchedresultscontroller-de-ling-yi-ge-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="NSFetchedResultsController-的另一个坑"><a href="#NSFetchedResultsController-的另一个坑" class="headerlink" title="NSFetchedResultsController 的另一个坑"></a>NSFetchedResultsController 的另一个坑</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>之前有分享过 <code>NSFetchedResultsController</code> 初始化时设置了 <code>cacheName</code> 会导致 iOS10+ 内存泄露的坑，具体可以参考之前这条<a href="https://github.com/awesome-tips/iOS-Tips/blob/master/2017/11.md#nsfetchedresultscontroller%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">微博</a>。</p><p>今天分享另一个坑。用过 <code>CoreData</code> 的大家应该比较了解 <code>NSFetchedResultsController</code>，这个类设计个人认为是为了和列表视图 <code>UITableView/UICollectionView</code> 做绑定，由于它内部有自带 <code>diff</code> 算法，结合两个列表类的局部刷新系列方法，可以表现出较好的性能（相对于 <code>reloadData</code> 而言），它的 API 回调其实在列表视图中都能找到对应的刷新方式，如图<br><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/8-1.jpg?raw=true" alt><br><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/8-2.jpg?raw=true" alt></p><p>但是有一个坑点是 <code>controller:didChangeObject: atIndexPath:forChangeType:newIndexPath:</code> 这个方法的回调时机有时候是错误的，就是一个 <code>object</code> 放生改变时，会触发两次回调一次是 <code>Move</code> 一次是 <code>Update</code>，最终导致数据源不一致导致崩溃，具体可以参考苹果开发者论坛上的这个<a href="https://forums.developer.apple.com/thread/4999" target="_blank" rel="noopener">讨论</a>，讨论中给出了一种解决方案就是把 <code>Move</code> 拆成 <code>Delete</code> 和 <code>Insert</code>，亲测也是可行的。</p><p>在用 <code>NSFetchedResultsController</code> 时候，你有没有遇到其他问题呢？欢迎一起探讨~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fix All issue</title>
      <link href="/2018/05/01/2018/5/fix-all-issue/"/>
      <url>/2018/05/01/2018/5/fix-all-issue/</url>
      
        <content type="html"><![CDATA[<h2 id="Fix-All-issue"><a href="#Fix-All-issue" class="headerlink" title="Fix All issue"></a>Fix All issue</h2><p><strong>作者</strong>: <a href="https://weibo.com/touristdiary" target="_blank" rel="noopener">南峰子</a></p><p>我们在写代码时，可能不经意没有通过 Refactor -&gt; Rename 修改了某个方法名，或者类似于 Swift 这种破坏式升级，或者其它各种原因，而造成多个多个错误。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/11-1.png" alt></p><p>Xcode 为我们提供了一个功能：Fix All Issues，只要 Xcode 知道问题在哪，就可以通过这种方式一次性解决这些问题。</p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/11-2.png" alt></p><p><img src="https://github.com/awesome-tips/iOS-Tips/blob/master/images/2018/05/11-3.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为icon换装</title>
      <link href="/2018/04/01/2018/4/wei-icon-huan-zhuang/"/>
      <url>/2018/04/01/2018/4/wei-icon-huan-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="为icon换装"><a href="#为icon换装" class="headerlink" title="为icon换装"></a>为icon换装</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>最近一直在研究怎么减少资源文件，如果产品童鞋要用不同颜色的图片展示不同的状态，状态 A 是绿色的，状态 B 是红色的，状态 C 是黄色，图案都是一样的，只是颜色不同，也许你会让设计童鞋切3张图，但这种方式不太优雅。</p><p>有两种方案：一个是使用 <code>tintColor</code>，可以简单的实现更换颜色；如果这个方法不能满足需求，可以使用绘制的方式，可选参数会多很多。喵神之前发表过一篇文章——<strong>《iOS中使用blend改变图片颜色》</strong>很是受用，虽然发表时间有点早，但我个人觉得还是比较实用。</p><p>我们可以使用 <code>UIImage</code> 的 <code>-drawInRect:blendMode:alpha:</code> 方法，封装后一行代码搞定你想要的任何颜色，直接上代码：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/8-1.jpg?raw=true" alt></p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/8-2.jpg?raw=true" alt></p><p>运行效果如图：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/8-3.jpg?raw=true" alt></p><p><code>kCGBlendModeDestinationIn</code> 是保留透明度信息；但如果图片中有阴影就需要与 <code>kCGBlendModeOverlay</code> 或者 <code>kCGBlendModeMultiply</code> 或其它参数根据实际情况叠加使用。</p><p>喵神已经把原理讲解的很详细了，感兴趣的童鞋可以移步：<a href="https://onevcat.com/2013/04/using-blending-in-ios/" target="_blank" rel="noopener">https://onevcat.com/2013/04/using-blending-in-ios/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>说说 NSTimer 的新 API</title>
      <link href="/2018/04/01/2018/4/shuo-shuo-nstimer-de-xin-api/"/>
      <url>/2018/04/01/2018/4/shuo-shuo-nstimer-de-xin-api/</url>
      
        <content type="html"><![CDATA[<h2 id="说说-NSTimer-的新-API"><a href="#说说-NSTimer-的新-API" class="headerlink" title="说说 NSTimer 的新 API"></a>说说 NSTimer 的新 API</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>在以往的 iOS 版本中，我们为了避免 NSTimer 的循环引用问题，一个比较常用的解决办法是为 NSTimer 添加一个 category，新增传入 block 类型参数的接口。分类内部实现是将此 block 作为 NSTimer 的 userInfo 参数传入，而 NSTimer的 target 则设置为 timer 自己。以此来避免 NSTimer 持有 VC。代码如下:</p><pre class=" language-objc"><code class="language-objc">// NSTimer+BlocksSupport.h#import <Foundation/Foundation.h>@interface NSTimer (BlocksSupport)+ (NSTimer *)ly_scheduledTimerWithTimeInterval:(NSTimeInterval)intervalrepeats:(BOOL)repeatsblock:(void(^)())block;@end// NSTimer+BlocksSupport.m#import "NSTimer+BlocksSupport.h"@implementation NSTimer (BlocksSupport)+ (NSTimer *)ly_scheduledTimerWithTimeInterval:(NSTimeInterval)intervalrepeats:(BOOL)repeatsblock:(void(^)())block;{    return [self scheduledTimerWithTimeInterval:interval                        target:self                      selector:@selector(ly_blockInvoke:)                      userInfo:[block copy]                       repeats:repeats];}+ (void)ly_blockInvoke:(NSTimer *)timer {    void (^block)() = timer.userInfo;    if(block) {        block();    }}@end</code></pre><p>而在 iOS 10 之后，苹果终于为 NSTimer 添加了一个官方 API，支持传入 block 类型参数。可谓是千呼万唤始出来。新官方 API 包括：</p><pre class=" language-objc"><code class="language-objc">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)intervalrepeats:(BOOL)repeatsblock:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)intervalrepeats:(BOOL)repeatsblock:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>讨论一个常见的需求实现</title>
      <link href="/2018/04/01/2018/4/tao-lun-yi-ge-chang-jian-de-xu-qiu-shi-xian/"/>
      <url>/2018/04/01/2018/4/tao-lun-yi-ge-chang-jian-de-xu-qiu-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="讨论一个常见的需求实现"><a href="#讨论一个常见的需求实现" class="headerlink" title="讨论一个常见的需求实现"></a>讨论一个常见的需求实现</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>今天 <code>Lefe_x</code> 打算和大家讨论一个非常常见的需求。如果是你，你会咋么做？你会不会使用一种更优雅的方式？</p><p><strong>PM</strong>：我们要实现一个下载音频的功能，下载前需要做这些处理。</p><ul><li>如果网络异常，直接提示网络异常并退出下载；</li><li>如果是 4G 网络，需要弹窗提醒用户选择是否继续下载，用户点击下载后进入下载流程，取消后直接退出下载；</li><li>如果 wifi 直接进入下载；</li><li>下载时需要获去下载地址，获取到下载地址后，进入下载；</li><li>下载完成需要刷新 UI；</li></ul><p>梳理完逻辑后是这样的：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/6-1.jpg?raw=true" alt></p><p><strong>我</strong>：这个好办，不一会就写完了，结果是这样的。</p><pre><code>- (void)downloadCallBack:(void(^)(BOOL isSuccess))callback{    if ([self isBadNetwork]) {        callback(NO);        return;    }    if ([self is4GNetwork]) {        [self showAlert:^(NSInteger index) {            if (index == 1) {                [self requestDownloadUrl:^(NSString *url) {                    [self startDownloadWithURLString:url callback:^(BOOL isSuccess) {                        callback(YES);                    }];                }];            } else {                callback(NO);            }        }];    } else {        [self requestDownloadUrl:^(NSString *url) {            [self startDownloadWithURLString:url callback:^(BOOL isSuccess) {                callback(YES);            }];        }];    }}</code></pre><p>上面这种写法主要有回调地狱和很多冗余代码，解决这种问题，我们可以使用 <code>Promise</code> 这种异步编程的方式来避免这些问题。如下：</p><pre><code>- (void)downloadForPromiseCallBack:(void(^)(BOOL isSuccess))callback{    // 检查是否可以下载    AnyPromise *checkPromise = [self checkCanDownloadPromise];    checkPromise.then(^(){        // 请求下载地址        return [self requestUrlPromise];    }).then(^(NSString *downloadUrl){        // 开始下载音频        return [self downloadPromiseWithURLString:downloadUrl];    }).then(^(){        // 下载成功        if (callback) {            callback(YES);        }    }).catch(^(NSError *error){        // 所有的异常        callback(NO);    });}</code></pre><p>如果你有好的想法，不防提出来，我们一起讨论哈。</p><p>参考：</p><p><strong>primise 的使用</strong> <code>https://github.com/lefex/LefexWork/blob/master/blog/iOS/Promise.md</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模块化带来的痛之模块之间的数据同步</title>
      <link href="/2018/04/01/2018/4/mo-kuai-hua-dai-lai-de-tong-zhi-mo-kuai-zhi-jian-de-shu-ju-tong-bu/"/>
      <url>/2018/04/01/2018/4/mo-kuai-hua-dai-lai-de-tong-zhi-mo-kuai-zhi-jian-de-shu-ju-tong-bu/</url>
      
        <content type="html"><![CDATA[<h2 id="模块化带来的痛之模块之间的数据同步"><a href="#模块化带来的痛之模块之间的数据同步" class="headerlink" title="模块化带来的痛之模块之间的数据同步"></a>模块化带来的痛之模块之间的数据同步</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>如今，模块化已经屡见不鲜，目前很多公司都在做。然而在使用模块化的过程中，各个模块之间是如何通信的？我们一起先看下具体的需求：</p><p>PM：这一版本做一个下载功能，包含我的下载，待下载，正在下载等，下载入口会在A，B，C模块中都会显示，而且需要把下载状态和进度实时显示到 UI 上。</p><p>我：从需求出发，需要设计一个下载模块。但是，<strong>A，B，C 模块都需要实时了解当前的下载状态和进度以展示到 UI</strong>，那么问题来了如何做到下载模块与 A，B，C 模块之间进行下载状态和进度同步呢？</p><p>模块之间数据同步可以有以下几种方式：</p><ul><li><p>1.通知<br>通知是最简单的方式，每当下载状态和进度变化的时候，需要发通知出去，这样其它模块即可接收到当前的变化。他的缺点是通知太分散，不太好控制。</p></li><li><p>2.注册监听<br>下载队列是一个单例，可以直接通过路由的方式注册监听，当下载状态和进度变化的时候给注册者发送消息。</p></li></ul><p>如果你有什么好的方式，欢迎讨论，这条小集只是起到了抛砖引玉的作用，希望大家可以把更好的方案分享出来。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我们可以利用 NSURLProtocol 做什么</title>
      <link href="/2018/04/01/2018/4/wo-men-ke-yi-li-yong-nsurlprotocol-zuo-shi-me/"/>
      <url>/2018/04/01/2018/4/wo-men-ke-yi-li-yong-nsurlprotocol-zuo-shi-me/</url>
      
        <content type="html"><![CDATA[<h2 id="我们可以利用-NSURLProtocol-做什么"><a href="#我们可以利用-NSURLProtocol-做什么" class="headerlink" title="我们可以利用 NSURLProtocol 做什么"></a>我们可以利用 NSURLProtocol 做什么</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>今天和大家聊一聊 <code>NSURLProtocol</code>，可能你已经听说过它。因篇幅有限，这里不讲解具体的使用方式，主要是和大家聊一聊我们可以利用 <code>NSURLProtocol</code> 做的一系列事情，权当抛砖引玉，大家可以根据自己的需要去深入了解。</p><p>简单来说 <code>NSURLProtocol</code> 是苹果 <code>URL Loading System</code> 中的一个抽象类。通过实现其子类并注册到 app 中，我们可以拦截 <code>app</code> 中的网络请求。那么拦截网络请求可以做什么呢？这里举几个小例子：</p><ul><li><code>app</code> 内置了测试服、正式服的切换开关，需要通过开关一键切换所有网络请求使用的 <code>server</code> 地址。</li><li>项目内部分模块使用了 <code>ReactNative</code>，需要动态配置由前端发出的网络请求 <code>server</code> 地址（特殊在于虽然是前端发出，但并非来自 <code>webview</code> ）。这个例子和例 1 类似。</li><li>项目内含有 <code>hybrid</code> 模块。对 <code>hybrid</code> 页面加速的一个策略，可以是客户端在合适时机提前缓存资源文件，并且以与 <code>webview</code> 加载资源的路径相对应的方式存储在本地。这样当 <code>webview</code> 加载资源时，通过拦截判断是否是本地已经存在的资源的请求，如果是，则使用本地资源构造 <code>response</code> 。这样可以显著提升被过多资源请求影响的加载速度。</li><li>限制 <code>app</code> 内 <code>webview</code> 的跳转行为，例如禁止向某域名下的跳转，或者对于某个域名下的跳转做重定向操作。当然这些使用 <code>webview</code> 的代理方法也可以做到。</li><li>对于 <code>app</code> 内发出的所有网络请求，需要添加公共的 <code>header</code> 内容。</li><li>需要统计 <code>app</code> 内各处对某个 <code>api</code> 的调用次数等数据。</li><li>需要统计 <code>app</code> 内的网络请求失败率。</li></ul><p>参考链接：</p><ul><li><a href="https://juejin.im/post/584f9d0a128fe10058b8c4b6" target="_blank" rel="noopener">https://juejin.im/post/584f9d0a128fe10058b8c4b6</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何优雅地获取 ScrollView 的滚动方向</title>
      <link href="/2018/04/01/2018/4/ru-he-you-ya-di-huo-qu-scrollview-de-gun-dong-fang-xiang/"/>
      <url>/2018/04/01/2018/4/ru-he-you-ya-di-huo-qu-scrollview-de-gun-dong-fang-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="如何优雅地获取-ScrollView-的滚动方向"><a href="#如何优雅地获取-ScrollView-的滚动方向" class="headerlink" title="如何优雅地获取 ScrollView 的滚动方向"></a>如何优雅地获取 ScrollView 的滚动方向</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>在有些场景，我们可能需要获取 <code>UIScrollView</code>（及其子类）的滚动方向来做不同的操作。</p><p>我们首先能想到最直观的方法是：用一个变量或属性 lastContentOffset 去保存 scrollView 上次的 <code>content offset</code> 值，然后在 <code>UIScrollView</code> 的 <code>scrollViewDidScroll:</code> delegate 方法中跟 scrollView 当前实时的 <code>content offset</code> 做对比来判断滚动方向，代码大致如下：</p><pre class=" language-objc"><code class="language-objc">// @property (nonatomic, assign) CGFloat lastContentOffset;- (void)scrollViewDidScroll:(UIScrollView *)scrollView {    if (self.lastContentOffset > scrollView.contentOffset.y) {        // 向下滚动    } else if (self.lastContentOffset < scrollView.contentOffset.y) {        // 向上滚动    }    self.lastContentOffset = scrollView.contentOffset.y;}</code></pre><p>今天我们同事在阅读第三方开源代码时，看到一个更简便的方法，同样在 <code>scrollViewDidScroll:</code> 方法中，先获取 scrollView 的 <code>panGestureRecognizer</code>（拖拽/移动动作）手势，然后把手势滑动的相对偏移在当前 view 上转换成一个 <code>point</code>，最后根据 <code>point</code> 的 x 或 y 来判断左右/上下滚动方向，代码如下：</p><pre class=" language-objc"><code class="language-objc">- (void)scrollViewDidScroll:(UIScrollView *)scrollView {    CGPoint point = [scrollView.panGestureRecognizer translationInView:self.view];    if (point.y > 0) {        // 向下滚动    } else {        // 向上滚动    }}</code></pre><p>虽然这种方式看似很优雅，可以不用借助额外的变量来完成，但它存在一个问题，如下图所示，我们手指按住屏幕不放，先向上滑动一段距离（从 A -&gt; B，向上）然后改变滑动方向再向下滑动一段距离，（从 B -&gt; A -&gt; C，向下）：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/3-1.png?raw=true" alt></p><p>但这时候通过第二种方法判断实际得到的结果是：A -&gt; B 向上滚动，B -&gt; A 向上滚动，A -&gt; C 向下滚动，显然，其中 B -&gt; A 的方向判断是错的，应该是向下。</p><p>原因在于，上述方法中拖拽手势的相对偏移 <code>point</code> 是根据滑动的起始点 A 来进行计算的，所在只要手势停留在起始点 A 之上，不管向上还是向下滑动，它都认为是向上滚动了。</p><p>所以这种优雅的方法只适用于 scrollView 一次手势滑动中不改变方向的情况。</p><p>参考连接：<a href="https://stackoverflow.com/questions/2543670/finding-the-direction-of-scrolling-in-a-uiscrollview" target="_blank" rel="noopener">Finding the direction of scrolling in a UIScrollView?</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于 Xcode console 输出的 UIImage 警告的解决方式</title>
      <link href="/2018/04/01/2018/4/guan-yu-xcode-console-shu-chu-de-uiimage-jing-gao-de-jie-jue-fang-shi/"/>
      <url>/2018/04/01/2018/4/guan-yu-xcode-console-shu-chu-de-uiimage-jing-gao-de-jie-jue-fang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-Xcode-console-输出的-UIImage-警告的解决方式"><a href="#关于-Xcode-console-输出的-UIImage-警告的解决方式" class="headerlink" title="关于 Xcode console 输出的 UIImage 警告的解决方式"></a>关于 Xcode console 输出的 UIImage 警告的解决方式</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>最近项目中遇到 Xcode console 偶尔输出 <code>[framework] CUICatalog: Invalid asset name supplied: &#39;(null)&#39;</code> 这样一段 <code>warning</code>，毫无头绪。在爆栈上看到有人遇到一样的问题，原因是由于 <code>[UIImage imageNamed:]</code> 传了 <code>nil</code> 或者传入的 <code>string</code> 的 <code>length</code> 为0。至于怎么找到具体是哪里传了 <code>nil</code>，可以打一个全局断点，然后加一个条件来判断入参是否为空，即可找到有问题的地方。如图所示</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/4-1.jpg?raw=true" alt></p><p>还有遇到 <code>Could not load the &quot;some-image-name&quot; image referenced from a nib in the bundle with identifier &quot;com.xxxx&quot;</code> 这种情况，一般情况下是这张图片被删除了，但是 <code>Xib/Storyboard</code> 中还引用了这张图片，表现形式主要是 <code>UIImageView</code> 的 <code>image</code> 属性一栏是 <code>Unknown</code>，如下图</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/4-2.png?raw=true" alt></p><p>只要把这个 <code>Unknown</code> 改成对应图片即可。</p><p>参考链接：<br><a href="http://t.cn/R06T3OW" target="_blank" rel="noopener">Error: CUICatalog: Invalid asset name supplied</a><br><a href="http://t.cn/RmXu0sN" target="_blank" rel="noopener">Could not load the “xxx” image referenced from a nib in the bundle with identifier</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 Toolchains 在 Xcode 中切换 Swift 版本</title>
      <link href="/2018/04/01/2018/4/shi-yong-toolchains-zai-xcode-zhong-qie-huan-swift-ban-ben/"/>
      <url>/2018/04/01/2018/4/shi-yong-toolchains-zai-xcode-zhong-qie-huan-swift-ban-ben/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Toolchains-在-Xcode-中切换-Swift-版本"><a href="#使用-Toolchains-在-Xcode-中切换-Swift-版本" class="headerlink" title="使用 Toolchains 在 Xcode 中切换 Swift 版本"></a>使用 Toolchains 在 Xcode 中切换 Swift 版本</h2><p><strong>作者</strong>: <a href="https://weibo.com/touristdiary" target="_blank" rel="noopener">南峰子_老驴</a></p><p>我们每次安装新版本的 <code>Xcode</code> 的时，新 <code>Xcode</code> 都只包含最新版本的 <code>Swift</code>。但通常我们的代码或第三方库还来不及匹配，或者我们想看看新的特性在新旧版本之间的区别，这时候就比较头大了。</p><p>苹果爸爸给的解决方案是：<code>multiple Swift toolchains</code>。每个版本的 <code>Swift</code> 都可以单独下载安装。我们可以在 <code>Swift</code> 官方博客上下载：<a href="https://swift.org/download/#releases。每个" target="_blank" rel="noopener">https://swift.org/download/#releases。每个</a> <code>toolchain</code> 都是一个 <code>.pkg</code> 安装包。我们下载安装完成后，重新启动 <code>Xcode</code>，就可以在 <code>Xcode</code> 的菜单上找到 <code>toolchains</code> 了。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/1-1.png?raw=true" alt></p><p>另外，我们也可以在 <code>Preference -&gt; Components: Toolchains</code> 面板里面来管理 <code>Toolchains</code>，如切换、删除等。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/1-2.png?raw=true" alt></p><p>需要注意的是，<code>Xcode</code> 自带的默认的 <code>toolchains</code> 不能被移除。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 LLDB bugreport 命令导出 App 运行崩溃日志</title>
      <link href="/2018/04/01/2018/4/shi-yong-lldb-bugreport-ming-ling-dao-chu-app-yun-xing-beng-kui-ri-zhi/"/>
      <url>/2018/04/01/2018/4/shi-yong-lldb-bugreport-ming-ling-dao-chu-app-yun-xing-beng-kui-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-LLDB-bugreport-命令导出-App-运行崩溃日志"><a href="#使用-LLDB-bugreport-命令导出-App-运行崩溃日志" class="headerlink" title="使用 LLDB bugreport 命令导出 App 运行崩溃日志"></a>使用 LLDB bugreport 命令导出 App 运行崩溃日志</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>在日常开发调试 <code>App</code> 过程中，当我们写的代码有 <code>Bug</code> 导致崩溃时，此时我们通常会断点到崩溃的位置，然后查看 <code>Xcode</code> 控制台输出崩溃原因进行解决。</p><p>但有些时候我们手头可能有其它的活不能立即进行排查，或者崩溃的是其他同事的代码，需要先把控制台的崩溃日志复制粘贴到其他地方保存起来，过后再看或者告知同事进行解决。强大的 <code>LLDB</code> 调试工具提供了一个 <code>bugreport</code> 命令帮我们快速完成导出日志这件事。</p><p>例如，有一段数组越界崩溃的代码如下：</p><pre class=" language-objc"><code class="language-objc">- (void)testBugReport {    NSArray *testArray = @[@"1", @"2", @"3"];    NSLog(@"%@", testArray[4]);}</code></pre><p>此时在控制台执行如下命令：</p><pre class=" language-ruby"><code class="language-ruby">bugreport unwind <span class="token operator">--</span>outfile <span class="token operator">/</span><span class="token constant">Users</span><span class="token operator">/</span>kangzubin<span class="token operator">/</span><span class="token constant">Desktop</span><span class="token operator">/</span>buglog<span class="token punctuation">.</span>txt</code></pre><p>它可以生成一份当前 App 运行状态的完整报告，包含崩溃的调用栈信息，大致如下：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/7-1.png?raw=true" alt></p><p>另外，我们可以在上述命令后面加一个 <code>--append-outfile</code> 修饰符，用于在已有的日志文件中追加新的崩溃日志信息，而不是覆盖。</p><pre><code>bugreport unwind --outfile &lt;path to output file&gt; --append-outfile</code></pre><p>参考：<a href="https://medium.com/flawless-app-stories/debugging-swift-code-with-lldb-b30c5cf2fd49" target="_blank" rel="noopener">Debugging Swift code with LLDB</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>水平或者竖直布局方案</title>
      <link href="/2018/04/01/2018/4/shui-ping-huo-zhe-shu-zhi-bu-ju-fang-an/"/>
      <url>/2018/04/01/2018/4/shui-ping-huo-zhe-shu-zhi-bu-ju-fang-an/</url>
      
        <content type="html"><![CDATA[<h2 id="水平或者竖直布局方案"><a href="#水平或者竖直布局方案" class="headerlink" title="水平或者竖直布局方案"></a>水平或者竖直布局方案</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/10-1.jpg?raw=true" alt></p><p>如果想实现上图这种水平布局，大家会采取哪些技术方案呢？一些常规操作我就不介绍了，我主要是介绍2种比较方便的解决方案，可以适用于固定个数的子视图和不确定个数的子试图（eg:根据接口返回显示子视图的个数）。</p><p>首先推荐iOS9之后推出的<strong>UIStackView</strong>，使用比较方便，嵌套使用也比较方便，如果是在xib或者Storyboard直接拖几个控件，设置一下属性就可以实现上面的效果，如果手动Coding的话也很简单，如图：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/10-2.jpg?raw=true" alt></p><p>另一个方案是<strong>Masonry</strong>库封装的方法，这种布局也可以轻松实现，如图：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/10-3.jpg?raw=true" alt></p><p>如果有其他更简单的方案，欢迎一起分享！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>webview关闭时手动停止音频播放</title>
      <link href="/2018/04/01/2018/4/webview-guan-bi-shi-shou-dong-ting-zhi-yin-pin-bo-fang/"/>
      <url>/2018/04/01/2018/4/webview-guan-bi-shi-shou-dong-ting-zhi-yin-pin-bo-fang/</url>
      
        <content type="html"><![CDATA[<h2 id="webview关闭时手动停止音频播放"><a href="#webview关闭时手动停止音频播放" class="headerlink" title="webview关闭时手动停止音频播放"></a>webview关闭时手动停止音频播放</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>当我们使用 webview 展示网页时，页面内若含有音频标签，点击播放，这时关闭带有 webview 的 VC，会发现即使 webview 已经被释放，音频还是没有停止。这时可以采用比较快捷的方法来做到 webview 被关闭时停止正在播放的音频：webview 重新 load 页面，或者执行停止音频播放的 JavaScript 语句。</p><p>这里以 UIWebview 举例，WKWebview 同理。</p><p>方法一：重新 load 一个空白页面</p><blockquote><p>[self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@”about:blank”]]];</p></blockquote><p>方法二：手动执行停止音频的 JavaScript 语句</p><blockquote><p>[self.webView stringByEvaluatingJavaScriptFromString:@”audioPause()”];</p></blockquote><p>当然，这两种方法都是比较简便但不优雅的实现方式，适合轻度使用 webview 的场景。如果你们对于 webview 做了比较多的加工，是可以监听 webview 中的音频、视频任务，来手动停止的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS9之后字符串变换API</title>
      <link href="/2018/04/01/2018/4/ios9-zhi-hou-zi-fu-chuan-bian-huan-api/"/>
      <url>/2018/04/01/2018/4/ios9-zhi-hou-zi-fu-chuan-bian-huan-api/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS9之后字符串变换API"><a href="#iOS9之后字符串变换API" class="headerlink" title="iOS9之后字符串变换API"></a>iOS9之后字符串变换API</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>今天给大家介绍的是 <code>iOS9</code> 之后 <code>NSString</code> 新增的方法：<br><code>- (nullable NSString *)stringByApplyingTransform:(NSStringTransform)transform reverse:(BOOL)reverse</code><br>，我用了它的翻译功能之后，喜欢称之为翻译方法，说是翻译可能不太准确，语言变换会更准确一些。</p><p><code>iOS</code> 实现了部分 <code>ICU</code>（International Components for Unicode的缩写，主要提供提供了 Unicode 和全球化支持）功能，所以才有了这个方法的诞生。因此除了系统提供的转换方式（如下图）之外，还支持ICU语法。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/5-1.jpg?raw=true" alt></p><p><code>ICU</code> 转换语法比如说，简体转繁体（Hans-Hant），繁体转简体（Hant-Hans），字母过滤（[:^Letter:] Remove），还有转换成小写（Lower）等等。</p><p>我做了一个简单的Demo，核心代码如下：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/5-2.jpg?raw=true" alt></p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/5-3.jpg?raw=true" alt></p><p>是不是发现项目里汉语转拼音的三方库也可以干掉了？<br>😜比较遗憾的是ICU是不支持英文翻译的，所以这个API<br>也是不支持的。只支持简体，繁体，日语，韩语等多语言的APP用这个方法还是比较方便的，在处理字符串上面也是比较不错，去掉emoji也可以一行代码搞定。</p><p>ICU相关内容详看：<a href="http://userguide.icu-project.org/transforms/general/rules" target="_blank" rel="noopener">http://userguide.icu-project.org/transforms/general/rules</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 你的APP中能藏的住秘密吗？</title>
      <link href="/2018/04/01/2018/4/ios-ni-de-app-zhong-neng-cang-de-zhu-mi-mi-ma/"/>
      <url>/2018/04/01/2018/4/ios-ni-de-app-zhong-neng-cang-de-zhu-mi-mi-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-你的APP中能藏的住秘密吗？"><a href="#iOS-你的APP中能藏的住秘密吗？" class="headerlink" title="iOS 你的APP中能藏的住秘密吗？"></a>iOS 你的APP中能藏的住秘密吗？</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>今天知识小集以不一样的方式给大家推送一条“小”集。经过不断的打磨，为知识小集提供的微信截图工具已开源，有需要的小伙伴可以点击原文下载，还没关注知识小集的公众号，点原文关注哈。本文主要向大家普及一些逆向的知识，以防止别人破解你的APP，拿到重要数据。其实，APP中没有什么安全可言，别人都会轻而易举拿到APP中的数据，修改代码的执行逻辑等。昨天转发了 <code>@没故事的桌同学</code> 的一条微博，有很多同学咨询说使用 <code>Reveal</code> 必须使用越狱机吗？当然不用也可以。文章会有提到，<a href="https://juejin.im/post/5accbc05f265da238a30c7fd" target="_blank" rel="noopener">查看原理</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 11 后还使用旧方法获取设备剩余空间？</title>
      <link href="/2018/04/01/2018/4/ios-11-hou-huan-shi-yong-jiu-fang-fa-huo-qu-she-bei-sheng-yu-kong-jian/"/>
      <url>/2018/04/01/2018/4/ios-11-hou-huan-shi-yong-jiu-fang-fa-huo-qu-she-bei-sheng-yu-kong-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-11-后还使用旧方法获取设备剩余空间？"><a href="#iOS-11-后还使用旧方法获取设备剩余空间？" class="headerlink" title="iOS 11 后还使用旧方法获取设备剩余空间？"></a>iOS 11 后还使用旧方法获取设备剩余空间？</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p><strong>iOS11</strong></p><p><code>iOS11</code> 以后使用 <code>NSHomeDirectory()</code> 这种方式获取手机剩余空间总是不准，经测试差不多少 <code>2G</code> 左右，最后查文档后发现 <code>iOS11</code> 后苹果新增了 <code>API</code>。 所以 <code>iOS11</code> 以后需要使用新的 <code>API</code> 才能获取到真实的剩余空间，不过 <code>BYTE</code> 转换为 <code>KB</code> 的时候苹果使用的是 <code>1000</code>，而腾讯视频使用的是 <code>1024</code>。</p><blockquote><p>The query type to use depends on what’s being stored. If you’re storing data based on a user request or resources the app requires to function properly (for example, a video the user is about to watch or resources that are needed for the next level in a game), query against <code>NSURLVolumeAvailableCapacityForImportantUsageKey</code>. However, if you’re downloading data in a more predictive manner (for example, downloading a newly available episode of a TV series that the user has been watching recently), query against <code>NSURLVolumeAvailableCapacityForOpportunisticUsageKey</code>.</p></blockquote><ul><li><p><code>NSURLVolumeTotalCapacityKey</code>获取到整个手机的存储空间，比如32G的手机获取的数据是32G；</p></li><li><p><code>NSURLVolumeAvailableCapacityKey</code> 可用容量；</p></li><li><p><code>NSURLVolumeAvailableCapacityForImportantUsageKey</code> 苹果建议如果下载视频或者游戏下一关的数据用这个，经调查发现系统中的剩余空间和腾讯视频使用的都是这个；</p></li><li><p><code>NSURLVolumeAvailableCapacityForOpportunisticUsageKey</code>苹果建议如果您以更具预见性的方式下载数据（例如，下载最近使用的一个电视系列节目，用户最近一直在观看）。</p></li></ul><p><strong>iOS11以前</strong></p><p><code>iOS11</code> 以前获取的手机剩余空间总是多余系统中的剩余空间。我手机系统是<code>iOS9.3.1</code> 获取到的剩余空间差不多为 <code>7.98G</code>，而系统显示为 <code>7.8G</code>，比系统获取的还要多，而且不确定苹果使用的是 <code>1000</code> 还是 <code>1024</code> 进行转换，如果使用 <code>1000</code> 转换的话，那么我获取到的剩余空间会比系统显示的剩余空间还要大。如果我用 <code>1000</code> 转换，大约为 <code>8.56GB</code>。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/2-1.png?raw=true" alt></p><p>参考</p><p><a href="https://developer.apple.com/documentation/foundation/nsurlresourcekey/checking_volume_storage_capacity?language=objc" target="_blank" rel="noopener">Checking Volume Storage Capacity</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode 9 中快速定位目标控制器</title>
      <link href="/2018/04/01/2018/4/xcode-9-zhong-kuai-su-ding-wei-mu-biao-kong-zhi-qi/"/>
      <url>/2018/04/01/2018/4/xcode-9-zhong-kuai-su-ding-wei-mu-biao-kong-zhi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="Xcode-9-中快速定位目标控制器"><a href="#Xcode-9-中快速定位目标控制器" class="headerlink" title="Xcode 9 中快速定位目标控制器"></a>Xcode 9 中快速定位目标控制器</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/2565466125" target="_blank" rel="noopener">moon2light</a></p><p>你有没有这种困扰，接手一个老项目或项目目录结构复杂的时候，我们要修改某个控制器的界面/功能时，控制器的定位就有些许困难。苹果爸爸很早就意识到这个问题了，也一直在优化这里，今天就分享一下该 <code>UI</code> 调试小技巧。</p><p>充分条件:</p><ol><li><code>Xcode 9.0</code> 及以上</li><li>模拟器/真机 <code>iOS 11.0</code> 及以上</li></ol><p>过程:</p><p>1.模拟器/真机定位需要调试的界面.</p><p>2.定位到 <code>debug</code> 工具 -&gt; 点击 <code>debug view hierarchies</code>。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/9-1.jpeg?raw=true" alt></p><p>3.轻转一下视图层次,就可以看到整个的页面的层次结构,今天的重点在这里,控制器实例。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/9-2.jpeg?raw=true" alt></p><p>4.点击控制器实例(上图红框部分),看 <code>Xcode</code> 右侧 <code>show the object inspector</code>。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/9-3.jpeg?raw=true" alt></p><p>5.当当当~是不是感觉到类名很熟悉,点击右侧小箭头,就会跳转到对应控制器的 .h 文件。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/04/9-4.jpeg?raw=true" alt></p><p>6.<code>command+shift+j</code> 文件导航栏中定位文件,找到 <code>.m</code> 文件,  <code>enjoy debugging</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C 可变容器对象的初始化方法使用总结</title>
      <link href="/2018/04/01/2018/4/objective-c-ke-bian-rong-qi-dui-xiang-de-chu-shi-hua-fang-fa-shi-yong-zong-jie/"/>
      <url>/2018/04/01/2018/4/objective-c-ke-bian-rong-qi-dui-xiang-de-chu-shi-hua-fang-fa-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="Objective-C-可变容器对象的初始化方法使用总结"><a href="#Objective-C-可变容器对象的初始化方法使用总结" class="headerlink" title="Objective-C 可变容器对象的初始化方法使用总结"></a>Objective-C 可变容器对象的初始化方法使用总结</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>最近在 Review Code 时，发现团队中不同成员对一个 <code>可变字典空对象</code> 的初始化方式写法都不太一致，主要有以下几种：</p><pre class=" language-objc"><code class="language-objc">// 第 1 种NSMutableDictionary *dict1 = [[NSMutableDictionary alloc] init];// 第 2 种NSMutableDictionary *dict2 = [NSMutableDictionary new];// 第 3 种NSMutableDictionary *dict3 = [NSMutableDictionary dictionary];// 第 4 种NSMutableDictionary *dict4 = [NSMutableDictionary dictionaryWithCapacity:10];// 第 5 种NSMutableDictionary *dict5 = @{}.mutableCopy;</code></pre><p>我们知道在 Objective-C 中主要有三大容器，分别是数组、字典、集合，它们各自都对应有可变对象和不可变对象，如：<code>NSArray</code>/<code>NSMutableArray</code>, <code>NSDictionary</code>/<code>NSMutableDictionary</code>, <code>NSSet</code>/<code>NSMutableSet</code>, 我们这里不再赘述它们的区别和使用方式，下面主要以 <code>NSMutableDictionary</code> 为例介绍以上几种初始化写法的不同。</p><p>第 1 种就是我们常见初始化一个 <code>NSObject</code> 对象的写法，其中 <code>alloc</code> 为 <code>NSObject</code> 的类方法，它用于创建（分配内存）并返回指定类一个的新对象，而 <code>init</code> 为 <code>NSObject</code> 的实例方法，一般由子类重新实现，用于初始化一个刚创建 (allocated) 的对象。</p><p>第 2 种写法，对于 <code>NSObject</code> 的 <code>new</code> 方法，<a href="https://developer.apple.com/documentation/objectivec/nsobject/1571948-new" target="_blank" rel="noopener">苹果文档</a> 是这么说的：Allocates a new instance of the receiving class, sends it an init message, and returns the initialized object. 因此，它就是 <code>alloc</code> 和 <code>init</code> 方法的组合，与第 1 种写法是等价的。</p><p>第 3 种，<a href="https://developer.apple.com/documentation/foundation/nsdictionary/1574180-dictionary?language=objc" target="_blank" rel="noopener">文档描述</a>：Creates and returns an empty dictionary. 它也是一种快速的初始化写法。在 <strong>ARC</strong> 下，它与 <code>[[NSMutableDictionary alloc] init]</code> 是相同的；但在 <strong>MRC</strong> 手动管理内存时，使用 <code>[[NSMutableDictionary alloc] init]</code> 创建并初始化对象，后续我们需要手动调用 <code>release</code> 方法释放，而 <code>[NSMutableDictionary dictionary]</code> 相当于 <code>[[[NSMutableDictionary alloc] init] autorelease]</code>，区别在于你不用再调用 release 方法去释放它了。</p><p>第 4 种，相当于调用 <code>[[NSMutableDictionary alloc] initWithCapacity:10]</code> 方法，它用于创建一个可变字典对象并初始化分配给它足够的内存空间以存储指定长度（10）个内容对象，且当动态添加的数据超过初始化时指定的长度，也会自动增加分配新的内存，所以如果你可以确定要用的可变字典大致的存储个数，推荐使用这种方式。</p><p>对于第 5 种，我们知道 <code>@{}</code> 字面值相当于创建了一个不可变的 <code>NSDictionary</code> 空对象，然后调 NSObject 的 <code>mutableCopy</code> 拷贝成一个新的可变对象赋给 <code>dict5</code>。</p><p>此外，对于 <code>NSMutableArray</code> 和 <code>NSMutableSet</code> 也有与上述类似的几种不同的初始化写法，不再一一分析。</p><p>以上是对可变字典空对象的几种不同初始化写法的简单对比，你习惯用哪一种呢？欢迎留言讨论…</p><p><a href="https://stackoverflow.com/questions/4152322/to-create-an-empty-dictionary-nsmutabledictionary-dictionary-or-nsmutabledi" target="_blank" rel="noopener">参考链接1</a>、<a href="https://stackoverflow.com/questions/11256228/what-is-the-difference-between-class-new-and-class-alloc-init-in-ios/11256290" target="_blank" rel="noopener">参考链接2</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CoreData 检索遇到的坑及其解决方式</title>
      <link href="/2018/04/01/2018/4/coredata-jian-suo-yu-dao-de-keng-ji-qi-jie-jue-fang-shi/"/>
      <url>/2018/04/01/2018/4/coredata-jian-suo-yu-dao-de-keng-ji-qi-jie-jue-fang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="CoreData-检索遇到的坑及其解决方式"><a href="#CoreData-检索遇到的坑及其解决方式" class="headerlink" title="CoreData 检索遇到的坑及其解决方式"></a>CoreData 检索遇到的坑及其解决方式</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>项目中有用到 <code>CoreData</code> 的同学应该对 <a href="https://github.com/magicalpanda/MagicalRecord/" target="_blank" rel="noopener"><code>MagicalRecord</code></a> 这个库或多或少有一点了解，我们项目中也用到这个库的搜索功能即 <code>NSManagedObject (MagicalFinders)</code> 这个分类。</p><p>最近遇到一个问题就是两个 <code>CoreData</code> 的 <code>Model</code>，<code>Father</code> 和 <code>Son</code>，<code>Son</code> 继承自 <code>Father</code>。在 <code>Father</code> 执行 <code>MR_findxxx</code> 等一系列方法时，会把 <code>Son</code> 的实例也找出来。一番搜索下来发现有人在 <a href="https://github.com/magicalpanda/MagicalRecord/" target="_blank" rel="noopener"><code>MagicalRecord</code></a> 提了个类似的 <a href="http://t.cn/RmQD2Rj" target="_blank" rel="noopener">issue</a>。然后发现 <code>NSFetchRequest</code> 有一个 <code>includesSubentities</code> 属性，直接将其设置成 <code>NO</code>，即可。代码如下</p><pre class=" language-objc"><code class="language-objc">+ (NSArray *)findAllOrderBy:(NSString *)orderItem ascending:(BOOL)ascending inContext:(NSManagedObjectContext *)context {    NSFetchRequest *request = [self requestAllInContext:context];    [request setIncludesSubentities:NO];    [request setFetchBatchSize:[self defaultBatchSize]];    NSSortDescriptor *sortBy = [[NSSortDescriptor alloc] initWithKey:orderItem ascending:ascending];    [request setSortDescriptors:[NSArray arrayWithObject:sortBy]];    return [self executeFetchRequest:request inContext:context];}</code></pre><p>参考链接：</p><p><a href="http://t.cn/RmQD2Rj" target="_blank" rel="noopener">mr_fetchAllSorted fetches not only the parent entity but also the child entity</a></p><p><a href="http://t.cn/RmQDqYa" target="_blank" rel="noopener">NSPredicate that filters out subclass results</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CoreData 关系的4种删除规则</title>
      <link href="/2018/04/01/2018/4/coredata-guan-xi-de-4-chong-shan-chu-gui-ze/"/>
      <url>/2018/04/01/2018/4/coredata-guan-xi-de-4-chong-shan-chu-gui-ze/</url>
      
        <content type="html"><![CDATA[<h2 id="CoreData-关系的4种删除规则"><a href="#CoreData-关系的4种删除规则" class="headerlink" title="CoreData 关系的4种删除规则"></a>CoreData 关系的4种删除规则</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>由于项目是基于 <code>CoreData</code> 的，所以 <code>CoreData</code> 方面遇到的问题比较多。今天主要为大家分享一下 CoreData 中关系的4种删除规则。</p><p>先假设我们有两个实体，<code>Blog</code> 和 <code>Category</code>，一篇 <code>Blog</code> 只能属于一个 <code>Category</code>，一个 <code>Category</code> 可以有多篇 <code>Blog</code>。<br>如图:<br><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/1-1.jpg?raw=true" alt><br><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/05/1-2.jpg?raw=true" alt></p><p>1.No Action</p><p>规则为 <code>No Action</code> 时，当 <code>category</code> 删除时， <code>blogs</code> 是不会被通知到的，由于 <code>CoreData</code> 里关系是双向的，<code>blog</code> 这边依然认为他被关联到对应的 <code>category</code>。这种规则到目前还没用到过，也没有具体的使用场景，如果设置成 <code>No Action</code>，如果操作不当，可能会有崩溃发生</p><p>2.Nullify</p><p>还是拿上面举例，如果 <code>category</code> 被删除，<code>blog</code> 对应的 <code>category</code>  关系会被置为 <code>nil</code>。这个是系统默认删除规则，也是日常中用的最多的删除规则。</p><p>3.Cascade</p><p><code>Cascade</code> 规则某些场景下也十分有用。还是用上面例子，一般情况下，我们想 <code>category</code> 被删除之后，其拥有的所有 <code>blog</code> 实例也要删除，那这个时候直接将删除规则设置成这个即可。<code>CoreData</code> 在 <code>category</code> 删除后会自动将其关联的 <code>blog</code> 也全部删除。但这种情况一般只存在与一对多(或一对一)的情况，如果是多对多，就不适合用这种规则。</p><p>4.Deny</p><p>这个规则刚好和 <code>Cascade</code> 相反，<code>category</code> 只有在其所拥有的 <code>blogs</code> 都被删除的情况下才会被删除。这种情况在我们项目中，也没有具体使用场景。</p><p>综上，一般业务场景下 <code>Nullify</code> 和 <code>Cascade</code> 规则已经可以满足。如果有其他特殊场景也可以考虑1和4。欢迎补充和讨论~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>让失去焦点的 UIWebView 弹出键盘的方法</title>
      <link href="/2018/04/01/2018/4/rang-shi-qu-jiao-dian-de-uiwebview-dan-chu-jian-pan-de-fang-fa/"/>
      <url>/2018/04/01/2018/4/rang-shi-qu-jiao-dian-de-uiwebview-dan-chu-jian-pan-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="让失去焦点的-UIWebView-弹出键盘的方法"><a href="#让失去焦点的-UIWebView-弹出键盘的方法" class="headerlink" title="让失去焦点的 UIWebView 弹出键盘的方法"></a>让失去焦点的 UIWebView 弹出键盘的方法</h2><hr><p><strong>作者</strong>: <a href="https://weibo.com/agvicking" target="_blank" rel="noopener">折腾范儿_味精</a></p><p><code>UIWebView</code> 无法靠代码的方式让失去焦点的 <code>webview</code> 弹出键盘，必须人主动点击 <code>webview</code>，代码 <code>becomefirstresponder</code> 无效。这个问题是可以通过常规合法手段解决，而不是必须操作私有 <code>Api</code></p><p>1 <code>UIWebView</code> 有一个属性叫 <code>keyboardDisplayRequiresUserAction</code> 默认为 <code>YES</code>，就是说只有用户主动操作才可以展现键盘，可以把这行代码置为 <code>NO</code>；</p><p>2 然后你会发现你调用 <code>becomefirstresponder</code> 依然无效，原因是 <code>iOS Api</code> 依然无法工作，但是 <code>keyboardDisplayRequiresUserAction</code> 关闭，你可以通过 <code>js</code> 来操作 <code>dom</code> 的 <code>focus</code> 事件，从而展现键盘了；</p><p>3 <code>[uiwebview stringByEvaluatingJavaScriptFromString:@&quot;document.getElementById(&#39;content&#39;).focus()&quot;];</code>  注入一行 <code>js</code> 代码，让 <code>js</code> 对页面中的  ‘<code>content</code>’ 这个 <code>dom</code>，发起 <code>focus</code> 事件，键盘弹出；</p><p>4 注意，<code>iOS</code> 客户端同学不要原样照抄这行 <code>js</code> 代码，得根据你的 <code>web</code> 页面的 <code>dom</code> 甚至三方库自行调整 <code>js</code> 的注入代码；</p><p>5 简单总结一下：关闭 <code>keyboardDisplayRequiresUserAction</code> ，客户端注入 <code>js</code>，让 <code>js</code> 触发 <code>input</code> 区域的 <code>focus</code> 事件；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决修改 xcconfig 配置版本号和 build 号不生效的问题</title>
      <link href="/2018/03/01/2018/3/jie-jue-xiu-gai-xcconfig-pei-zhi-ban-ben-hao-he-build-hao-bu-sheng-xiao-de-wen-ti/"/>
      <url>/2018/03/01/2018/3/jie-jue-xiu-gai-xcconfig-pei-zhi-ban-ben-hao-he-build-hao-bu-sheng-xiao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="解决修改-xcconfig-配置版本号和-build-号不生效的问题"><a href="#解决修改-xcconfig-配置版本号和-build-号不生效的问题" class="headerlink" title="解决修改 xcconfig 配置版本号和 build 号不生效的问题"></a>解决修改 xcconfig 配置版本号和 build 号不生效的问题</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>之前我有介绍过 <code>xcconfig</code> 这个 tip，最近使用中遇到了一点小问题：当我使用 <code>xcconfig</code> 来管理版本号和 <code>build</code> 号时（如下图所示），</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/5-1.jpg?raw=true" alt></p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/5-2.jpg?raw=true" alt></p><p>编译一次之后，修改这两个值，此时我在运行的时候想把这两个值读出来，如下图所示：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/5-3.jpg?raw=true" alt></p><p>发现读出来的依然是修改之前的值，如下图所示：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/5-4.jpg?raw=true" alt></p><p>此时打开 <code>Product</code> 下面的 <code>Demo.app</code> 文件，查看 <code>Info.plist</code> 文件发现，里面果然显示的还是老值，如下图所示：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/5-5.jpg?raw=true" alt></p><p>这是因为使用 <code>xcconfig</code> 管理这两个值后，<code>Info.plist</code> 用的这两个值是 <code>User-Defined</code> 变量，并不能检测这两个变量内容有变更导致的缓存问题。最简单的解决办法就是 <code>Clean</code> 一下，再运行就能显示正确的值了，但对于中大型项目来说 <code>Clean</code> 的成本有点高，所以就想到了用脚本来解决这个问题（如下图所示），</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/5-6.jpg?raw=true" alt></p><p>每次运行时更新这两个缓存中的值即可。</p><p>如果有其他更好的解决办法，欢迎分享！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cycript调试第三方APP</title>
      <link href="/2018/03/01/2018/3/cycript-diao-shi-di-san-fang-app/"/>
      <url>/2018/03/01/2018/3/cycript-diao-shi-di-san-fang-app/</url>
      
        <content type="html"><![CDATA[<h1 id="Cycript调试第三方APP"><a href="#Cycript调试第三方APP" class="headerlink" title="Cycript调试第三方APP"></a>Cycript调试第三方APP</h1><hr><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>试想一种场景，我想知道某个第三方 APP 当前页面对应的是哪个 VC，想让某个实例执行某个函数后的效果，打印当前的视图层级，咋么办？</p><p>其实使用 Cycript 即可解决这几个问题，Cycript是一门脚本语言，可以把某段代码注入到某个进程中。比如我可以把用 Cycript 编写的代码植入到一个运行的 APP 中，这样 APP 就可以执行注入的代码。下面的测试需要安装 MonkeyDev。 </p><p>安装 Cycript 非常简单，直接下载 Cycript，并进入 Cycript 目录下，执行：</p><p><code>./cycript -r 192.168.10.111:6666</code></p><p>192.168.10.111:6666 是手机ip地址，6666是默认的端口。这时控制台会有：cy#。</p><ul><li>1.当前页面对应的是哪个 VC?</li></ul><p>获取当前页面是哪个页面时，可以用到响应链的知识。假如SubjectViewController有一个 UITableView， 它的内存地址是 0x106a05c00 ，那么我可以通过下列命令找到当前的VC。</p><pre><code>cy# [#0x106a05c00 nextResponder]#&quot;&lt;UIView: 0x105d839d0; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x1c0635460&gt;&gt;&quot;cy# [#0x105d839d0 nextResponder]#&quot;&lt;SubjectViewController: 0x106a0a200&gt;&quot;</code></pre><ul><li>2.某个实例执行某个函数后的效果？</li></ul><p>SubjectViewController 的内存地址是 0x106a0a200，直接执行下面的这条指令，SubjectViewController 的标题会离开变为 Lefe_x。</p><p><code>cy# [#0x106a0a200 setTitle: @&quot;Lefe_x&quot;]</code></p><ul><li>3.打印当前的视图层级</li></ul><p>直接执行下列指令即可。</p><p><code>[[UIApp keyWindow]recursiveDescription].toString()</code></p><p><a href="http://www.cycript.org/" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决 WKWebView 无法处理 URL Scheme 和 App Store 链接的问题</title>
      <link href="/2018/03/01/2018/3/jie-jue-wkwebview-wu-fa-chu-li-url-scheme-he-app-store-lian-jie-de-wen-ti/"/>
      <url>/2018/03/01/2018/3/jie-jue-wkwebview-wu-fa-chu-li-url-scheme-he-app-store-lian-jie-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="解决-WKWebView-无法处理-URL-Scheme-和-App-Store-链接的问题"><a href="#解决-WKWebView-无法处理-URL-Scheme-和-App-Store-链接的问题" class="headerlink" title="解决 WKWebView 无法处理 URL Scheme 和 App Store 链接的问题"></a>解决 WKWebView 无法处理 URL Scheme 和 App Store 链接的问题</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>之前使用 <code>UIWebView</code> 时，当遇到 <code>App Store</code> 下载链接（例如： <code>https://itunes.apple.com/cn/app/id414478124?mt=8</code>），点击可以自动打开 <code>iPhone</code> 本地 <code>App Store</code> 并跳转到相应 <code>App</code> 的下载页面，</p><p>但是当换成 <code>WKWebView</code> 时，我们发现点击 <code>App Store Links</code> 时，有时候无反应，有时则会打开相应 <code>App</code> 的 <code>App Store Web</code> 页面，而不会直接调起本地 <code>App Store</code>。</p><p>另外，对于自定义的 <code>URL Scheme</code> 类型链接，在 <code>WKWebView</code> 里直接点击则会报错：<code>Error Domain=NSURLErrorDomain Code=-1002 &quot;unsupported URL&quot;</code></p><p>所以我们需要在 <code>WKWebView</code> 即将加载某一 URL 时，对这两种情况做一下处理，修改 <code>WKWebView</code> 的 <code>delegate</code> 中的 <code>webView:decidePolicyForNavigationAction:decisionHandler:</code> 方法，当遇到上述两种链接时，我们交给系统的 <code>[[UIApplication sharedApplication] openURL:xxx]</code> 来处理即可，代码如下：</p><pre class=" language-objc"><code class="language-objc">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {    NSURL *url = navigationAction.request.URL;    NSString *urlString = (url) ? url.absoluteString : @"";    // iTunes: App Store link    // 例如，微信的下载链接: https://itunes.apple.com/cn/app/id414478124?mt=8    if ([urlString containsString:@"//itunes.apple.com/"]) {        [[UIApplication sharedApplication] openURL:url];        decisionHandler(WKNavigationActionPolicyCancel);        return;    }    // Protocol/URL-Scheme without http(s)    else if (url.scheme && ![url.scheme hasPrefix:@"http"]) {        [[UIApplication sharedApplication] openURL:url];        decisionHandler(WKNavigationActionPolicyCancel);        return;    }    decisionHandler(WKNavigationActionPolicyAllow);}</code></pre><p>关于使用 <code>WKWebView</code> 的更多 <code>Tips</code>，可以参考 <code>https://github.com/ShingoFukuyama/WKWebViewTips</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>断案高手之otool</title>
      <link href="/2018/03/01/2018/3/duan-an-gao-shou-zhi-otool/"/>
      <url>/2018/03/01/2018/3/duan-an-gao-shou-zhi-otool/</url>
      
        <content type="html"><![CDATA[<h2 id="断案高手之otool"><a href="#断案高手之otool" class="headerlink" title="断案高手之otool"></a>断案高手之otool</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>前段时间一个朋友遇到了一个问题：每次打包的时候都会把某个方法注释掉，但为什么这次打包出来的效果却不对呢？按照他的思路想来的确百思不解，但秉着“世上没有无缘无故的恨”的原则，我还是想帮他解决一下疑问，我看了他的代码，并没有打 <code>Tag</code>，也没有环境区分（ <code>DEBUG</code> 和 <code>RELEASE</code> 区分）😂，就只能用 <code>otool</code> 来试试，方法如下：打开 <code>.ipa</code> 文件的 <code>Unix</code> 可执行文件，如下图：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/7-1.jpg?raw=true" alt></p><p>然后在 <code>Terminal</code> 中输入 <code>otool</code> 的命令，就可以打印出使用了哪些方法，如下图：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/7-2.jpg?raw=true" alt></p><p>这只是 <code>otool</code> 的一个小用法，这个工具很强大，感兴趣的小伙伴们可以深入了解一下。</p><p>不过从这个事情中可以看出来，人的记忆是不可靠的，规范项目才是王道！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查看.a静态库中的.o文件及函数接口信息</title>
      <link href="/2018/03/01/2018/3/cha-kan.a-jing-tai-ku-zhong-de.o-wen-jian-ji-han-shu-jie-kou-xin-xi/"/>
      <url>/2018/03/01/2018/3/cha-kan.a-jing-tai-ku-zhong-de.o-wen-jian-ji-han-shu-jie-kou-xin-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="查看-a静态库中的-o文件及函数接口信息"><a href="#查看-a静态库中的-o文件及函数接口信息" class="headerlink" title="查看.a静态库中的.o文件及函数接口信息"></a>查看.a静态库中的.o文件及函数接口信息</h2><p><strong>作者</strong>: <a href="https://weibo.com/touristdiary" target="_blank" rel="noopener">南峰子_老驴</a></p><p>如果想查看.a静态库中的.o文件及函数接口信息，可以尝试下 nm 命令。在 man page 中查看这个命令的信息，截取一段来看，如图1所示：</p><blockquote><p>Nm displays the name list (symbol table) of each object file in the argument list. If an argument is an archive, a listing for each object file in the archive will be produced. File can be of the form libx.a(x.o), in which case only symbols from that member of the object file are listed. (The parentheses have to be quoted to get by the shell.)  If no file is given, the symbols in a.out are listed.</p></blockquote><p>我们来看看实际效果，以微信的 libWeChatSDK.a 为例，使用如下命令：</p><p>nm -m /Users/**/Desktop/libWeChatSDK.a</p><p>实际的部分输出如图2所示</p><pre class=" language-objc"><code class="language-objc">                  ......                   (undefined) external _sqlite3_free                 (undefined) external _sqlite3_open                 (undefined) external _sqlite3_prepare_v2                 (undefined) external _sqlite3_reset                 (undefined) external _sqlite3_step/Users/**/Desktop/libWeChatSDK.a(OpenUDID.o):---------------- (LTO,CODE) non-external +[WXOMTAOpenUDID _generateFreshOpenUDID]---------------- (LTO,CODE) non-external +[WXOMTAOpenUDID _getDictFromPasteboard:]---------------- (LTO,CODE) non-external +[WXOMTAOpenUDID _setDict:forPasteboard:]---------------- (LTO,CODE) non-external +[WXOMTAOpenUDID setOptOut:]---------------- (LTO,CODE) non-external +[WXOMTAOpenUDID valueWithError:]---------------- (LTO,CODE) non-external +[WXOMTAOpenUDID value]                 (undefined) external _CC_MD5                 (undefined) external _CFRelease                 (undefined) external _CFStringGetCStringPtr                 (undefined) external _CFStringGetFastestEncoding                 (undefined) external _CFUUIDCreate                 (undefined) external _CFUUIDCreateString                 (undefined) external _OBJC_CLASS_$_NSDate                 (undefined) external _OBJC_CLASS_$_NSDictionary                 ......</code></pre><p>大家可以试试效果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>换一种 Hook 的姿势</title>
      <link href="/2018/03/01/2018/3/huan-yi-chong-hook-de-zi-shi/"/>
      <url>/2018/03/01/2018/3/huan-yi-chong-hook-de-zi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="换一种-Hook-的姿势"><a href="#换一种-Hook-的姿势" class="headerlink" title="换一种 Hook 的姿势"></a>换一种 Hook 的姿势</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>开发过程中，有时为了满足需求，通常会 <code>Hook</code> 系统或第三方库的一些方法。每次写一长串模版代码，是不是很痛苦？</p><p>其实可以换一种 <code>Hook</code> 的姿势 —— 使用 <code>CaptainHook</code> 库。它非常友好地提供一些宏来 <code>Hook</code> 某些方法。其实在逆向中，开发者通常使用这个库来 <code>Hook</code> 一些方法来达到目的。比如使用 <code>class-dump</code> 导出某个项目的头文件，然后替换掉需要 <code>Hook</code> 的方法。</p><p>简单举个例子：</p><p>替换掉 <code>HookObject</code> 类中的 <code>hookMe</code> 和 <code>userName</code> 方法。</p><pre><code>// 声明要 Hook 的类，HookObject 是已经声明的一个类CHDeclareClass(HookObject);// Hook 无返回值，无参数的方法CHMethod0(void, HookObject, hookMe){    NSLog(@&quot;I am a hook method: hookMe&quot;);    CHSuper0(HookObject, hookMe);}// Hook 有返回值，无参数的方法CHMethod0(NSString *, HookObject, userName){    NSLog(@&quot;I am a hook method: userName&quot;);    return CHSuper0(HookObject, userName);}// 构造 Hook 的类CHConstructor{    CHLoadClass(HookObject);    CHHook0(HookObject, hookMe);    CHHook0(HookObject, userName);}</code></pre><p>参考：<a href="https://github.com/rpetrich/CaptainHook/wiki" target="_blank" rel="noopener">CaptainHook</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>打包时 Xcode 无法及时更新 Provisioning Profile 的解决办法</title>
      <link href="/2018/03/01/2018/3/da-bao-shi-xcode-wu-fa-ji-shi-geng-xin-provisioning-profile-de-jie-jue-ban-fa/"/>
      <url>/2018/03/01/2018/3/da-bao-shi-xcode-wu-fa-ji-shi-geng-xin-provisioning-profile-de-jie-jue-ban-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="打包时-Xcode-无法及时更新-Provisioning-Profile-的解决办法"><a href="#打包时-Xcode-无法及时更新-Provisioning-Profile-的解决办法" class="headerlink" title="打包时 Xcode 无法及时更新 Provisioning Profile 的解决办法"></a>打包时 Xcode 无法及时更新 Provisioning Profile 的解决办法</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>我们在苹果开发者中心新添加一台测试设备的 <code>UDID</code> 之后，紧接着打出一份 <code>Adhoc</code> 包，却发现新添加的设备还是无法安装。这是因为 <code>Xcode</code> 没有及时更新云端的 <code>Provisioning Profile</code>。这时可以清除本地目录 <code>~/Library/MobileDevice/Provisioning</code> 下的所有内容，然后打包时勾选 <code>Automatically manage signing</code> 选项，<code>Xcode</code> 会自动下载云端的最新 <code>Provisioning Profile</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>应用 icon 被 Cocoapods “吃掉”的解决方式</title>
      <link href="/2018/03/01/2018/3/ying-yong-icon-bei-cocoapods-chi-diao-de-jie-jue-fang-shi/"/>
      <url>/2018/03/01/2018/3/ying-yong-icon-bei-cocoapods-chi-diao-de-jie-jue-fang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="应用-icon-被-Cocoapods-“吃掉”的解决方式"><a href="#应用-icon-被-Cocoapods-“吃掉”的解决方式" class="headerlink" title="应用 icon 被 Cocoapods “吃掉”的解决方式"></a>应用 icon 被 Cocoapods “吃掉”的解决方式</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>最近在做模块化相关的事情，和 <code>Cocoapods</code> 频繁接触，也踩了一些坑，今天主要分享一下最近遇到的一个 <code>bug</code>。</p><p>做模块化的时候，不同模块会有一个自己独立的 <code>repo</code>，然后有自己的各种资源，我们采取的方式是将图片放到 <code>.xcassets</code> 文件夹中，然后打到 <code>bundle</code> 当中，大概方式如图：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/3-1.jpg?raw=true" alt></p><p>放到 <code>bundle</code> 的 <code>.xcassets</code> 是为了防止图片和主工程或者其它模块中图片重名</p><p><code>run</code> 起来，一切图片等资源读取非常正常（资源的读取感觉后面有机会再写一篇文章单独介绍了），但是当我们 <code>Home</code> 出去的时候，发现应用的 <code>icon</code> 没了，变成了默认的那种空白图标😂，WTF！</p><p>果断到 <code>CocoaPods</code> 官方 <code>repo</code> 中寻求一波援助，发现有人提了类似的 <a href="https://github.com/CocoaPods/CocoaPods/issues/7003" target="_blank" rel="noopener">issue</a> 有人提出了一种解决方案，亲测可行。</p><p>原因是 <code>Xcode</code> 在 <code>&quot;Copy Bundle Resources&quot;</code> 阶段编译 <code>.xcassets</code> 加了 <code>--app-icon</code> 参数，而 <code>&quot;[CP] Copy Pods Resources&quot;</code> 阶段没有加这个参数，而且覆盖了编译出来的 <code>Assets.car</code>。解决方式就是在第一步加上这个参数。解决方式如下图，在 <code>podfile</code> 中加入参考链接中的脚本内容。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/3-2.jpg?raw=true" alt></p><p>还有一种解决方案就是把图片全部放到 <code>bundle</code>，不放在 <code>.xcassets</code> 的形式，也是亲测可行。但是这种方式不太优雅，因为可能导致图片重名，读取错误。</p><p>参考：</p><ol><li><a href="https://github.com/CocoaPods/CocoaPods/issues/7003#issuecomment-328045681" target="_blank" rel="noopener">issue 解决方案</a></li><li><a href="http://zhoulingyu.com/2018/02/02/pod-resource-reference/" target="_blank" rel="noopener">resource_bundles or resources</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用 Git-hook 自动配置不同仓库的用户信息</title>
      <link href="/2018/03/01/2018/3/li-yong-git-hook-zi-dong-pei-zhi-bu-tong-cang-ku-de-yong-hu-xin-xi/"/>
      <url>/2018/03/01/2018/3/li-yong-git-hook-zi-dong-pei-zhi-bu-tong-cang-ku-de-yong-hu-xin-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="利用-Git-hook-自动配置不同仓库的用户信息"><a href="#利用-Git-hook-自动配置不同仓库的用户信息" class="headerlink" title="利用 Git-hook 自动配置不同仓库的用户信息"></a>利用 Git-hook 自动配置不同仓库的用户信息</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><blockquote><p>问题的起因来自于某天一位同学的问题：“我给一个知名开源项目提交了代码，也被合并了，为什么 <code>contributors</code> 里面没有我？”其实，这多是因为提交代码时本地仓库的<code>user.name</code>、<code>user.email</code>与GitHub账号不匹配导致，只有提交代码时的用户设置与自己的 <code>GitHub</code> 账号相匹配时，各项数据才会被 <code>GitHub</code> 计入统计。如下图所示，这样的 <code>commit</code> 记录便来自于一个用户设置和我 <code>GitHub</code> 账号不匹配的本地仓库。</p></blockquote><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/4-1.jpg?raw=true" alt="图1"></p><p>如果你不仅使用 <code>GitHub</code> ，还会向公司自建的 <code>GitLab</code> ，以及 <code>oschina</code> 、<code>coding.net</code> 等基于 <code>Git</code> 的托管服务商提交代码，那么便会面临这个问题：你需要为不同来源的 <code>Git</code> 仓库一一配置用户名与邮箱信息，来避免上述的不同步情况。然而，手动在每个本地仓库路径下都使用 <code>git config user.name</code> 和 <code>git config user.email</code> 命令，难免会有忘记的情况，也过于繁琐。所以，我们可以使用<strong>Git初始模板、钩子函数</strong>的特性，达到在<strong>每次clone一个新的仓库时，根据仓库来源域名的不同，自动配置不同的用户信息</strong>。</p><ul><li><p>首先，在命令行使用该命令建立一个新的文件夹：<code>mkdir -p ~/.git-templates/hooks</code></p></li><li><p>然后配置git，让git知道这个文件夹是你的模板文件夹：<code>git config --global init.templatedir ~/.git-templates</code></p></li><li><p>接下来，在这个文件夹中新建钩子文件：<code>vi ~/.git-templates/hooks/post-checkout</code></p><p>钩子文件的内容较长，可在文末附带的链接中查看复制即可，完成之后赋予这个文件可执行权限：<code>chmod +x ~/.git-templates/hooks/post-checkout</code></p></li><li><p>最后，新建一个文件：<code>vi ~/.git-clone-init</code></p><p>最后一个文件是唯一一个内容需要自己配置的文件，也是整个过程的关键，内容格式如图2，意为对应不同域名下的仓库，自动配置不同的<code>user.name</code>和<code>user.email</code>。</p></li></ul><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/4-2.jpg?raw=true" alt="图2"></p><p><strong>整个过程的原理就是我们在执行克隆操作时，git会执行初始模板里的钩子文件，钩子文件根据git-clone-init文件定义的规则，自动配置用户名与邮箱信息。这套流程来自于一个GitHub开源库，目前star还很少，大家可以去支持一下~</strong></p><p>参考：</p><ol><li><a href="https://github.com/DrVanScott/git-clone-init" target="_blank" rel="noopener">DrVanScott/git-clone-init</a></li><li><a href="https://segmentfault.com/a/1190000013283182" target="_blank" rel="noopener">让你的git拥有不同身份</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>再谈 timer 之 CFRunLoopTimerRef</title>
      <link href="/2018/03/01/2018/3/zai-tan-timer-zhi-cfrunlooptimerref/"/>
      <url>/2018/03/01/2018/3/zai-tan-timer-zhi-cfrunlooptimerref/</url>
      
        <content type="html"><![CDATA[<h2 id="再谈-timer-之-CFRunLoopTimerRef"><a href="#再谈-timer-之-CFRunLoopTimerRef" class="headerlink" title="再谈 timer 之 CFRunLoopTimerRef"></a>再谈 timer 之 CFRunLoopTimerRef</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>阅读本小集可以参考以前的一篇小集「 定时器引发的思考 」</p><p>学习 <code>RunLoop</code> 的知识时如果有一些使用场景，我想对理解 <code>RunLoop</code> 有很大帮助。而 <code>timer</code> 和 <code>RunLoop</code> 息息相关。没有 <code>RunLoop</code> ，<code>timer</code> 不会跑起来。也就是说如果不把 <code>timer</code> 添加到 <code>RunLoop</code> 中，<code>timer</code> 就不会被执行。而且 <code>RunLoop</code> 和线程是一一对应的，如果非主线程的情况下，只有运行 <code>RunLoop</code> 时它才会创建 <code>RunLoop</code>。</p><p>在非主线程中创建一个定时器:</p><pre class=" language-objc"><code class="language-objc">[self performSelectorInBackground:@selector(createTimerInOtherThread) withObject:nil];</code></pre><p>由于函数 <code>createTimerInOtherThread</code> 不在主线程执行，那么可以使用 <code>[NSThread currentThread]</code> 获取当前的线程，使用 <code>CFRunLoopGetCurrent()</code> 获取当前的 <code>RunLoop</code>。由于只有主线程的 <code>RunLoop</code> 才会开启，而其他线程的 <code>RunLoop</code> 需要通过 <code>CFRunLoopRun()</code> 手动开启。</p><p>注意这里发现一个诡异的问题。执行 <code>CFRunLoopRun()</code> 后，它后面的代码将在 <code>RunLoop</code> 停止后执行，这是因为 <code>RunLoop</code> 相当于一个循环，循环结束后它后面的代码才会执行。</p><pre class=" language-objc"><code class="language-objc">- (void)createTimerInOtherThread{    CFAllocatorRef allocator = kCFAllocatorDefault;    CFAbsoluteTime fireDate = CFAbsoluteTimeGetCurrent();    CFTimeInterval interval = 2.0;    CFOptionFlags flag = 0;    CFIndex index = 0;    // 定时器的回调    CFRunLoopTimerCallBack callback = lefexTimerAction;    // 定时器上下文    CFRunLoopTimerContext context = {0, (__bridge void *)(self), NULL, NULL, NULL};    // 创建定时器    CFRunLoopTimerRef timer = CFRunLoopTimerCreate(allocator, fireDate, interval, flag, index, callback, &context);    // 获取当前线程的 runlopp，并且开启 runLoop 定时器才能正常执行    threadRunloop = CFRunLoopGetCurrent();    currentThread = [NSThread currentThread];    // 把timer添加到runloop中，timer将会跑起来    CFRunLoopAddTimer(threadRunloop, timer, kCFRunLoopCommonModes);    // 在 run 之后的代码将不会执行    CFRunLoopRun();    // 下面这行打印将在停止 runLoop 后执行。    NSLog(@"runLoop stop");}</code></pre><p>定时器跑起来后，它的回调函数将被执行，回调函数将在它所在的 <code>RunLoop</code> 对应的线程中执行。如果 <code>timer</code> 被添加到 <code>mainRunLoop</code> 回调函数在主线程中执行。</p><pre class=" language-objc"><code class="language-objc">void lefexTimerAction(CFRunLoopTimerRef timer, void *info){    NSLog(@"timer called on thread: %@", [NSThread currentThread]);}</code></pre><p>当不在使用 <code>timer</code> 时需要释放掉 <code>timer</code>，而其实也可以直接停止 <code>RunLoop</code> 的运行 （通过 <code>CFRunLoopStop(threadRunLoop)</code>），<code>timer</code> 也会停止。</p><pre class=" language-objc"><code class="language-objc">- (void)invalidTimer:(CFRunLoopTimerRef)timer{  if (timer) {    CFRunLoopTimerInvalidate(timer);    CFRelease(timer);    timer = 0;  }  if (threadRunloop) {  // 如果不暂停 runLoop，当前对象不会释放  CFRunLoopStop(threadRunloop);  threadRunLoop = NULL;}}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 LLDB expression 命令调试动态更新 UI</title>
      <link href="/2018/03/01/2018/3/shi-yong-lldb-expression-ming-ling-diao-shi-dong-tai-geng-xin-ui/"/>
      <url>/2018/03/01/2018/3/shi-yong-lldb-expression-ming-ling-diao-shi-dong-tai-geng-xin-ui/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-LLDB-expression-命令调试动态更新-UI"><a href="#使用-LLDB-expression-命令调试动态更新-UI" class="headerlink" title="使用 LLDB expression 命令调试动态更新 UI"></a>使用 LLDB expression 命令调试动态更新 UI</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>在日常 App 开发过程中，进行真机或者模拟器调试时，我们可能需要微调一下界面上的 UI 元素，比如色值、位置等来看看效果，但如果每次都通过修改代码，然后重新编译运行会比较麻烦，其实我们可以通过 LLDB 调试命令来动态地修改。</p><p>LLDB 的 <code>expression</code> 命令用于执行一个表达式，并将表达式返回的结果输出。</p><p>我们在 App 运行后，点击 Xcode 调试工具栏的“暂停”按钮，进入命令行调试模式，如图：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/10-1.png?raw=true" alt></p><p>然后输入如下命令：</p><pre><code>po [[[UIApplication sharedApplication] keyWindow] recursiveDescription]</code></pre><p>此时可以看到控制台中输出整个 UI 层级，及每个 UI 元素对象在内存中的地址，如下所示：</p><pre><code>po [[[UIApplication sharedApplication] keyWindow] recursiveDescription]&lt;UIWindow: 0x7fd94a616c50; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x60c00025b120&gt;; layer = &lt;UIWindowLayer: 0x60c00003f7c0&gt;&gt;   | &lt;UIView: 0x7fd94a701f90; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x60400003b820&gt;&gt;   |    | &lt;UIView: 0x7fd94a709640; frame = (30 30; 315 120); autoresize = RM+BM; layer = &lt;CALayer: 0x60400003b860&gt;&gt;   |    | &lt;UIView: 0x7fd94a709a30; frame = (30 180; 315 120); autoresize = RM+BM; layer = &lt;CALayer: 0x60400003bac0&gt;&gt;</code></pre><p>通过上述输出，我们可以根据内存地址取出某一 UI 元素：</p><pre><code>expression -- id $testView = (id)0x7fd94a709640</code></pre><p>然后，修改这个 UI 元素的相关属性：</p><pre><code>expression -- (void)[$testView setBackgroundColor:[UIColor redColor]]</code></pre><p>最后，通过下面命令刷新屏幕，你就可以看到 App 中的对应元素发生变化了：</p><pre><code>expression -- (void)[CATransaction flush]</code></pre><p>上面只是个例子，其实这个命令不限于说刷新 UI，你甚至可以通过它 Push 打开一个新页面，它相当于可以直接在命令行中执行代码。</p><p>另外，我们平时用的 <code>p</code> 和 <code>po</code> 两个命令，其实也是 <code>expression</code> 命令的别名，</p><p><code>p</code> 命令等价于 <code>expression  --</code> ；<br><code>po</code> 命令等价于 <code>expression -O --</code> ；</p><p>关于 expression 命令的更多使用方式，可通过 <code>help expression</code> 获取查看。</p><p>参考链接：<a href="https://segmentfault.com/a/1190000002413758" target="_blank" rel="noopener">iOS/OSX 调试：跳舞吧！与LLDB共舞华尔兹</a></p><p>写完这个小集后，无意看到 Mac 的 Dock 栏上的 Reveal 应用图标，心想费这些周折干嘛，我为啥不用 Reveal 这个强大的 UI 调试工具来完成这件事请呢？sad…</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 Apple Configuration 配置自动加入 Wi-Fi</title>
      <link href="/2018/03/01/2018/3/shi-yong-apple-configuration-pei-zhi-zi-dong-jia-ru-wi-fi/"/>
      <url>/2018/03/01/2018/3/shi-yong-apple-configuration-pei-zhi-zi-dong-jia-ru-wi-fi/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Apple-Configuration-配置自动加入-Wi-Fi"><a href="#使用-Apple-Configuration-配置自动加入-Wi-Fi" class="headerlink" title="使用 Apple Configuration 配置自动加入 Wi-Fi"></a>使用 Apple Configuration 配置自动加入 Wi-Fi</h2><p><strong>作者</strong>: <a href="https://weibo.com/touristdiary" target="_blank" rel="noopener">南峰子_老驴</a></p><p>通常我们的 <code>iPhone</code> 手机都会自动连接已经记住的 <code>Wi-Fi</code> 网络，对于一些企业级的 <code>WPA/WPA 2</code> 网络，如果不能自动加入的话，我们可以自己配置一个 <code>Wi-Fi</code> 描述文件来做自动加入。</p><p>我们可以使用 “<code>Apple Configuration</code>” 或者 “描述文件管理器” 来生成配置文件，如下图是使用 “<code>Apple Configuration</code>” 来配置（文件 -&gt; 新建配置文件），当然我们需要知道 <code>Wi-Fi</code> 实际的配置，比如网络协议接受的 <code>EAP</code> 类型。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/8-1.png?raw=true" alt></p><p>配置完成后保存成一个 <code>.mobileconfig</code> 文件，这实际上是一个 <code>xml</code> 文件，内容如下图所示。因此，我们实际上是可以通过代码的形式来生成这个文件。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/8-2.png?raw=true" alt></p><p>生成的 <code>.mobileconfig</code> 文件可以使用 “<code>Apple Configuration</code>” 导入到手机里面，如下图所示。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/8-3.png?raw=true" alt></p><p>剩下的就是在手机上正常安装描述文件的流程，需要进到 “设置 -&gt; 通用 -&gt; 描述文件” 里面安装这个描述文件。安装完成后，就可以自动连接 <code>Wi-Fi</code> 了。</p><p>需要注意的几个问题：</p><ol><li>如果想输入密码，可以勾选“使用单次连接密码”，不过这个选项不能和“自动加入”同时使用；如果两个都勾选会默认使用“使用单次连接密码”；</li><li>可以对配置文件做签名，但如果签名后，文件将不能再做修改；同时保存的文件内容变成16进制数据，所以也不能像修改 <code>xml</code> 文件那样手动修改文件；</li><li>未签名的 <code>xml</code> 文件，是以明文的形式保存密码；</li><li>如果需要证书认证，则要将相应的证书配置到描述文件中；</li><li>在线安装描述文件的方式仅限于 <code>Safari</code>、<code>Mail</code>；</li><li>使用 <code>portal</code> 方式认证的登录木有验证过；</li></ol><p>参考：</p><p><a href="https://support.apple.com/zh-cn/HT202343" target="_blank" rel="noopener">关于“自动加入”和单一连接密码 Wi-Fi 描述文件设置</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>三个打印类信息的私有方法</title>
      <link href="/2018/03/01/2018/3/san-ge-da-yin-lei-xin-xi-de-si-you-fang-fa/"/>
      <url>/2018/03/01/2018/3/san-ge-da-yin-lei-xin-xi-de-si-you-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="三个打印类信息的私有方法"><a href="#三个打印类信息的私有方法" class="headerlink" title="三个打印类信息的私有方法"></a>三个打印类信息的私有方法</h2><p><strong>作者</strong>: <a href="https://weibo.com/touristdiary" target="_blank" rel="noopener">南峰子_老驴</a></p><p>想在 <code>NSLog</code> 打印变量的类型信息，无意中找到了看到 <code>Extended Type Info in Objective-C</code> 这篇文章，发现了 <code>NSObject</code> 的打印类相关信息的三个私有方法，分享一下：</p><ol><li><code>_methodDescription/_shortMethodDescription</code>：打印接收者的所有实例方法和类方法，包括私有方法；</li><li><code>_ivarDescription</code>：打印接收者的成员变量，包括类型和值；</li></ol><p>我们可以如下使用这几个方法：</p><pre class=" language-objc"><code class="language-objc">UIView *view = [[UIView alloc] init];NSLog(@"%@", [view performSelector:@selector(_ivarDescription)]);</code></pre><p>打印的信息如下所示。</p><pre><code>&lt;UIView: 0x7fa18a7022d0&gt;:in UIView:    _constraintsExceptingSubviewAutoresizingConstraints (NSMutableArray*): nil    _cachedTraitCollection (UITraitCollection*): nil    _layer (CALayer*): &lt;CALayer: 0x604000222ac0&gt;    _layerRetained (CALayer*): &lt;CALayer: 0x604000222ac0&gt;    _enabledGestures (int): 0    _gestureRecognizers (NSMutableArray*): nil    _window (UIWindow*): nil    _subviewCache (NSArray*): nil    _templateLayoutView (UIView*): nil    _charge (float): 0    _tag (long): 0    _viewDelegate (UIViewController*): nil    _backgroundColorSystemColorName (NSString*): nil    _countOfMotionEffectsInSubtree (unsigned long): 0    _unsatisfiableConstraintsLoggingSuspensionCount (unsigned long): 0    _countOfTraitChangeRespondersInDirectSubtree (unsigned long): 1    _cachedScreenScale (double): 0    _viewFlags (struct ?): {        userInteractionDisabled (b1): NO        implementsDrawRect (b1): NO        implementsDidScroll (b1): NO        implementsMouseTracking (b1): NO        implementsIntrinsicContentSize (b1): NO        hasBackgroundColor (b1): NO        ......</code></pre><p>如果对这些信息感兴趣，可以重写类的 <code>debugDescription()</code> 方法，在这个方法里面调用上面几个方法。</p><p>需要注意一个问题：这些方法在是 <code>iOS 7+</code> 中，在 <code>UIKit</code> 里面实现的，所以在 <code>Mac OS</code> 中用不了，可以尝试建一个控制台程序，看看结果。</p><p>参考：<a href="http://bou.io/ExtendedTypeInfoInObjC.html" target="_blank" rel="noopener">Extended Type Info in Objective-C</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>“偷窥”第三方APP头文件</title>
      <link href="/2018/03/01/2018/3/tou-kui-di-san-fang-app-tou-wen-jian/"/>
      <url>/2018/03/01/2018/3/tou-kui-di-san-fang-app-tou-wen-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="“偷窥”第三方APP头文件"><a href="#“偷窥”第三方APP头文件" class="headerlink" title="“偷窥”第三方APP头文件"></a>“偷窥”第三方APP头文件</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>有时候在开发的过程中需要些黑科技，“偷窥”第三方 APP 使用了哪些第三方库，或猜猜它是如何实现的，咋么办？</p><p>其实我们可以使用 <code>class-dump</code> 这个工具查看某个 APP 的头文件。只需要找到第三方 APP 的 <code>xxx.app</code> 文件，然后执行 <code>class-dump</code> 命令即可。不过在执行 <code>class-dump</code> 命令前，需要确保 <code>xxx.app</code> 是砸过壳的，从 <code>APPStore</code> 下载的 <code>xxx.app</code> 文件是经过加密处理的，可以直接从各大越狱市场上下载第三方 <code>xxx.app</code> 文件，从越狱市场下载的 <code>xxx.app</code> 已被破解。可以直接使用 <code>class-dump</code> 导出头文件。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>网上很多教程，不啰嗦了哈。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>创建一个 <code>Demo</code>，然后打包导出 <code>ipa</code> 包，找到 <code>xxx.app</code>，这里 <code>xxx.app</code> 是未经过加密的。具体代码如下：</p><pre class=" language-objc"><code class="language-objc">@protocol ViewControllerDelegate<NSObject>- (void)didRefreshDataSuccess;@end@interface ViewController : UIViewController@property (nonatomic, weak) id<ViewControllerDelegate> delegate;@property (nonatomic, copy) NSString *pubName;- (void)pubLoadDataWithAlbumID:(NSString *)albumID count:(NSString *)count;@end@interface ViewController1 (Navigation)- (void)setRightBarItemWithTitle:(NSString *)title;@end</code></pre><p>执行 <code>class-dump</code> 命令：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">class</span><span class="token operator">-</span>dump <span class="token operator">-</span><span class="token constant">H</span> <span class="token punctuation">[</span>xxx<span class="token punctuation">.</span>app所在的位置<span class="token punctuation">]</span> <span class="token operator">-</span>o <span class="token punctuation">[</span>头文件导出的位置<span class="token punctuation">]</span></code></pre><p>比如：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">class</span><span class="token operator">-</span>dump <span class="token operator">-</span><span class="token constant">H</span> <span class="token constant">Lefex</span><span class="token punctuation">.</span>app <span class="token operator">-</span>o lefexheader</code></pre><p>最终导出的头文件如下：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/9-1.jpg?raw=true" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用 <code>class-dump</code> 导出头文件有以下特点：</p><ol><li>不管 <code>.h</code> 还是 <code>.m</code> 文件中的属性和方法都会被导出；</li><li>某个类的类别中的方法也会被导出，导出到源文件中，比如 <code>ViewController (Navigation)</code> 中的方法被导出到 <code>ViewController</code> 中；</li><li>实现的协议也会被导出，比如 <code>ViewControllerDelegate</code> 的方法被导出到 <code>ViewController</code> 中，如果 <code>ViewController</code> 不实现 <code>ViewControllerDelegate</code> 协议讲不会被导出；</li><li>协议中定义的方法不会被导出，只会导出到实现协议的类中；</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="noopener">Class-dump</a></p><p>可以参考这个 <a href="https://weibo.com/everettjf?from=usercardnew&amp;refer_flag=0000020001_" target="_blank" rel="noopener">@everettjf</a>  <a href="http://everettjf.com/2016/07/09/classify-class-dump-headers-tool/" target="_blank" rel="noopener">http://everettjf.com/2016/07/09/classify-class-dump-headers-tool/</a> ，话说可以导出头文件并找出使用的第三方库。不过我试了下没安装成功就没深究，有兴趣的朋友可以看看。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>podspec 中预编译宏的使用</title>
      <link href="/2018/03/01/2018/3/podspec-zhong-yu-bian-yi-hong-de-shi-yong/"/>
      <url>/2018/03/01/2018/3/podspec-zhong-yu-bian-yi-hong-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="podspec-中预编译宏的使用"><a href="#podspec-中预编译宏的使用" class="headerlink" title="podspec 中预编译宏的使用"></a>podspec 中预编译宏的使用</h1><hr><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>相信大家在写一个独立的组件的时候可能都会遇到一个问题，写了一个大而全的库发布到 Cocoapods 上，但是接入者可能只想使用其中几个功能，但是却不得不引入所有代码，有点伤。那有没有对应的解决方案呢？答案是肯定的，就是使用 Cocoapods 中提供的 GCC_PREPROCESSOR_DEFINITIONS。这个是从 SDWebImage 中学到的。</p><p>SD 有一个功能是使用 libwebp 来解码展示 WebP 图片。但是一般情况下，引入方是不需要这个功能的。所以作者巧妙的使用了如下方式，来实现 WebP 的引入。即</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true"># 省略了很多不是重点的代码，具体可以参考 SDWebImage</span>s<span class="token punctuation">.</span>subspec <span class="token string">'WebP'</span> <span class="token keyword">do</span> <span class="token operator">|</span>webp<span class="token operator">|</span>    webp<span class="token punctuation">.</span>xcconfig <span class="token operator">=</span> <span class="token punctuation">{</span>       <span class="token string">'GCC_PREPROCESSOR_DEFINITIONS'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'$(inherited) SD_WEBP=1'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>  <span class="token keyword">end</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS9 以后 openURL 和 canOpenURL 使用限制的小误区</title>
      <link href="/2018/03/01/2018/3/ios9-yi-hou-openurl-he-canopenurl-shi-yong-xian-zhi-de-xiao-wu-qu/"/>
      <url>/2018/03/01/2018/3/ios9-yi-hou-openurl-he-canopenurl-shi-yong-xian-zhi-de-xiao-wu-qu/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS9-以后-openURL-和-canOpenURL-使用限制的小误区"><a href="#iOS9-以后-openURL-和-canOpenURL-使用限制的小误区" class="headerlink" title="iOS9 以后 openURL 和 canOpenURL 使用限制的小误区"></a>iOS9 以后 openURL 和 canOpenURL 使用限制的小误区</h2><p><strong>作者</strong>: <a href="https://weibo.com/kangzubin" target="_blank" rel="noopener">KANGZUBIN</a></p><p>通常我们会用 <code>UIApplication</code> 的 <code>openURL:</code> 方法调起其他 App 来进行一些操作，如分享、第三方登录、支付等。但 <code>iOS9</code> 发布后，在看了很多适配总结的文章后，相信很多人可能跟我一样会有如下理解：</p><blockquote><p><code>iOS9</code> 限制了 <code>openURL:</code> 和 <code>canOpenURL:</code> 方法的使用，如果我们要调起第三方 App，需要在 <code>Info.plist</code> 的 <code>LSApplicationQueriesSchemes</code> Key 中添加相应 App 的 <code>Scheme</code> 才行，且添加的 <code>Scheme</code> 个数不能超过 <strong>50</strong> 个。</p></blockquote><p><strong>其实上面描述是有误的。</strong></p><p>举个例子，大部分 App 在接入微信的 <code>SDK</code> 后，会先在自己工程配置中的 <code>Info</code> -&gt; <code>URL Types</code> 添加注册一个 <code>Scheme</code>，叫 “wx+appId” ，以便在调起微信进行登录或分享后，微信回调返回到我们自己的 App 中。但是试想一下，如果 <code>openURL:</code> 使用必须事先声明且有个数的限制，那么微信如何回调成千上万的 App 呢，难道微信要在其工程的 <code>Info.plist</code> 中把这些第三方 App 的 <code>Scheme</code> 都添加进去，而且每天都会有新增的 App 接入了微信 <code>SDK</code>，如何动态更新添加 <code>Scheme</code> 呢？微信是有什么黑科技或者苹果给微信等大厂的超级 App 开了特殊通道？</p><p>在查阅了苹果官方文档后，我们发现其实并不是这样的，如下图：</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/6-1.png?raw=true" alt></p><blockquote><p><strong>！！！只有 <code>canOpenURL:</code> 方法的使用受 <code>Info.plist</code> 中声明的 <code>Scheme</code> 的限制，而 <code>openURL:</code> 方法是不受限制的，不需要事先声明，也没有个数限制。</strong>（其实在 <code>iOS9</code> 的某 Beta 版上，<code>openURL:</code> 也受同样限制，但苹果后面确认是 Bug，在正式版中已更正过来）</p></blockquote><p>另外关于 <code>canOpenURL:</code> 最多只能对 <strong>50</strong> 个 <code>Scheme</code> 做判断的说法也是错误的。苹果的正确描述是：<strong>“如果你的 App 是使用 <code>Xcode 7 (iOS9 SDK)</code> 之前版本编译的，但是在 <code>iOS9</code> 及以后的系统中运行，那么你的 App 最多只能调用 50 次 <code>canOpenURL:</code> 方法，超过 50 次后，该方法都会返回 <code>NO</code>。”</strong></p><p>如果我们使用最新版的 <code>Xcode</code> 编译 App，<code>canOpenURL:</code> 能判断的 <code>Scheme</code> 个数应该是不受限制的。</p><p>我写了一个 <code>Demo</code> 验证了以上说法，如下图所示，在 <code>Info.plist</code> 中我先添加了超过 100 个 <code>Scheme</code> 后再添加 “weixin”，仍可以通过 <code>canOpenURL:</code> 判断是否安装了微信，另外即使没有添加微博的 <code>Scheme</code> “sinaweibo” 也可以通过 <code>openURL:</code> 正常打开。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/6-2.png?raw=true" alt></p><p>Demo 地址：<a href="https://github.com/kangzubin/DevDemo/tree/master/TestOpenURL" target="_blank" rel="noopener">TestOpenURL</a></p><blockquote><p>虽然 <code>openURL:</code> 方法使用不受限制，但是苹果还是建议我们在使用它之前，先调 <code>canOpenURL:</code> 判断一下，再进行后续操作。</p></blockquote><p>以上测试结果是在真机 <strong><code>iPhone 8 (iOS 11.2.6)</code></strong> 上进行的，如果其他设备或者系统版本有差异，欢迎留言讨论。</p><p>参考链接：</p><ul><li><a href="https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc" target="_blank" rel="noopener">Apple Developer Documentation</a></li><li><a href="https://useyourloaf.com/blog/querying-url-schemes-with-canopenurl/" target="_blank" rel="noopener">Querying URL Schemes with canOpenURL</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pod 关于 unknown UUID 警告的解决方式</title>
      <link href="/2018/03/01/2018/3/pod-guan-yu-unknown-uuid-jing-gao-de-jie-jue-fang-shi/"/>
      <url>/2018/03/01/2018/3/pod-guan-yu-unknown-uuid-jing-gao-de-jie-jue-fang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="Pod-关于-unknown-UUID-警告的解决方式"><a href="#Pod-关于-unknown-UUID-警告的解决方式" class="headerlink" title="Pod 关于 unknown UUID 警告的解决方式"></a>Pod 关于 unknown UUID 警告的解决方式</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>最近某次在 <code>pod install</code> 之后会发现终端会输出类似下面的提示：</p><pre><code>[!] `&lt;PBXBuildFile UUID=`xxxxxxx`&gt;` attempted to initialize an object with an unknown UUID. `xxxxxxxx` for attribute: `file_ref`. This can be the result of a merge and  the unknown UUID is being discarded. </code></pre><p>一直很困惑。后面 Google 在 <code>CocoaPods repo</code> 下看到一个类似的 <code>issue</code>，原因是由于修改了 <code>pbxproj</code> 文件，但是没有把它提交到 <code>git</code> 当中，当其他人更新 <code>pod</code> 的时候就会提示这个。</p><p>解决方案就是使用下面这段命令 </p><pre><code>cat ProjectName.xcodeproj/project.pbxproj | grep SECOND_UDID_F34A6B992B28CA</code></pre><p>然后会输出对应的文件名，做对应的删除或添加操作即可。再执行 <code>pod install</code> 或 <code>update</code> 之后即可正常。</p><p>综合起来整个过程如下图所示</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/1-1.jpg?raw=true" alt></p><p>参考：<a href="https://github.com/CocoaPods/CocoaPods/issues/1822" target="_blank" rel="noopener">Pod install result in initialize an object with an unknown UUID</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 9 以后通知不再需要手动移除</title>
      <link href="/2018/03/01/2018/3/ios-9-yi-hou-tong-zhi-bu-zai-xu-yao-shou-dong-yi-chu/"/>
      <url>/2018/03/01/2018/3/ios-9-yi-hou-tong-zhi-bu-zai-xu-yao-shou-dong-yi-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-9-以后通知不再需要手动移除"><a href="#iOS-9-以后通知不再需要手动移除" class="headerlink" title="iOS 9 以后通知不再需要手动移除"></a>iOS 9 以后通知不再需要手动移除</h2><p><strong>作者</strong>: <a href="https://weibo.com/halohily" target="_blank" rel="noopener">halohily</a></p><p>通知 NSNotification 在注册者被回收时需要手动移除，是一直以来的使用准则。原因是在 MRC 时代，通知中心持有的是注册者的 unsafe_unretained 指针，在注册者被回收时若不对通知进行手动移除，则指针指向被回收的内存区域，成为野指针。这时再发送通知，便会造成 crash 。而在 iOS 9 以后，通知中心持有的是注册者的 weak 指针，这时即使不对通知进行手动移除，指针也会在注册者被回收后自动置空。我们知道，向空指针发送消息是不会有问题的。</p><p>但是有一个例外。如果用</p><p><code>- (id &lt;NSObject&gt;)addObserverForName:(nullable NSNotificationName)name object:(nullable id)obj queue:(nullable NSOperationQueue \*)queue usingBlock:(void (^)(NSNotification *note))block API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));</code></p><p>这个API来注册通知，可以直接传入 block 类型参数。使用这个API会导致注册者被系统 retain ，因此仍然需要像以前一样手动移除通知，同时这个 block 类型参数也需注意避免循环引用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C中自定义泛型类</title>
      <link href="/2018/03/01/2018/3/objective-c-zhong-zi-ding-yi-fan-xing-lei/"/>
      <url>/2018/03/01/2018/3/objective-c-zhong-zi-ding-yi-fan-xing-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="Objective-C中自定义泛型类"><a href="#Objective-C中自定义泛型类" class="headerlink" title="Objective-C中自定义泛型类"></a>Objective-C中自定义泛型类</h2><p><strong>作者</strong>: <a href="https://weibo.com/touristdiary" target="_blank" rel="noopener">南峰子_老驴</a></p><p>最近看 <code>Facebook</code> 的 <code>promise</code> 源码，看到 <code>FBLPromise</code> 类定义为一个泛型类，所以就温习一下。</p><p>苹果在2015年就为 Objective-C 增加了泛型。我们现在用 <code>Array</code> 、<code>Dictionary</code> 、<code>Set</code> 、<code>HashTable</code> 这些类时，一般都会使用泛型来指定元素的类型。除此之外，我们也可以自定义泛型类。如下代码所示，我们定义了一个 <code>Queue</code> 泛型类，并使用了 <code>ObjectType</code> 作为泛型类型的占位符。然后 <code>ObjectType</code> 就可以用于 <code>Queue</code> 类的属性、方法参数、成员变量中，作为这些值的类型。</p><pre class=" language-objc"><code class="language-objc">@interface Queue<ObjectType> : NSObject- (void)enqueue:(ObjectType)value;- (ObjectType)dequeue;@end@implementation Queue {    NSMutableArray *_array;}- (instancetype)init {    self = [super init];    if (self) {        _array = [[NSMutableArray alloc] init];    }    return self;}- (void)enqueue:(id)value {    [_array addObject:value];}- (id)dequeue {    if (_array.count > 0) {        id value = _array[0];        [_array removeObjectAtIndex:0];        return value;    }    return nil;}- (NSString *)description {    return [NSString stringWithFormat:@"The queue is [%@]", _array];}@end</code></pre><p>不过有两点需要注意：</p><ol><li><p><code>ObjectType</code> 只能用于类的声明中，即 <code>@interface</code> 和 对应的 <code>@end</code> 区间内。如果用在类的实现中，即 <code>@implementation</code> 中，编译器会报错，提示 “<code>Excepted a type</code>”。因此，在 <code>@implementation</code> 中，对应的需要改成 <code>id</code> 。如上代码所示；</p></li><li><p>在创建对象时，如果指定了泛型类型，那么在具体使用过程中，如果违反了规则，编译器会给出警告，如下代码所示。不过仅此而已，在运行时，你依然可以传递其它类型的值。当然，如果创建对象时没有指定泛型类型，编译器也不会给出警告；</p></li></ol><pre class=" language-objc"><code class="language-objc">int main(int argc, const char * argv[]) {    @autoreleasepool {        // insert code here...        NSLog(@"Hello, World!");        Queue<NSNumber *> *queue = [[Queue alloc] init];        [queue enqueue:@123];        [queue enqueue:@"abc"];        // Warning: Incompatible pointer types sending 'NSString *' to parameter of type 'NSNumber *'        NSLog(@"%@", queue);    }    return 0;}</code></pre><p>Objective-C 的泛型是所谓的 <code>Lightweight Generics</code>，主要是为了和 Swift 做混编，同时保证了与之前版本的兼容性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C 泛型的协变与逆变</title>
      <link href="/2018/03/01/2018/3/objective-c-fan-xing-de-xie-bian-yu-ni-bian/"/>
      <url>/2018/03/01/2018/3/objective-c-fan-xing-de-xie-bian-yu-ni-bian/</url>
      
        <content type="html"><![CDATA[<h2 id="Objective-C-泛型的协变与逆变"><a href="#Objective-C-泛型的协变与逆变" class="headerlink" title="Objective-C 泛型的协变与逆变"></a>Objective-C 泛型的协变与逆变</h2><p><strong>作者</strong>: <a href="https://weibo.com/touristdiary" target="_blank" rel="noopener">南峰子_老驴</a></p><p>Objective-C 引入泛型后，就可能会遇到一个类型转换的问题，如下代码所示：</p><pre class=" language-objc"><code class="language-objc">@interface Base : NSObject@end@implementation Base@end@interface Sub : Base@end@implementation Sub@end@interface Queue<ObjectType> : NSObject- (void)enqueue:(ObjectType)value;- (ObjectType)dequeue;@end@implementation Queue- (void)enqueue:(__unused id)value {}- (id)dequeue { return nil; }@endint main(int argc, const char * argv[]) {    @autoreleasepool {        Queue<Sub *> *subQueue = [[Queue alloc] init];        Queue<Base *> *queue = subQueue; // Warning: Incompatible pointer types initializing 'Queue<Base *>' with an expression of type 'Queue<Sub *>'        [queue enqueue:[Sub new]];    }    return 0;}</code></pre><p><code>Sub</code> 是 <code>Base</code> 的子类，如果我将一个 <code>Queue&lt;Sub *&gt;</code> 类型的对象指派给 <code>Queue&lt;Base *&gt;</code> 对象，则编译器会给出警告。这主要是因为这两个类型实际上是不同的，这种情况下，编译器不会做强制转换。如果希望子类型强制转换为父类型，就涉及到泛型的 “协变(covariant)” 操作。可以在 <code>Queue</code> 声明中，对泛型类型加上 <code>__covariant</code> 修饰符，表示元素可以接受子类型，如下代码所示：</p><pre class=" language-objc"><code class="language-objc">@interface Queue<__covariant ObjectType> : NSObject- (void)enqueue:(ObjectType)value;- (ObjectType)dequeue;@end</code></pre><p>当然，如果想反过来，将 <code>Queue&lt;Base *&gt;</code> 类型的对象指派给 <code>Queue&lt;Sub *&gt;</code> 类型的对象，可以加上 <code>__contravariant</code> 修饰符，称为 “逆变”，表示可以接受父类类型元素。</p><p>另外有两点需要注意：</p><ol><li>如果声明对象时，不指定泛型类型，直接用 <code>Queue</code>，那么可以和 <code>Queue&lt;Base *&gt;</code> 、 <code>Queue&lt;Sub *&gt;</code> 互相转换；</li><li>这两个修饰符不能同时使用；根据 <code>Mike Ash</code> 的描述，还有一个所谓的 “<code>双变性(bivariance)</code>”，即同时接受父类和子类，不过这种情况在 Objective-C 里面不存在；</li></ol><p>参考：<a href="https://www.mikeash.com/pyblog/friday-qa-2015-11-20-covariance-and-contravariance.html" target="_blank" rel="noopener">Friday Q&amp;A 2015-11-20: Covariance and Contravariance</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决Xcode真机无法联调的野路子</title>
      <link href="/2018/03/01/2018/3/jie-jue-xcode-zhen-ji-wu-fa-lian-diao-de-ye-lu-zi/"/>
      <url>/2018/03/01/2018/3/jie-jue-xcode-zhen-ji-wu-fa-lian-diao-de-ye-lu-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="解决Xcode真机无法联调的野路子"><a href="#解决Xcode真机无法联调的野路子" class="headerlink" title="解决Xcode真机无法联调的野路子"></a>解决Xcode真机无法联调的野路子</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>最近在真机联调的时候，经常遇到 <code>App installation failed.&lt;Could not write to the device.&gt;</code> 的错误提示，所下图所示。</p><p><img src="https://github.com/iOS-Tips/iOS-tech-set/blob/master/images/2018/03/2.jpg?raw=true" alt></p><p>网上的解决也是五花八门，比如说删除 <code>App</code> 重新 <code>Run</code>，<code>Clean</code> 等，发现并没有起什么卵用，并且还会占用很多开发时间。想想一个大型项目要重新编译是一件多么可怕的事情。好嘛，重点来了，图中这种错误，有一个简单而又有效的非官方解决方案——随便找一个 <code>.h</code> 或者 <code>.m</code> 进行一下增删改即可，是不是很神奇，屡试不爽。<code>&lt;iPhone has denied the launch request&gt;</code> 这种错误也可以用这种解决方案。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用AVCaptureSession踩的一个坑</title>
      <link href="/2018/02/01/2018/2/shi-yong-avcapturesession-cai-de-yi-ge-keng/"/>
      <url>/2018/02/01/2018/2/shi-yong-avcapturesession-cai-de-yi-ge-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="使用AVCaptureSession踩的一个坑"><a href="#使用AVCaptureSession踩的一个坑" class="headerlink" title="使用AVCaptureSession踩的一个坑"></a>使用AVCaptureSession踩的一个坑</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>最近遇到一个 <code>bug</code>，场景是这样的：</p><p>应用中有两个相机相关的页面，直播页和直播封面拍摄页（两个页面相机实例不是同一个），进入直播页时，设置了 <code>preset1（16:9）</code>，点击进入封面拍摄，会使用 <code>preset2（4:3）</code>。如果直播页和封面拍摄页的摄像头位置一致，从封面拍摄页返回到直播页时，会导致相机输出的画面内容变形。后面断点查看，在摄像头位置一致的情况下，从封面拍摄页返回到直播页时，直播页 <code>AVCaptureSession</code> 的 <code>preset</code> 变为了 <code>AVCaptureSessionPresetInputPriority</code> ，而不再是之前的设置的 <code>preset1</code>。</p><p>通过官方文档以及 <code>Google</code> 出的资料，<code>AVCaptureSessionPresetInputPriority</code> 代表 <code>capture session</code> 不去控制音频与视频输出设置。而是通过已连接的捕获设备的 <code>activeFormat</code> 来反过来控制 <code>capture session</code> 的输出质量等级。放到我们上面的场景，也就是最终回到直播拍摄页时，<code>preset</code> 变成了封面拍摄时的 <code>preset</code>（即 <code>4:3</code> 的 <code>preset2</code> ），进而导致了输出画面变形。其实想想也对，设备全局是同一个摄像头，上一次的更改的参数值，应该是会被保留到下一次的，所以下一次在用之前最好做一次判断是否要重新设值。</p><p>解决方案就是每次相机页面 <code>viewDidAppear</code> 的时候判断一下 <code>captureSession</code> 的 <code>preset</code> 和预设的值是否一致，不一致，再设回来即可。</p><p>以上，如有错误，欢迎指出，一起交流探讨。</p><p>参考链接：<a href="http://t.cn/R8fAZ37" target="_blank" rel="noopener">http://t.cn/R8fAZ37</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译源文件的流程</title>
      <link href="/2018/02/01/2018/2/bian-yi-yuan-wen-jian-de-liu-cheng/"/>
      <url>/2018/02/01/2018/2/bian-yi-yuan-wen-jian-de-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="编译源文件的流程"><a href="#编译源文件的流程" class="headerlink" title="编译源文件的流程"></a>编译源文件的流程</h2><p><strong>作者</strong>: <a href="https://weibo.com/touristdiary" target="_blank" rel="noopener">南峰子_老驴</a></p><p>来复习一下编译 <code>Objective-C</code> 源文件的过程吧。用下面的命令输出编译源文件的不同阶段：</p><pre class=" language-c"><code class="language-c">clang <span class="token operator">-</span>ccc<span class="token operator">-</span>print<span class="token operator">-</span>phases main<span class="token punctuation">.</span>m</code></pre><p>输出结果如下：</p><pre class=" language-c"><code class="language-c"><span class="token number">0</span><span class="token punctuation">:</span> input<span class="token punctuation">,</span> <span class="token string">"main.m"</span><span class="token punctuation">,</span> objective<span class="token operator">-</span>c<span class="token number">1</span><span class="token punctuation">:</span> preprocessor<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> objective<span class="token operator">-</span>c<span class="token operator">-</span>cpp<span class="token operator">-</span>output<span class="token number">2</span><span class="token punctuation">:</span> compiler<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> ir<span class="token number">3</span><span class="token punctuation">:</span> backend<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> assembler<span class="token number">4</span><span class="token punctuation">:</span> assembler<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> object<span class="token number">5</span><span class="token punctuation">:</span> linker<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span> image<span class="token number">6</span><span class="token punctuation">:</span> bind<span class="token operator">-</span>arch<span class="token punctuation">,</span> <span class="token string">"x86_64"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span> image</code></pre><p>简单解释一下1-6的处理：</p><ol><li>预处理：处理包括宏替换、头文件导入；</li><li>编译生成IR(中间代码)：词法分析、生成AST、静态分析等，然后生成LLVM代码；</li><li>汇编器生成汇编代码；</li><li>汇编器将可读的汇编代码转换为机器代码；</li><li>将多个目标对象文件合并为一个可执行文件；</li><li>生成image文件，即最后的可执行文件；</li></ol><p>参考 </p><p><a href="https://github.com/ming1016/study/wiki/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E7%BC%96%E8%AF%91-Clang---LLVM" target="_blank" rel="noopener">深入剖析 iOS 编译 Clang LLVM </a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用xcconfig配置BuildSettings</title>
      <link href="/2018/02/01/2018/2/yong-xcconfig-pei-zhi-buildsettings/"/>
      <url>/2018/02/01/2018/2/yong-xcconfig-pei-zhi-buildsettings/</url>
      
        <content type="html"><![CDATA[<h2 id="用xcconfig配置BuildSettings"><a href="#用xcconfig配置BuildSettings" class="headerlink" title="用xcconfig配置BuildSettings"></a>用xcconfig配置BuildSettings</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>当我们项目中有很多 <code>Target</code>，并且不同 <code>Configurations</code> 下的配置也不同的时候，直接配置 <code>BuildSettings</code> 是一件很痛苦的事情，这个时候就可以用 <code>xcconfig</code> 来解耦了。<code>xcconfig</code> 是用来保存 <code>BuildSettings</code> 键值对的纯文本文件，并且还可以共享公用的配置，在中大型项目中很是实用。</p><p>我们来举个简单栗子🌰吧，创建2个<code>xcconfig</code>文件，一个是<code>Common.xcconfig</code>（公共设置）,一个是<code>Debug.xcconfig</code>（Debug的时候使用的），如图1；</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/21-1-1.JPG?raw=true" alt></p><p>如图2；</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/21-1-2.JPG?raw=true" alt></p><p>如图3；</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/21-1-3.JPG?raw=true" alt></p><p>这个时候我们去 <code>Build Settings</code> 里面去查看就可以看到我们写入的内容了，如图4。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/21-1-4.JPG?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么音频播放器突然没声音了呢？</title>
      <link href="/2018/01/01/2018/1/wei-shi-me-yin-pin-bo-fang-qi-tu-ran-mei-sheng-yin-liao-ni/"/>
      <url>/2018/01/01/2018/1/wei-shi-me-yin-pin-bo-fang-qi-tu-ran-mei-sheng-yin-liao-ni/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么音频播放器突然没声音了呢？"><a href="#为什么音频播放器突然没声音了呢？" class="headerlink" title="为什么音频播放器突然没声音了呢？"></a>为什么音频播放器突然没声音了呢？</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>做音频的同学可能都会遇到播放的音频突然没声音的情况，遇到这种情况后，一般控制台会抛出下面的错误：</p><pre class=" language-objc"><code class="language-objc">[AVAudioSession setActive:withOptions:error:]: Deactivating an audio session that has running I/O. All I/O should be stopped or paused prior to deactivating the audio session.`</code></pre><p>遇到这个错误，会导致音频不能正常播放的情况。出现这种情况的主要原因当你设置</p><pre class=" language-objc"><code class="language-objc">[[AVAudioSession sharedInstance] setActive:NO withOptions:AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation error:nil];</code></pre><p>时还有某些操作占用了 <code>AVAudioSession</code> 权限，必须暂停或停止对 <code>AVAudioSession</code> 的使用。比如使用 <code>AVAudioPlayer</code> 播放某一音频时，此时音频正在播放，直接设置 <code>AVAudioSession</code> 的 <code>active</code> 为 <code>NO</code>，就会报上面提到的错误。而正确的做法是先暂停播放，再设置 <code>AVAudioSession</code> 的 <code>active</code> 为 <code>NO</code>。其正确的做法像下面代码所示，这样的好处是，当遇到设置失败后可以第一时间知道出错的时间点。</p><pre class=" language-objc"><code class="language-objc">NSError *error;BOOL isSuccess = [[AVAudioSession sharedInstance] setActive:active withOptions:AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation error:&error];if (isSuccess) {   NSLog(@"恭喜你成功设置");} else {   NSLog(@"设置失败");}</code></pre><p>当然如果应用中有多个地方使用 <code>AVAudioSession</code>，建议项目中统一处理 <code>AVAudioSession</code> 的 <code>active</code>，这样避免出现错误，一旦出现错误，调试起来就非常费劲。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>谈一谈iOS平台跨域访问漏洞</title>
      <link href="/2018/01/01/2018/1/tan-yi-tan-ios-ping-tai-kua-yu-fang-wen-lou-dong/"/>
      <url>/2018/01/01/2018/1/tan-yi-tan-ios-ping-tai-kua-yu-fang-wen-lou-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="谈一谈iOS平台跨域访问漏洞"><a href="#谈一谈iOS平台跨域访问漏洞" class="headerlink" title="谈一谈iOS平台跨域访问漏洞"></a>谈一谈iOS平台跨域访问漏洞</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>最近很多关于 <code>iOS Webview</code> 漏洞的话题，利用这个机会，我也来说说对这个漏洞的理解，如果有理解不对的地方，欢迎指出，同时感谢 @折腾范儿_味精 的指点。</p><p>iOS平台跨域访问漏洞成因是由于 <code>UIWebView</code> 默认开启了<code>WebKitAllowUniversalAccessFromFileURLs</code> 和 <code>WebKitAllowFileAccessFromFileURLs</code> 选项。这样黑客利用这个漏洞给某个 APP 下发一个 <code>HTML</code> 文件，当 <code>UIWebView</code> 使用 <code>file</code> 协议打开这个 <code>HTML</code> 文件，而 <code>HTML</code> 文件中含有一段窃取用户数据的 <code>JS</code> 代码，这样就导致用户数据泄露的可能。为了演示这个漏洞，我特意写了一个 <code>Demo</code>，截图是运行结果。</p><pre class=" language-objc"><code class="language-objc">NSString *filePath = [[NSBundle mainBundle] pathForResource:@"index" ofType:@"html"];_webView = [[UIWebView alloc] initWithFrame:self.view.bounds];[_webView loadRequest:[NSURLRequest requestWithURL:[NSURL fileURLWithPath:filePath]]];</code></pre><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">            <span class="token comment" spellcheck="true">// 这个可以是手机任意一个文件地址</span>            <span class="token keyword">var</span> localfile <span class="token operator">=</span> <span class="token string">"/etc/passwd"</span>            <span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">alert</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>           <span class="token keyword">try</span> <span class="token punctuation">{</span>              xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> localfile<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token function">alert</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/17-1-1.jpg?raw=true" alt></p><p>运行上面的代码，会读取出手机端 <code>/etc/passwd</code> 的文件。这样的话，我们可以利用这个漏洞访问其他应用的数据，而不必需要用户的许可。而 <code>WKWiebView</code> 的 <code>WebKitAllowUniversalAccessFromFileURLs</code> 和 <code>WebKitAllowFileAccessFromFileURLs</code> 默认是关闭的，不会存在这样的风险。</p><p>那么如何觉得自己的 APP 是否是安全的呢？看看有没有满足下面几点：</p><ol><li><code>APP</code> 中是否含有远程下发的 <code>html</code> 供 <code>APP</code> 加载，而中途会被别人篡改；</li><li>加载 <code>HTML</code> 文件是通过 <code>file</code> 协议加载的；</li><li>使用的是否为 <code>UIWebView</code>；</li><li>使用 <code>WKWiebView</code> 是否有主动开启 <code>WebKitAllowUniversalAccessFromFileURLs</code> 和 <code>WebKitAllowFileAccessFromFileURLs</code> 这两个属性。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>缓存 NSDateFormatter</title>
      <link href="/2018/01/01/2018/1/huan-cun-nsdateformatter/"/>
      <url>/2018/01/01/2018/1/huan-cun-nsdateformatter/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存-NSDateFormatter"><a href="#缓存-NSDateFormatter" class="headerlink" title="缓存 NSDateFormatter"></a>缓存 NSDateFormatter</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/2293476232" target="_blank" rel="noopener"><em>拿破仑的</em>风火轮_</a></p><p>为什么要缓存 <code>NSDateFormatter</code> ?</p><blockquote><p>Creating a date formatter is not a cheap operation. If you are likely to use a formatter frequently, it is typically more efficient to cache a single instance than to create and dispose of multiple instances. One approach is to use a static variable.<br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/DataFormatting/Articles/dfDateFormatting10_4.html" target="_blank" rel="noopener">developer.apple.com</a></p></blockquote><p>思路: 利用 <code>NSCache</code>, 以 stringFormatter+NSLocale的localeIdentifier 为key缓存 <code>NSDateFormatter</code>. 当<code>UIApplicationDidReceiveMemoryWarningNotification</code> 或 <code>NSCurrentLocaleDidChangeNotification</code> 释放 <code>NSCache</code> 缓存的对象.</p><p>代码参考<a href="https://github.com/BrooksWon/BTNSDateFormatterFactory/blob/master/BTNSDateFormatterFactory/BTNSDateFormatterFactory.m" target="_blank" rel="noopener">code</a>,  核心实现代码如下:</p><pre class=" language-objc"><code class="language-objc">- (NSDateFormatter *)dateFormatterWithFormat:(NSString *)format andLocale:(NSLocale *)locale {    @synchronized(self) {        NSString *key = [NSString stringWithFormat:@"%@|%@", format, locale.localeIdentifier];        NSDateFormatter *dateFormatter = [loadedDataFormatters objectForKey:key];        if (!dateFormatter) {            dateFormatter = [[NSDateFormatter alloc] init];            dateFormatter.dateFormat = format;            dateFormatter.locale = locale;            [loadedDataFormatters setObject:dateFormatter forKey:key];        }        return dateFormatter;    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>打印App中加载的库</title>
      <link href="/2018/01/01/2018/1/da-yin-app-zhong-jia-zai-de-ku/"/>
      <url>/2018/01/01/2018/1/da-yin-app-zhong-jia-zai-de-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="打印App中加载的库"><a href="#打印App中加载的库" class="headerlink" title="打印App中加载的库"></a>打印App中加载的库</h2><p><strong>作者</strong>: <a href="https://weibo.com/touristdiary" target="_blank" rel="noopener">南峰子_老驴</a></p><p>之前分享过配置环境变量 <code>DYLD_PRINT_STATISTICS</code>，来在控制台打印出程序启动过程中各个阶段所消耗的时间。今天再分享两个环境变量：<code>DYLD_PRINT_LIBRARIES</code> 和 <code>DYLD_PRINT_LIBRARIES_POST_LAUNCH</code>，这两个变量用于打印 <code>dyld</code> 加载的库，如下代码所示：</p><pre class=" language-objc"><code class="language-objc">dyld: loaded: /var/containers/Bundle/Application/717397DD-AE3E-457F-A446-609883FF865C/ChangeIcon.app/ChangeIcondyld: loaded: /Developer/usr/lib/libBacktraceRecording.dylibdyld: loaded: /Developer/usr/lib/libMainThreadChecker.dylibdyld: loaded: /Developer/Library/PrivateFrameworks/DTDDISupport.framework/libViewDebuggerSupport.dylibdyld: loaded: /System/Library/Frameworks/Foundation.framework/Foundationdyld: loaded: /usr/lib/libobjc.A.dylibdyld: loaded: /usr/lib/libSystem.B.dylibdyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/CoreFoundationdyld: loaded: /System/Library/Frameworks/UIKit.framework/UIKitdyld: loaded: /usr/lib/libarchive.2.dylibdyld: loaded: /usr/lib/libicucore.A.dylibdyld: loaded: /usr/lib/libxml2.2.dylibdyld: loaded: /usr/lib/libz.1.dylibdyld: loaded: /System/Library/Frameworks/CFNetwork.framework/CFNetworkdyld: loaded: /System/Library/Frameworks/SystemConfiguration.framework/SystemConfiguration......</code></pre><p>两者的区别在于 <code>DYLD_PRINT_LIBRARIES</code> 会打印出所有被加载的库，而 <code>DYLD_PRINT_LIBRARIES_POST_LAUNCH</code> 打印的是通过 <code>dlopen</code> 调用返回的库，包括动态库的依赖库，主要发生在 <code>main</code> 函数运行之后。</p><p>参考：<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/LoggingDynamicLoaderEvents.html" target="_blank" rel="noopener">Logging Dynamic Loader Events</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>弱持有容器方案</title>
      <link href="/2018/01/01/2018/1/ruo-chi-you-rong-qi-fang-an/"/>
      <url>/2018/01/01/2018/1/ruo-chi-you-rong-qi-fang-an/</url>
      
        <content type="html"><![CDATA[<h2 id="弱持有容器方案"><a href="#弱持有容器方案" class="headerlink" title="弱持有容器方案"></a>弱持有容器方案</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>在通知者模式中，<code>manger</code> 想弱持有一些对象，我们可以怎么做呢？</p><p>方案一：使用<code>Foundation</code>为大家提供的弱持有容器：<code>NSHashTable</code>、<code>NSMapTable</code>、<code>NSPointerArray</code>，初始化时把<code>option</code>设置成<code>weak</code>即可；</p><p>方案二：可以使用<code>CFFoundation</code>的<code>CFArrayCreateMutable</code>等来创建容器，被添加的对象引用计数不会加1；</p><p>方案三：可以妙用<code>NSValue</code>的<code>valueWithNonretainedObject</code>方法，被添加的对象不需要服从<code>NSCopying</code>协议；</p><p>方案四：使用我们通常用的强持有容器，让被添加的对象weak一下，比如使用<code>__weak</code>和<code>block</code>配合：在<code>block</code>中返回weak对象。</p><p>如果有其他思路的，欢迎提出！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对清除图片缓存的思考</title>
      <link href="/2018/01/01/2018/1/dui-qing-chu-tu-pian-huan-cun-de-si-kao/"/>
      <url>/2018/01/01/2018/1/dui-qing-chu-tu-pian-huan-cun-de-si-kao/</url>
      
        <content type="html"><![CDATA[<h2 id="对清除图片缓存的思考"><a href="#对清除图片缓存的思考" class="headerlink" title="对清除图片缓存的思考"></a>对清除图片缓存的思考</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>众所周知，使用 <code>+[UIImage imageNamed:]</code> 方法加载图片是会进图片缓存的，清除缓存是系统触发，并没有为我们提供API；使用 <code>+[UIImage imageWithContentsOfFile:]</code> 方法加载图片是不会进入图片缓存的。如果想要有图片缓存机制，并且能手动清除图片缓存，我们可以这样做：</p><p>从 <code>+[UIImage imageWithContentsOfFile:]</code> 方向下手：<br>我们可以自己维护一套图片缓存，<code>Swizzle +[UIImage imageWithContentsOfFile:]</code> 方法加入缓存机制。加载图片后，加入到 <code>NSCache</code> 缓存，再次取该图片时，优先取 <code>NSCache</code> 内的缓存，如果缓存内没有再去真正加载。<code>NSCache</code>在 <code>Memory Warning</code> 的时候会自动清除缓存，我们也可以使用 <code>-[NSCache removeAllObjects]</code> 手动清除缓存。当然，你也可以不使用 <code>Swizzle</code> ，写一个 <code>Manager</code> 也是可以的，我只是提供一种思路。</p><p>从 <code>+[UIImage imageNamed:]</code> 方向下手：<br>在 <code>Memory Warning</code> 或进入后台时，系统会自动帮我们清除使用 <code>+[UIImage imageNamed:]</code> 的图片缓存。我们也可以通过模拟发送 <code>UIApplicationDidReceiveMemoryWarningNotification</code> 或 <code>UIApplicationDidEnterBackgroundNotification</code> 来清除图片缓存，风险可以根据实际情况来评估。</p><p>还可以从私有API来下手，<code>+[UIImage imageNamed:]</code> 系统底层是通过 <code>UIAssetManager</code> 来管理图片缓存的，如下两图所示，我们可以模拟调用 <code>_clearCachedResources</code> 方法来实现清除缓存。</p><p>如果有其他思路的，欢迎提出！</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/5-1.jpg?raw=true" alt><br><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/5-2.jpg?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>定时器引发的思考</title>
      <link href="/2018/01/01/2018/1/ding-shi-qi-yin-fa-de-si-kao/"/>
      <url>/2018/01/01/2018/1/ding-shi-qi-yin-fa-de-si-kao/</url>
      
        <content type="html"><![CDATA[<h2 id="定时器引发的思考"><a href="#定时器引发的思考" class="headerlink" title="定时器引发的思考"></a>定时器引发的思考</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>当使用 <code>AudioServicesPlaySystemSoundWithCompletion</code> 播放完一段音频后，在回调中开启一个定时器，然后发现定时器不执行，代码是这样的：</p><pre class=" language-objc"><code class="language-objc">AudioServicesPlaySystemSoundWithCompletion(sysSoundID, ^{    AudioServicesDisposeSystemSoundID(sysSoundID);    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(lefexTimerAction:) userInfo:nil repeats:YES];});- (void)lefexTimerAction:(NSTimer*)timer{   // 这个方法并不会执行}</code></pre><p>如果我把代码改成下面这样，定时器可以正常执行，但是发现方法 <code>lefexTimerAction:</code> 并不在主线程中执行，而是在开启定时器对应的线程中执行，代码如下：</p><pre><code>AudioServicesPlaySystemSoundWithCompletion(sysSoundID, ^{   AudioServicesDisposeSystemSoundID(sysSoundID);   NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(handlePageStayTimer:) userInfo:nil repeats:YES];   [[NSRunLoop currentRunLoop] run]; });</code></pre><p>看到这里，相信你已经明白是什么原因了。</p><p>系统音频播放完成后回调并不在主线程，导致开启定时器时不在主线程。<code>Timer</code> 和 <code>runLoop</code> 是一起工作的，没有 <code>runLoop</code>，定时器不能正常执行。而系统中只有 <code>mainRunLoop</code> 会默认开启，这就是为什么在主线程创建定时器可以正常执行的原因。</p><p><code>runLoop</code> 会强引用 <code>timer</code>，这就是我们经常所说的为什么 <code>timer</code> 会导致内存泄漏，即使在 <code>dealloc</code> 中释放 <code>timer</code>，也不能避免内存泄漏，因为 <code>dealloc</code> 就不会执行。</p><p>查看 <code>runLoop</code> 中的 <code>timer</code> 信息发现，它会记录 <code>timer</code> 下次要执行的时间，当 <code>runLoop</code> 到下一次循环的时候，会检测 <code>timer</code> 是否需要执行，这也就是 <code>timer</code> 不准的原因，因为每一次 <code>runloop</code> 后才会执行 <code>timer</code> 的事件。</p><pre class=" language-objc"><code class="language-objc">{  valid = Yes,  firing = No,  interval = 1,  tolerance = 0,  next fire date = 538315424 (-6.348737 @ 113761747014063),  callout = (NSTimer) [Lefex handlePageStayTimer:],  context = <CFRunLoopTimer context 0x600000226680> }</code></pre><p>总结：<br>从上面的问题来看，<code>NSTimer</code>对学习 <code>runLoop</code> 有很大帮助。<code>runLoop</code> 和线程是一一对应的，而除主线程外，其他线程对应的 <code>runLoop</code> 并没有创建，当调用 <code>[NSRunLoop currentRunLoop]</code> 时会创建这个线程对应的 <code>runLoop</code>，定时器能跑起来的前提是 <code>runLoop</code> 必须 <code>run</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>另一种形式定时器</title>
      <link href="/2018/01/01/2018/1/ling-yi-chong-xing-shi-ding-shi-qi/"/>
      <url>/2018/01/01/2018/1/ling-yi-chong-xing-shi-ding-shi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="另一种形式定时器"><a href="#另一种形式定时器" class="headerlink" title="另一种形式定时器"></a>另一种形式定时器</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>从昨天 @Lefe_x 的分享我们知道 <code>NSTimer</code> 需要配合 <code>runloop</code> 使用，而且它计时是不精确的，同时处理不当的情况下会存在循环引用的情况。</p><p>今天和大家分享一下基于 <code>GCD</code> 的 <code>Timer</code>，它能解决掉刚刚提及到的 <code>NSTimer</code> 的三大问题。先来看一段示例代码，如图，具体解释已经包含在图中了。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/15-1.jpg" alt></p><p>但是使用 <code>dispatch_suspend</code>、<code>dispatch_resume</code> 这两个方法需要注意配对使用，不然可能会有意想不到的“惊(崩)喜(溃)”。值得一提的是 <code>dispatch source</code> 并没有提供用于检测 <code>source</code> 本身的挂起计数的 <code>API</code>，也就是说外部无法得知当前 <code>source</code> 状态。还有就是创建 <code>timer</code> 最好被持有，不然 <code>dispatch_suspend</code> 之后，如果没有被持有的话，就会 <code>crash</code>。</p><p>当 <code>dispatch_cancel</code> 调用后，这个 <code>timer</code> 就失效了，类似 <code>NSTimer</code> 的 <code>invalidate</code>。</p><p>关于 <code>GCD Timer</code> 推荐一个开源库:<a href="https://github.com/100mango/SwiftTimer" target="_blank" rel="noopener">SwiftTimer</a></p><p><a href="http://t.cn/RQmIIpV" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动画实现竟然可以这么简单，支持 NA 与 Web</title>
      <link href="/2018/01/01/2018/1/dong-hua-shi-xian-jing-ran-ke-yi-zhe-me-jian-dan-zhi-chi-na-yu-web/"/>
      <url>/2018/01/01/2018/1/dong-hua-shi-xian-jing-ran-ke-yi-zhe-me-jian-dan-zhi-chi-na-yu-web/</url>
      
        <content type="html"><![CDATA[<h2 id="动画实现竟然可以这么简单，支持-NA-与-Web"><a href="#动画实现竟然可以这么简单，支持-NA-与-Web" class="headerlink" title="动画实现竟然可以这么简单，支持 NA 与 Web"></a>动画实现竟然可以这么简单，支持 NA 与 Web</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>你有没有想过，一个复杂的类似 <code>Twitter</code> 点赞动画使用一行代码就可以完成，而且基本不需要调整什么参数就可以达到 UE 的要求，从几天的工作量可以缩短到几分钟。而这一切多亏了 <code>Lottie</code>，它可以帮我们实现这一切。只需要有个由 <code>Bodymovin</code> 导出的 <code>Json</code> 文件，即可轻松实现 <code>UE</code> 提供的动效。</p><p><code>Lottie</code> 是由 <a href="http://airbnb.io" target="_blank" rel="noopener">Airbnb</a> 开源的库，它支持 iOS, macOS， Android ，React Native 和 Web。它主要通过解析一个由 <code>Bodymovin</code> 导出的 <code>Json</code> 文件，然后在 <code>NA</code> 和 <code>Web</code> 上渲染动画。而这些动画最初通过 <code>Adobe After Effects</code> 软件设计。</p><p><code>Adobe After Effects</code> 简称 “AE” 是 <code>Adobe</code> 公司推出的一款图形视频处理软件，适用于从事设计和视频特技的机构，包括电视台、动画制作公司、个人后期制作工作室以及多媒体工作室。</p><p><code>Bodymovin</code> 是 <code>Adobe After Effects</code> 的一个插件，可以把通过 <code>AE</code> 做出的动画，导出为 <code>Json</code> 文件，而 <code>Lottie</code> 直接使用导出的 <code>Json</code> 文件在手机端渲染动画。</p><p>看看具体的一个 <code>Twitter</code> 点赞动画实例：</p><pre class=" language-objc"><code class="language-objc">LOTAnimatedSwitch *heartIcon = [LOTAnimatedSwitch switchNamed:@"TwitterHeart"];heartIcon.frame = CGRectMake(100, 100, 200, 200);[self.view addSubview:heartIcon];</code></pre><p><code>Lottie</code> 可以直接创建一个动画视图添加到另一个视图上，既可以完成显示。而它的原理就是通过解析 <code>Json</code> 文件生成一个 <code>LOTComposition</code> 类，来管理动画所需要的参数，然后利用原生类实现动画效果。目前主要支持的动画特性有：</p><ol><li>转场动画；</li><li>通过 <code>Json</code> 文件渲染动画；</li><li>可以通过一个动画播放器来播放动画，拖到进度条，查看动画的实现，这对自己实现一个原生动画非常有帮助；</li><li>在运行时修改动画；</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态加载Framework/Library</title>
      <link href="/2018/01/01/2018/1/dong-tai-jia-zai-framework-library/"/>
      <url>/2018/01/01/2018/1/dong-tai-jia-zai-framework-library/</url>
      
        <content type="html"><![CDATA[<h2 id="动态加载Framework-Library"><a href="#动态加载Framework-Library" class="headerlink" title="动态加载Framework/Library"></a>动态加载Framework/Library</h2><p><strong>作者</strong>: <a href="https://weibo.com/touristdiary" target="_blank" rel="noopener">南峰子_老驴</a></p><p>在开发 <code>Framework/Library</code> 时，我们可能需要在 <code>Demo</code> 中测试不同版本的兼容性。如果每次都在 <code>Demo</code> 的 <code>Build Phase</code> 中切换 <code>Framework/Library</code> 的不同版本，是件很麻烦的事。这种情况下，我们就可以考虑在运行时动态加载 <code>Framework/Library</code>。方法很简单，就是使用 <code>&quot;dlfcn.h&quot;</code> 中的 <code>dlopen</code> 函数：</p><pre class=" language-objc"><code class="language-objc">void *framework1Handle = dlopen("DynamicFramework1.framework/DynamicFramework1", RTLD_LAZY);</code></pre><p><code>dlopen</code> 有一个对应的方法 <code>dlclose</code> 用于卸载库，不过在 <code>iOS</code> 上，这个方法似乎不起作用。因此在同一次运行时，没有办法直接切换 <code>Framework/Library</code> 的不同版本，否则会出现如图的提示。实际使用哪个版本的代码无法确定。</p><pre class=" language-objc"><code class="language-objc">objc[10662]: Class CASHello is implemented in both /private/var/containers/Bundle/Application/73362515-9CCA-47E0-B709-49BA437935DC/ios-dynamic-loading-framework.app/Frameworks/DynamicFramework1.framework/DynamicFramework1 (0x105680178) and /private/var/containers/Bundle/Application/73362515-9CCA-47E0-B709-49BA437935DC/ios-dynamic-loading-framework.app/Frameworks/DynamicFramework2.framework/DynamicFramework2 (0x105694178). One of the two will be used. Which one is undefined.</code></pre><p>变通的方案是在启动时提供一个选择页面，选择在运行 <code>App</code> 时，使用哪个版本的 <code>Framework/Library</code>。如果要切换版本，再重新启动 <code>App</code> 。</p><p><code>dlopen</code> 仅限于开发阶段使用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态修改应用程序的icon</title>
      <link href="/2018/01/01/2018/1/dong-tai-xiu-gai-ying-yong-cheng-xu-de-icon/"/>
      <url>/2018/01/01/2018/1/dong-tai-xiu-gai-ying-yong-cheng-xu-de-icon/</url>
      
        <content type="html"><![CDATA[<h2 id="动态修改应用程序的icon"><a href="#动态修改应用程序的icon" class="headerlink" title="动态修改应用程序的icon"></a>动态修改应用程序的icon</h2><p><strong>作者</strong>: <a href="https://weibo.com/touristdiary" target="_blank" rel="noopener">南峰子_老驴</a></p><p>偶然看到 <code>Price Tag</code> 有个替换应用图标的功能，如图，研究了一下。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/3-1.png?raw=true" alt></p><p>这个功能是在 <code>iOS 10.3</code> 后新增的，主要的 <code>API</code> 如下所示：</p><pre class=" language-objc"><code class="language-objc">@interface UIApplication (UIAlternateApplicationIcons)// If false, alternate icons are not supported for the current process.@property (readonly, nonatomic) BOOL supportsAlternateIcons NS_EXTENSION_UNAVAILABLE("Extensions may not have alternate icons") API_AVAILABLE(ios(10.3), tvos(10.2));// Pass `nil` to use the primary application icon. The completion handler will be invoked asynchronously on an arbitrary background queue; be sure to dispatch back to the main queue before doing any further UI work.- (void)setAlternateIconName:(nullable NSString *)alternateIconName completionHandler:(nullable void (^)(NSError *_Nullable error))completionHandler NS_EXTENSION_UNAVAILABLE("Extensions may not have alternate icons") API_AVAILABLE(ios(10.3), tvos(10.2));// If `nil`, the primary application icon is being used.@property (nullable, readonly, nonatomic) NSString *alternateIconName NS_EXTENSION_UNAVAILABLE("Extensions may not have alternate icons") API_AVAILABLE(ios(10.3), tvos(10.2));@end</code></pre><p>只读属性 <code>supportsAlternateIcons</code> 用于判断系统是否允许修改 <code>App</code> 图标，只有在允许的情况下才能修改。<code>-setAlternateIconName:completionHandler:</code> 用于执行修改操作，如果 <code>iconName</code> 设置为 <code>nil</code>，则恢复为主图标，使用方式如下代码所示：</p><pre class=" language-objc"><code class="language-objc">- (IBAction)changeIcon:(UIButton *)sender {    if ([[UIApplication sharedApplication] supportsAlternateIcons]) {        NSString *iconName = nil;        if (sender.tag == 1) {            iconName = @"rocket";        } else if (sender.tag == 2) {            iconName = @"pin";        }        [[UIApplication sharedApplication] setAlternateIconName:iconName completionHandler:^(NSError * _Nullable error) {        }];    }}</code></pre><p>除了调用 <code>API</code> 外，最主要的还需要在 <code>info.plist</code> 中配置 <code>CFBundleIcons</code> 项，这是一个字典，可包含 <code>CFBundlePrimaryIcon</code>、<code>CFBundleAlternateIcons</code>、<code>UINewsstandIcon</code> 三个键。</p><p><code>CFBundlePrimaryIcon</code> 为主图标，即 <code>Assets.xcassets</code> 中 <code>AppIcon</code> 的信息，一般置空。<code>CFBundleAlternateIcons</code> 即用于设置替换图标，具体的配置项描述可以参考<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html" target="_blank" rel="noopener">官方文档</a> ，通常的配置如图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/3-2.png?raw=true" alt></p><p>这里需要注意的是，替换图标应该放在工程的某个目录下，而不放在 <code>Assets.xcassets</code> 中，如图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/3-3.png?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用 Custom event 解决一个小问题</title>
      <link href="/2018/01/01/2018/1/li-yong-custom-event-jie-jue-yi-ge-xiao-wen-ti/"/>
      <url>/2018/01/01/2018/1/li-yong-custom-event-jie-jue-yi-ge-xiao-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="利用-Custom-event-解决一个小问题"><a href="#利用-Custom-event-解决一个小问题" class="headerlink" title="利用 Custom event 解决一个小问题"></a>利用 Custom event 解决一个小问题</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/2293476232" target="_blank" rel="noopener"><em>拿破仑的</em>风火轮_</a></p><p>做IM开发时,有个场景是:数据异步处理,回到主线程刷新UI、展示消息给用户看到.当用户短时间内收到很多条消息时,我们不想对UI进行频繁而累赘的更新,理想的情况是当主线程繁忙时将所有的改变联结起来。此时,可以利用联结的优势(在异步线程上调用 <code>dispatch_source_merge_data</code> 后，就会执行 <code>dispatch source</code> 事先定义好的 <code>handler</code> )。使用 <code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>，将刷新UI的工作拼接起来，短时间内做尽量少次数的刷新。</p><p>伪代码</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/20-1-1.png?raw=true" alt></p><p>执行结果</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/20-1-2.png?raw=true" alt></p><p>欢迎大家分享其他思路.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于断言的一些用法和坑</title>
      <link href="/2018/01/01/2018/1/guan-yu-duan-yan-de-yi-xie-yong-fa-he-keng/"/>
      <url>/2018/01/01/2018/1/guan-yu-duan-yan-de-yi-xie-yong-fa-he-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="关于断言的一些用法和坑"><a href="#关于断言的一些用法和坑" class="headerlink" title="关于断言的一些用法和坑"></a>关于断言的一些用法和坑</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>众所周知，我们在写代码的时候会写一些断言来发现调试阶段的一些异常情况，但是这些异常情况上线后是不应该展示给用户或者让用户感知到的。</p><p>通常使用 <code>NSAssert</code> 或基于它的宏。<code>Xcode 4.2</code> 之后在 <code>release</code> 模式下会自动将所有的 <code>NSAssert</code> 优化掉，也就是说，<code>release</code> 模式下，<code>NSAssert</code> 不会被编译到二进制文件中去，主要是通过这个宏 <code>NS_BLOCK_ASSERTIONS</code> 来实现的。<br>但是项目中接入的第三方库或者其它团队提供的库，无法保证他们也用 <code>NSAssert</code>，写C语言的工程师一般是用 <code>assert</code> 来做断言处理，但是这里就来坑了。具体坑体现在以下两种情况：</p><ol><li><code>assert</code> 在 <code>release</code> 下 <code>Xcode</code> 是不会自动将这些断言移除，也就是会导致正式生产环境下会导致一些异常(崩溃)。我们可以通过 <code>Building Settings</code> -&gt; 搜索 <code>“Preprocessor Macros”</code> 找到 <code>release</code> 模式，双击，然后添加，输入 <code>NDEBUG=1</code> 即可。如图所示</li></ol><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/7-1.jpg?raw=true" alt></p><ol start="2"><li>说完第一个坑，又来到第二个，如果 <code>pod</code> 里面也有用到 <code>assert</code>，上述步骤对 <code>pod</code> 无效。解决方案如图</li></ol><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/7-2.jpg?raw=true" alt></p><p>就是 <code>pod install</code> 之后把每个 <code>pod</code> 的 <code>target</code> 的 <code>release</code> 模式添加 <code>NDEBUG=1</code>。或者也可以在 <code>podspec</code> 里面添加对应的 <code>GCC_PREPROCESSOR_DEFINITIONS</code> 定义，不过由于是第三方库，可能不太方便（自己维护的 <code>pod</code> 另说）。</p><p>参考</p><ol><li><a href="http://nshipster.com/nsassertionhandler/" target="_blank" rel="noopener">NSAssertionHandler</a></li><li><a href="https://stackoverflow.com/a/7887526" target="_blank" rel="noopener">NSAssert vs. assert: Which do you use, and when?</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS中NSArray/NSSet的一些巧妙用法</title>
      <link href="/2018/01/01/2018/1/ios-zhong-nsarray-nsset-de-yi-xie-qiao-miao-yong-fa/"/>
      <url>/2018/01/01/2018/1/ios-zhong-nsarray-nsset-de-yi-xie-qiao-miao-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS中NSArray-NSSet的一些巧妙用法"><a href="#iOS中NSArray-NSSet的一些巧妙用法" class="headerlink" title="iOS中NSArray/NSSet的一些巧妙用法"></a>iOS中NSArray/NSSet的一些巧妙用法</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>最近用到很多操作集合类型的方法，这里总结分享一下，也欢迎大家一起补充。</p><ul><li>假设我们已经有一个 <code>NSArray&lt;Model *&gt;</code> 类型的数组，但是我们想把这个数组中的 <code>Model</code> 的某个属性取出组成一个新的数组，一般情况下可能是直接去遍历，但是 <code>NSArray/NSSet</code> 有一个更便捷的方法 <code>valueForKey:</code>,可以快速取出对应属性组成的数组。但是有个问题就是这个方法的效率比 <code>for</code> 循环低，数据量不大的时候使用还是没有问题的。如下面两张图：</li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/4-1.jpg?raw=true" alt></p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/4-2.jpg?raw=true" alt></p><ul><li><p>要取两个数组的交集的时候，可以先将 <code>NSArray</code> 转换成 <code>NSMutableSet</code>，再通过取二者交集即可。但是需要注意一点的是数组中的元素最好复写一下 <code>isEqual:</code> 和 <code>hash</code> 方法，保证取交集后的结果是正确的。</p></li><li><p>要将数组内元素排序或者过滤等操作，可以结合 <code>NSSortDescriptor</code> 和 <code>NSPredicate</code> 使用，可以避免掉大量冗余的 <code>for</code> 循环之类的代码。关于 <code>NSPredicate</code> 的用法可以参考 <a href="http://nshipster.com/nspredicate/" target="_blank" rel="noopener">NSHipster</a> 和 <code>Realm</code> 的 <a href="https://academy.realm.io/posts/nspredicate-cheatsheet/" target="_blank" rel="noopener">Cheetsheet</a></p></li><li><p>关于图中 <code>valueForKey:</code> 的参数为什么不直接用 <code>@&quot;name&quot;</code> 而是用 <code>NSStringFromSelector(@selector(name))</code>，是因为后者会有代码提示可以避免硬编码带来的错误，同时后续该 <code>key</code> 换名字了之后，会有对应的警告。这个也是从 <code>AFNetworking</code> 中学到的。如图所示：</p></li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/4-3.jpg?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义WebView的UserAgent</title>
      <link href="/2018/01/01/2018/1/zi-ding-yi-webview-de-useragent/"/>
      <url>/2018/01/01/2018/1/zi-ding-yi-webview-de-useragent/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义WebView的UserAgent"><a href="#自定义WebView的UserAgent" class="headerlink" title="自定义WebView的UserAgent"></a>自定义WebView的UserAgent</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/2293476232" target="_blank" rel="noopener"><em>拿破仑的</em>风火轮_</a></p><ol><li>产品需求:所有 <code>APP</code> 内的 <code>WebView</code> 访问的自家服务, 根据 <code>UserAgent</code> 自动切换显示合适的内容.</li><li>思路:自定义全局的 <code>UserAgent</code> .</li><li>实现代码如下:</li></ol><pre class=" language-objc"><code class="language-objc">/** * User-Agent 格式参照了 AFNetworking 设置 */- (void)customizeWebViewUserAgent {    NSString *userAgent = nil;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wgnu"    // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43    userAgent = [NSString stringWithFormat:@"%@/%@ (%@-WebView; iOS %@; Scale/%0.2f)", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@"CFBundleShortVersionString"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];#pragma clang diagnostic pop    if (userAgent) {        if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) {            NSMutableString *mutableUserAgent = [userAgent mutableCopy];            if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@"Any-Latin; Latin-ASCII; [:^ASCII:] Remove", false)) {//把不符合ASCII编码的字符,转码成ASCII编码格式                userAgent = mutableUserAgent;            }        }        [NSUserDefaults.standardUserDefaults registerDefaults:@{@"UserAgent": userAgent}];    }}</code></pre><ul><li><p><code>UIWebView</code> 和 <code>WkWebView</code> 的默认 <code>UserAgent</code> 抓包如图所示</p><p>  <img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/6-1.png?raw=true" alt></p></li><li><p>自定义 <code>UserAgent</code> 如图所示</p><p>  <img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/6-2.png?raw=true" alt></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 中音量控制解惑</title>
      <link href="/2018/01/01/2018/1/ios-zhong-yin-liang-kong-zhi-jie-huo/"/>
      <url>/2018/01/01/2018/1/ios-zhong-yin-liang-kong-zhi-jie-huo/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-中音量控制解惑"><a href="#iOS-中音量控制解惑" class="headerlink" title="iOS 中音量控制解惑"></a>iOS 中音量控制解惑</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>iOS 中音量中其实也有好多小窍门，这个小集帮你解惑。iOS 中主要有2个地方可以控制音量，一个是系统音量，用户主动按音量键，调整音量，这种方式会显示系统音量提示框；另一个是播放器的音量，比如通过 <code>AVAudioPlayer</code> 调整音量，这种不会显示系统提示音量框。</p><h3 id="如何调节音量时不显示系统音量提示框"><a href="#如何调节音量时不显示系统音量提示框" class="headerlink" title="如何调节音量时不显示系统音量提示框"></a>如何调节音量时不显示系统音量提示框</h3><p>主要原理就是获取系统音量 <code>View</code>，并把它让用户不可见。但注意一点，你不能把 <code>MPVolumeView</code> 的 <code>hidden</code> 属性设置为 <code>YES</code>，这样导致的结果是用户调整音量时任然会显示系统音量提示框，如下代码所示。</p><pre><code>_volumeView = [[MPVolumeView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];_volumeView.backgroundColor = [UIColor yellowColor];// 如果设置了 Hidden 为 YES，那么修改音量时会弹出系统音量框_volumeView.hidden = NO;_volumeView.alpha = 0.01;for (UIView *view in [_volumeView subviews]){if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;]){    self.volumeSlider = (UISlider*)view;    break;   }}[self.view addSubview:_volumeView];</code></pre><h3 id="获取系统音量"><a href="#获取系统音量" class="headerlink" title="获取系统音量"></a>获取系统音量</h3><p>方法一：通过 <code>self.volumeSlider</code> 获取</p><p>如果想获取系统音量，可以通过第一种方式，<code>self.volumeSlider.value</code> 来获取，但是你发现第一次为 0，这很纠结，这样导致的结果就是获取的系统音量不准确。这是因为初始 <code>MPVolumeView</code> 时，<code>volumeSlider.value</code> 还没有赋值，如下图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/2-1.jpg?raw=true" alt></p><p>可以发现，音量是后来通过 <code>[MPVolumeController updateVolumeValue]</code> 来更新的。所以我们可以通过监听 <code>self.volumeSlide</code> 值改变时的事件，达到获取系统音量的目的。</p><pre class=" language-objc"><code class="language-objc">[self.volumeSlider addTarget:self action:@selector(sliderValueDidChange:) forControlEvents:UIControlEventValueChanged];</code></pre><p>方法二：通过 <code>AVAudioSession</code> 获取</p><pre class=" language-objc"><code class="language-objc">[[AVAudioSession sharedInstance] outputVolume];</code></pre><p>这种方法直接了当。</p><h3 id="自定义音量控件"><a href="#自定义音量控件" class="headerlink" title="自定义音量控件"></a>自定义音量控件</h3><p>如果想自定义音量控件，可以监听音量的变化，并且通过第一种方法隐藏系统音量提示框。通过监听通知，达到监听音量变化的效果。</p><h3 id="监听音量变化"><a href="#监听音量变化" class="headerlink" title="监听音量变化"></a>监听音量变化</h3><p>监听音量变化，通过监听通知 </p><pre class=" language-objc"><code class="language-objc">AVSystemController_SystemVolumeDidChangeNotification[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(volumeChanged:) name:@"AVSystemController_SystemVolumeDidChangeNotification" object:nil];</code></pre><p>最终结果 <code>AVSystemController_AudioVolumeNotificationParameter</code> 表示音量的值，这里需要注意的是 <code>&quot;AVSystemController_AudioVolumeChangeReasonNotificationParameter&quot; = ExplicitVolumeChange;</code> 这个值，它会由于不同的场景，有不同的值。<code>ExplicitVolumeChange</code> 是用户点击音量按钮，<code>CategoryChange</code> 是用户按 <code>home</code> 键调起 <code>Siri</code>，<code>RouteChange</code> 这个时路线修改（不太清楚，什么情况下触发的）。</p><pre class=" language-objc"><code class="language-objc">AVSystemController_SystemVolumeDidChangeNotification; object = <AVSystemController: 0x1c4001dc0>; userInfo = {    "AVSystemController_AudioCategoryNotificationParameter" = "Audio/Video";    "AVSystemController_AudioVolumeChangeReasonNotificationParameter" = ExplicitVolumeChange;    "AVSystemController_AudioVolumeNotificationParameter" = "0.5625";    "AVSystemController_UserVolumeAboveEUVolumeLimitNotificationParameter" = 0;}}</code></pre><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>如果通过代码修改了 <code>self.volumeSlide</code> 的 <code>value</code>，那么会显示出系统音量框，如果你发现某个页面突然蹦出一个系统音量框，原因大多数是你修改了这个值。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2018/01/2-2.jpg?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 关于音频播放调研</title>
      <link href="/2018/01/01/2018/1/ios-guan-yu-yin-pin-bo-fang-diao-yan/"/>
      <url>/2018/01/01/2018/1/ios-guan-yu-yin-pin-bo-fang-diao-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-关于音频播放调研"><a href="#iOS-关于音频播放调研" class="headerlink" title="iOS 关于音频播放调研"></a>iOS 关于音频播放调研</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>由于最近做音频方面的工作，就调研了一下关于音频播放的一些知识，中间也走过不少弯路，希望这篇小集能对关注我们的同学一点启示，少走一些弯路。最后提供一份我看过的资料。这里关于音频播放简单做一个总结。iOS 中音频播放有以下 5 种方式（如果你有更多的方式告诉我，非常感激），它们的使用场景各不同。</p><p>[1] 播放小于 30s 的音频：<br><code>AudioServicesPlaySystemSound</code> 可以播放小于等于 <code>30s</code> 的音频，主要用于播放一些提示音，你可以利用 <code>AudioServicesPlaySystemSoundWithCompletion</code> 的值播放完成的 <code>callback</code>。它有以下特点：</p><ul><li>使用系统音量，不能修改播放音量；</li><li>立刻开始播放，不能暂停；</li><li>不支持快进播放，也不可以循环播放；</li><li>同一时刻只能播放一个音频；</li><li>只能通过手机播放音频，不能通过其它设备输出，比如不能通过车载播放。</li></ul><p><a href="http://iphonedevwiki.net/index.php/AudioServices" target="_blank" rel="noopener">查看更多的系统声音ID</a></p><p>[2] <code>AVAudioPlayer</code> 播放本地的音频，或者已加载到内存中的音频流，主要用于播放本地的一些音频文件。注意它不能播放网络音频。它有以下特点：</p><ul><li>可以从任意位置播放，可快进，快退；</li><li>可以循环播放；</li><li>可以同时播放多个音频；</li><li>可以控制播放速率；</li></ul><p>[3] <code>AVPlayer</code> 可以播放本地和网络音频，也可以播放视频，它支持流媒体播放，也就是说我们可以用它来做边下别播的使用场景。</p><p>[4] <code>AVQueuePlayer</code> 是 <code>AVPlayer</code> 的子类，它含有一个队列，主要用来播放一个音视频队列。</p><p>[5] <code>Audio Queue</code> 主要用来播放音频，录音，它比较底层，会有更多的控制权，如果 <code>APP</code> 主要功能是基于音频播放，推荐使用这个。</p><p>总的来说，如果普通的本地音频播放，可以选择 <code>AVAudioPlayer</code> ，这个不需要了解更多的音频知识，就可以达到一个基本的播放；如果想做流媒体播放，建议使用 <code>AVPlayer + Local Server</code> 的方式，类似于唱吧目前开源的方式。当然也可以选择 <code>Audio Queue</code>，不过这个难度比较高，需要对音频播放有一个整体的了解，推荐使用三方库 <code>FreeStream</code>，不过需要一些 <code>C++</code> 的知识，因为使用过程中有一些坑需要填，这样不得不阅读源码。最后推荐一些不错的文章。</p><p><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/AQPlayback/PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW1" target="_blank" rel="noopener">官方 Audio Queue</a></p><p><a href="https://developer.apple.com/library/content/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007875" target="_blank" rel="noopener">官方 AudioSession</a></p><p><a href="https://brownfeng.github.io/2016/07/25/iOS%E9%9F%B3%E9%A2%91%E7%B3%BB%E5%88%97(%E4%B8%80" target="_blank" rel="noopener">@pp锅的码农生活 博客</a>/)</p><p><a href="http://msching.github.io/blog/2014/07/08/audio-in-ios-2/" target="_blank" rel="noopener">@cy_zju 博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>证书勿随意Revoke</title>
      <link href="/2018/01/01/2018/1/zheng-shu-wu-sui-yi-revoke/"/>
      <url>/2018/01/01/2018/1/zheng-shu-wu-sui-yi-revoke/</url>
      
        <content type="html"><![CDATA[<h2 id="证书勿随意Revoke"><a href="#证书勿随意Revoke" class="headerlink" title="证书勿随意Revoke"></a>证书勿随意Revoke</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>用 <code>InHouse</code> 证书打了一个包，当 <code>InHouse</code> 证书过期后，已经安装了这个包的用户还可以继续正常使用，但用户想全新安装或者覆盖安装这个包就会失败；如果 <code>InHouse</code> 证书不是自然过期，而是手动 <code>Revoke</code> ，那么注意啦，用户不仅不能安装这个包，还会影响已经安装了这个包的用户，启动就会闪退，无法正常使用，如果此时你正在用蒲公英或者fir等三方平台灰测，那么可想而知。。。。虽然说发布证书<code>Revoke</code>不会影响已经发布到 <code>AppStore</code> 的包，但是依旧不提倡；如果你随意 <code>Revoke</code> 了一个正在使用中的 <code>Push</code> 证书，那么恭喜你，在你生成新的证书，<code>Push</code> 服务器更换之前，你的用户就无法收到 <code>Push</code> 啦。<code>Revoke</code> 需谨慎，且行且珍惜！搞不好，就会影响一大批用户。。。。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS快速解析崩溃日志</title>
      <link href="/2017/12/01/2017/12/ios-kuai-su-jie-xi-beng-kui-ri-zhi/"/>
      <url>/2017/12/01/2017/12/ios-kuai-su-jie-xi-beng-kui-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS快速解析崩溃日志"><a href="#iOS快速解析崩溃日志" class="headerlink" title="iOS快速解析崩溃日志"></a>iOS快速解析崩溃日志</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>平时我们拿到一份崩溃日志，需要解析，一般操作是取到对应的 dSYM 和对应的二进制文件，然后拿到相应的崩溃日志 uuid 、二进制的 uuid、dSYM 的 uuid 通过命令行来解析。这些操作感觉比较耗时。下面介绍几种情况下的快速解析的方法：</p><ul><li>1、自己设备上 Xcode 编译的包发生闪退：连上手机打开 Xcode，cmd+shift+2 呼出 Device 的 Window，如图1所示，然后点击 View Device Logs，然后选中对应时间段自己 app 的崩溃日志。如果此时对应的调用栈还没有符号化，可以选中日志后右键如图2所示 Re-Symbolicate Log 即可。</li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/10-1.jpg?raw=true" alt></p><ul><li><p>2、如果是打包服务器或者 Appstore 的包发生闪退：拷贝对应的包和 dSYM 到任意文件夹下，注意将 dSYM 解压以及 .ipa 里面的 .app 取出。然后按照情况1的方式处理即可，Xcode 会自动索引二进制及 dSYM。</p></li><li><p>3、如果拿到别的设备导出的未符号化的崩溃日志，可以将日志拖至图2所示的列表中，注意此时上面 tab 记得选 All Logs 而不是 This Device，然后参考情况2，找到崩溃日志对应的二进制包和 dSYM 文件，按照情况2处理即可。可能会遇到系统库的一些方法无法符号化的问题，只需要找到对应的设备连上电脑，让 Xcode 读取一遍该设备(同机型和系统版本的也可以)的符号表，然后再 Re-Symbolicate 一遍就行。</p></li><li><p>4、遇到线上用户崩溃，无法拿到完整崩溃日志，可以让用户到【设置-&gt;分析-&gt;分析数据】里面找到对应时间点的崩溃日志，然后截图，根据一个开源工具 <a href="https://github.com/answer-huang/dSYMTools" target="_blank" rel="noopener">dSYMTools</a>，把崩溃栈的关键地址输入到文本框中即可解析出崩溃的那个方法，具体使用方法参考 <a href="https://github.com/answer-huang/dSYMTools" target="_blank" rel="noopener">ReadMe</a>。</p></li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/10-2.jpg?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>是谁调了我的底层库</title>
      <link href="/2017/12/01/2017/12/shi-shui-diao-liao-wo-de-di-ceng-ku/"/>
      <url>/2017/12/01/2017/12/shi-shui-diao-liao-wo-de-di-ceng-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="是谁调了我的底层库"><a href="#是谁调了我的底层库" class="headerlink" title="是谁调了我的底层库"></a>是谁调了我的底层库</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>调试的时候，往往底层库会埋一些 <code>NSLog</code> 来调试，使用下面这种方式打印出来的函数名称 <code>__PRETTY_FUNCTION__</code> 是底层库的函数名。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#   <span class="token directive keyword">define</span> LEFLog(fmt, ...) NSLog((@"%s (%d) => " fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)</span></code></pre><p>打印是这样的：+[Network post] 中打印了 <code>I am a log</code>，而不清楚是谁调用了。</p><p><code>+[Network post] (22) =&gt; I am a log</code></p><p>但是，我想要的是我在最顶层调用时的函数名，这样我可以很容易的看到是那个方法调用了底层库。</p><p>不太理解？举个例子吧：<br>每个 APP 都会有一个网络层，业务层会直接与网络层进行交互。调试的时候，我想知道 A 请求是在哪个页面中的哪个函数被调用了，咋么办？前提是 <code>NSLog</code> 在底层库。我们可以这样实现：</p><pre class=" language-objc"><code class="language-objc">@implementation LEFLog+ (NSString *)lastCallMethod{    NSArray *symbols = [NSThread callStackSymbols];    NSInteger maxCount = symbols.count;    NSString *secondSymbol = maxCount > 2 ? symbols[2] : (maxCount > 1 ? symbols[1] : [symbols firstObject]);    if (secondSymbol.length == 0) {        return @"";    }    NSString *pattern = @"[+-]\\[.{0,}\\]";    NSError *error;    NSRegularExpression *express = [NSRegularExpression regularExpressionWithPattern:pattern options:kNilOptions error:&error];    if (error) {        NSLog(@"Error: %@", error);        return @"";    }    NSTextCheckingResult *checkResult = [[express matchesInString:secondSymbol options:NSMatchingReportCompletion range:NSMakeRange(0, secondSymbol.length)] lastObject];    NSString *findStr = [secondSymbol substringWithRange:checkResult.range];    return findStr ?: @"";}@end</code></pre><p>然后定义一个宏：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#   <span class="token directive keyword">define</span> LEFLog(fmt, ...) NSLog((@"%@, %s (%d) => " fmt), [LEFLog lastCallMethod], __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__</span></code></pre><p>打印结果是这样的：在 <code>LefexViewController</code>  中的 <code>viewDidLoad</code> 调用了 <code>Network</code> 的 <code>post</code> 方法，并打印 <code>I am a log</code>.</p><pre class=" language-objc"><code class="language-objc">-[LefexViewController viewDidLoad], +[Network post] (22) => I am a log</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>宏中的</title>
      <link href="/2017/12/01/2017/12/hong-zhong-de-de-han-yi/"/>
      <url>/2017/12/01/2017/12/hong-zhong-de-de-han-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="宏中的-的含义"><a href="#宏中的-的含义" class="headerlink" title="宏中的 ## 的含义"></a>宏中的 ## 的含义</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>在宏的定义中，我们也许会遇到过 <code>##</code>，比如下面是一些第三方库中 <code>##</code> 使用场景：</p><p>微信 WCDB 中的宏定义：<br><code>#define __WCDB_BINDING(className) _s_##className##_binding</code></p><p>唱吧 KTVHTTPCache 定义不同类中是否可以打印的例子：<br><code>#define KTVHCLogEnableValueConsoleLog(target)       KTVHCLog_##target##_ConsoleLogEnable</code></p><p>那 <code>##</code> 有什么用呢？<br><code>##</code> 在宏中的作用就是先分隔，然后进行强制连接。我们可能会定义不同的函数名或变量时就可以使用这样的宏定义。</p><p>那 <code>##</code> 是如何工作的呢？</p><ol><li><p><code>__WCDB_BINDING(className)</code> ，首先 <code>_s_##className##_binding</code> 会拆分成 <code>_s</code>,<code>className</code>,<code>_binding</code>。__WCDB_BINDING(ViewController) 将会被替换成 <code>_s_ViewController_binding</code>；</p></li><li><p><code>KTVHCLogEnableValueConsoleLog(target)</code>，首先 <code>KTVHCLog_##target##_ConsoleLogEnable</code> 会被拆分为 <code>KTVHCLog_</code>, <code>target</code> 和 <code>_ConsoleLogEnable</code>。KTVHCLogEnableValueConsoleLog(Lefex) 会被替换成 <code>KTVHCLog_ Lefex_ConsoleLogEnable</code>；</p></li></ol><p>3.当使用 KTVHCLogEnable(HTTPServer, YES) ，将会定义一个名为 <code>KTVHCLog_ HTTPServer_ConsoleLogEnable</code> 静态常量，初始值为 YES。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> KTVHCLogEnable(target, console_log_enable)               \static BOOL const KTVHCLog_##target##_ConsoleLogEnable = console_log_enable;        \</span></code></pre><p>比如我们使用不同的 View 名字创建不同的 View：</p><pre class=" language-objc"><code class="language-objc">#define Name(target) weibo_##target##_name#define View(target) view##target##Label@implementation ViewController- (void)viewDidLoad {    [super viewDidLoad];    NSString * Name(lefex) = @"Lefe_x";    // 打印：You weibo name is: Lefe_x    NSLog(@"You weibo name is: %@", weibo_lefex_name);    UILabel *View(1) = [UILabel new];    view1Label.backgroundColor = [UIColor redColor];    UIView *View(2) = [UIView new];    view2Label.backgroundColor = [UIColor yellowColor];}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为断点加条件和简单命令</title>
      <link href="/2017/12/01/2017/12/wei-duan-dian-jia-tiao-jian-he-jian-dan-ming-ling/"/>
      <url>/2017/12/01/2017/12/wei-duan-dian-jia-tiao-jian-he-jian-dan-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="为断点加条件和简单命令"><a href="#为断点加条件和简单命令" class="headerlink" title="为断点加条件和简单命令"></a>为断点加条件和简单命令</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>今天主要给大家介绍一个如何给断点加条件和命令来提高我们的调试效率。例如：一个for循环，在第n次循环的时候有一个bug，这个时候条件断点就有了用武之地，通过右击断点，选择编辑断点；</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/6-1.jpg?raw=true" alt></p><p>我们可以设置<code>Condition：i= n</code>，直接断到我们想要调试的那次循环；</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/6-2.jpg?raw=true" alt></p><p>或者也可以用<code>Ignore</code>功能来设置忽略前面不关心的循环；</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/6-3.jpg?raw=true" alt></p><p>通过设置Action功能还可以在断点处执行一些简单的命令、打印日志、播放声音、执行脚本等，</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/6-4.jpg?raw=true" alt></p><p>让调试变的欢乐起来吧！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>objc_getClass和object_getClass</title>
      <link href="/2017/12/01/2017/12/objc-getclass-he-object-getclass/"/>
      <url>/2017/12/01/2017/12/objc-getclass-he-object-getclass/</url>
      
        <content type="html"><![CDATA[<h2 id="objc-getClass和object-getClass"><a href="#objc-getClass和object-getClass" class="headerlink" title="objc_getClass和object_getClass"></a>objc_getClass和object_getClass</h2><p><strong>作者</strong>: <a href="https://weibo.com/touristdiary" target="_blank" rel="noopener">南峰子_老驴</a></p><p>昨天打开好久没开的公众号后台，看到一个小伙伴 <a href="https://weibo.com/u/5848750701" target="_blank" rel="noopener">@阳光下的小泡沫星人002</a> 给我留言，指正我之前写的关于Runtime的<a href="http://southpeak.github.io/2014/10/25/objective-c-runtime-1/" target="_blank" rel="noopener">文章</a> 中一个错误之处，并为此写了一篇<a href="http://www.jianshu.com/p/d0c6a3efb4d4" target="_blank" rel="noopener">文章</a> 在此感谢。</p><p>这个错误是关于获取 <code>NSObject</code> 的元类的 <code>isa</code> 指针的问题。在我的文章中，错误的用 <code>objc_getClass((__bridge void *)[NSObject class])</code> 这种方式来获取对象的指针。代码如下：</p><pre class=" language-objc"><code class="language-objc">void TestMetaClass(id self, SEL _cmd) {    NSLog(@"This objcet is %p", self);    NSLog(@"Class is %@, super class is %@", [self class], [self superclass]);    Class currentClass = [self class];    for (int i = 0; i < 4; i++) {        NSLog(@"Following the isa pointer %d times gives %p", i, currentClass);        currentClass = objc_getClass((__bridge void *)currentClass);    }    NSLog(@"NSObject's class is %p", [NSObject class]);    NSLog(@"NSObject's meta class is %p", objc_getClass((__bridge void *)[NSObject class]));  // 0x0}</code></pre><p>实际上 <code>objc_getClass</code> 的参数是类名的字符串，获取指定类的类对象。上述代码中 <code>(__bridge void *)[NSObject class])</code> 的结果并不是类名的字符串，而是一个对象的指针，所以 <code>objc_getClass</code> 函数返回值的相当于是一个 <code>nil</code>，打印指针的值就是 <code>0x0</code>。所以正确使用 <code>objc_getClass</code> 的方式应该是<code>objc_getClass(&quot;NSObject&quot;)</code>，其效果与 <code>[NSObject class]</code> 是一样的。</p><p>要想获取 <code>NSObject</code> 类对象的元类，可以使用 <code>object_getClass</code> 函数。这个函数参数是 <code>id</code> 类型，即一个对象，返回对象的 <code>Class</code> 信息，即对象的 <code>isa</code> 指针；如果传入的是一个类对象，获取的就是元类信息。</p><p>所以正确的代码如下，<code>for</code> 循环中的输出结果也印证了 <code>NSObject</code> 元类的isa指向的是其本身。</p><pre class=" language-objc"><code class="language-objc">void TestMetaClass(id self, SEL _cmd) {    NSLog(@"This objcet is %p", self);    NSLog(@"Class is %@, super class is %@", [self class], [self superclass]);    Class currentClass = [self class];    for (int i = 0; i < 4; i++) {        NSLog(@"Following the isa pointer %d times gives %p", i, currentClass);        currentClass = object_getClass(currentClass);    }    // Following the isa pointer 0 times gives 0x10048e1f0    // Following the isa pointer 1 times gives 0x10048e220    // Following the isa pointer 2 times gives 0x7fff8c8e50f0    // Following the isa pointer 3 times gives 0x7fff8c8e50f0    NSLog(@"NSObject's class is %p", [NSObject class]);    NSLog(@"NSObject's meta class is %p", object_getClass([NSObject class]));          // NSObject's class is 0x7fff8c8e5140    // NSObject's meta class is 0x7fff8c8e50f0}</code></pre><p>由于博客已停更，错误之处可以在微博上私信。还请阅读的时候不要盲从。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>指定构造器在 UITableViewController 中的坑</title>
      <link href="/2017/12/01/2017/12/zhi-ding-gou-zao-qi-zai-uitableviewcontroller-zhong-de-keng/"/>
      <url>/2017/12/01/2017/12/zhi-ding-gou-zao-qi-zai-uitableviewcontroller-zhong-de-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="指定构造器在-UITableViewController-中的坑"><a href="#指定构造器在-UITableViewController-中的坑" class="headerlink" title="指定构造器在 UITableViewController 中的坑"></a>指定构造器在 UITableViewController 中的坑</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>我们都知道，如果我们想要自定义指定构造器时，应该要遵循以下3个原则(图1)：<br>1、子类指定构造器必须调用父类指定构造器<br>2、便捷构造器只能通过调用自身指定构造器来完成初始化<br>3、指定构造器必须要用 <code>NS_DESIGNATED_INITIALIZER</code> 标示<br><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/5-1.jpg?raw=true" alt><br>但是如果你继承了 UITableViewController，并且自定义了指定构造器，而你的项目刚好要支持 iOS8 的话，在 iOS8 下就会出现一个必崩的 bug。示例代码及简单解释见图2。<br>有人提了对应的 <a href="http://www.openradar.me/23709930" target="_blank" rel="noopener">radar</a>， stackoverflow 上也有对应的<a href="https://stackoverflow.com/a/30719434" target="_blank" rel="noopener">详尽解释</a> 更多内容可<a href="http://t.cn/RX978vi" target="_blank" rel="noopener">查看</a><br>目前唯一的解决方案就是不继承 UITableViewController，而是继承自 UIViewController 然后持有一个 UITableView😂<br><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/5-2.jpg?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS中的mach_continuous_time()方法</title>
      <link href="/2017/12/01/2017/12/ios-zhong-de-mach-continuous-time-fang-fa/"/>
      <url>/2017/12/01/2017/12/ios-zhong-de-mach-continuous-time-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS中的mach-continuous-time-方法"><a href="#iOS中的mach-continuous-time-方法" class="headerlink" title="iOS中的mach_continuous_time()方法"></a>iOS中的mach_continuous_time()方法</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p><code>mach_absolute_time()</code> 这个函数大家应该比较了解：返回的是CPU已经运行的时钟周期数，可以转化为秒数，这个是不会受本地时间影响的，不过当手机重启会重新开始计数，锁屏休眠后会暂停计数。今天看文档惊喜的发现了 <code>iOS10</code> 之后提供了 <code>mach_continuous_time()</code> 方法：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/1-1.jpg?raw=true" alt></p><p>注释写的是：</p><blockquote><p>like mach_absolute_time, but advances during sleep</p></blockquote><p>突然感觉好惊喜，查看了一下源码：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/1-2.jpg?raw=true" alt></p><p>通过休眠测试（使用 <code>iPhone8+</code> , <code>iOS11</code> ,删除所有 <code>APP</code>, 关掉网络和蓝牙等，先运行 <code>demo</code> 获取一个时间，锁屏过了几个小时，再次获取时间)，结果果然可喜：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/1-3.jpg?raw=true" alt></p><p>不过重启后仍然会重置。顺便再介绍一下 <code>mach_approximate_time()</code>，是获取一个大约时间，暂时没有用过，可以简单看下源码：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/1-4.jpg?raw=true" alt></p><p>比较好理解。希望能帮助到大家！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift 4.0 中 Dictionary 编码成类数组结构的字符串</title>
      <link href="/2017/12/01/2017/12/swift-4.0-zhong-dictionary-bian-ma-cheng-lei-shu-zu-jie-gou-de-zi-fu-chuan/"/>
      <url>/2017/12/01/2017/12/swift-4.0-zhong-dictionary-bian-ma-cheng-lei-shu-zu-jie-gou-de-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift-4-0-中-Dictionary-编码成类数组结构的字符串"><a href="#Swift-4-0-中-Dictionary-编码成类数组结构的字符串" class="headerlink" title="Swift 4.0 中 Dictionary 编码成类数组结构的字符串"></a>Swift 4.0 中 Dictionary 编码成类数组结构的字符串</h2><p>在Swift 4.0中，使用<code>Codable</code>来编码一个<code>Dictionary</code>时，某些情况下得到的可能并不是类似于字典/对象结构的字符串，而可能是一个类似数组结构的字符串，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> dict<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Float</span> <span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token number">18.0</span><span class="token punctuation">:</span> <span class="token string">"ff0000"</span><span class="token punctuation">,</span>    <span class="token number">20.0</span><span class="token punctuation">:</span> <span class="token string">"00ff00"</span><span class="token punctuation">,</span>    <span class="token number">21.0</span><span class="token punctuation">:</span> <span class="token string">"0000ff"</span><span class="token punctuation">]</span><span class="token keyword">let</span> encoder <span class="token operator">=</span> <span class="token function">JSONEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>encoder<span class="token punctuation">.</span>outputFormatting <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>prettyPrinted<span class="token punctuation">,</span> <span class="token punctuation">.</span>sortedKeys<span class="token punctuation">]</span><span class="token keyword">let</span> encoded <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">!</span> encoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token keyword">let</span> jsonText <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>decoding<span class="token punctuation">:</span> encoded<span class="token punctuation">,</span> <span class="token keyword">as</span><span class="token punctuation">:</span> <span class="token builtin">UTF8</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>jsonText<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[</span><span class="token comment" spellcheck="true">//  21,</span><span class="token comment" spellcheck="true">//  "0000ff",</span><span class="token comment" spellcheck="true">//  18,</span><span class="token comment" spellcheck="true">//  "ff0000",</span><span class="token comment" spellcheck="true">//  20,</span><span class="token comment" spellcheck="true">//  "00ff00"</span><span class="token comment" spellcheck="true">//]</span></code></pre><p>这里的<code>dict</code>以<code>Float</code>类型为<code>key</code>，结果是输出一个类似数组的字符串。查看源码中<code>Dictionary</code>对<code>Encodable</code>协议的扩展实现，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token builtin">Dictionary</span> <span class="token punctuation">:</span> <span class="token builtin">Encodable</span> <span class="token comment" spellcheck="true">/* where Key : Encodable, Value : Encodable */</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function">encode</span><span class="token punctuation">(</span>to encoder<span class="token punctuation">:</span> <span class="token builtin">Encoder</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token punctuation">{</span>        <span class="token function">assertTypeIsEncodable</span><span class="token punctuation">(</span><span class="token builtin">Key</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">,</span> <span class="token keyword">in</span><span class="token punctuation">:</span> <span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">assertTypeIsEncodable</span><span class="token punctuation">(</span><span class="token builtin">Value</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">,</span> <span class="token keyword">in</span><span class="token punctuation">:</span> <span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">Key</span><span class="token punctuation">.</span><span class="token keyword">self</span> <span class="token operator">==</span> <span class="token builtin">String</span><span class="token punctuation">.</span><span class="token keyword">self</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Since the keys are already Strings, we can use them as keys directly.</span>            <span class="token keyword">var</span> container <span class="token operator">=</span> encoder<span class="token punctuation">.</span><span class="token function">container</span><span class="token punctuation">(</span>keyedBy<span class="token punctuation">:</span> _DictionaryCodingKey<span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>                <span class="token keyword">let</span> codingKey <span class="token operator">=</span> <span class="token function">_DictionaryCodingKey</span><span class="token punctuation">(</span>stringValue<span class="token punctuation">:</span> key <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token operator">!</span>                <span class="token keyword">try</span> <span class="token punctuation">(</span>value <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">Encodable</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">__encode</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token operator">&amp;</span>container<span class="token punctuation">,</span> forKey<span class="token punctuation">:</span> codingKey<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token builtin">Key</span><span class="token punctuation">.</span><span class="token keyword">self</span> <span class="token operator">==</span> <span class="token builtin">Int</span><span class="token punctuation">.</span><span class="token keyword">self</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Since the keys are already Ints, we can use them as keys directly.</span>            <span class="token keyword">var</span> container <span class="token operator">=</span> encoder<span class="token punctuation">.</span><span class="token function">container</span><span class="token punctuation">(</span>keyedBy<span class="token punctuation">:</span> _DictionaryCodingKey<span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>                <span class="token keyword">let</span> codingKey <span class="token operator">=</span> <span class="token function">_DictionaryCodingKey</span><span class="token punctuation">(</span>intValue<span class="token punctuation">:</span> key <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token operator">!</span>                <span class="token keyword">try</span> <span class="token punctuation">(</span>value <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">Encodable</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">__encode</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token operator">&amp;</span>container<span class="token punctuation">,</span> forKey<span class="token punctuation">:</span> codingKey<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Keys are Encodable but not Strings or Ints, so we cannot arbitrarily convert to keys.</span>            <span class="token comment" spellcheck="true">// We can encode as an array of alternating key-value pairs, though.</span>            <span class="token keyword">var</span> container <span class="token operator">=</span> encoder<span class="token punctuation">.</span><span class="token function">unkeyedContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">(</span>key <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">Encodable</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">__encode</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token operator">&amp;</span>container<span class="token punctuation">)</span>                <span class="token keyword">try</span> <span class="token punctuation">(</span>value <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">Encodable</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">__encode</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token operator">&amp;</span>container<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到当 <code>key</code> 的类型为 <code>String</code> 和 <code>Int</code> 时，使用 <code>_DictionaryCodingKey</code> 来编码 <code>key</code>，进而编码 <code>key-value</code> 对，最后以类似字典的结构输出(依赖于 <code>keyed container</code> )，这是因为在 <code>Codable</code> 系统中，这两个类型是有效的可编码 <code>key</code> 类型；而其它类型则不是，由于 <code>Dictionary</code> 无法告诉其它类型如何编码自身，所以将这些值 <code>key</code> 存储在一个 <code>unkeyed container</code> 中，最终处理成一个数组。</p><p>参考：</p><ol><li><a href="https://developer.apple.com/documentation/swift/unkeyedencodingcontainer" target="_blank" rel="noopener">UnkeyedEncodingContainer</a></li><li><a href="https://oleb.net/blog/2017/12/dictionary-codable-array/" target="_blank" rel="noopener">Why Dictionary sometimes encodes itself as an array</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SourceTree 搭配 Kaleidoscope 进行 Code Review</title>
      <link href="/2017/12/01/2017/12/sourcetree-da-pei-kaleidoscope-jin-xing-code-review/"/>
      <url>/2017/12/01/2017/12/sourcetree-da-pei-kaleidoscope-jin-xing-code-review/</url>
      
        <content type="html"><![CDATA[<h2 id="SourceTree-搭配-Kaleidoscope-进行-Code-Review"><a href="#SourceTree-搭配-Kaleidoscope-进行-Code-Review" class="headerlink" title="SourceTree 搭配 Kaleidoscope 进行 Code Review"></a>SourceTree 搭配 Kaleidoscope 进行 Code Review</h2><p>平时在 <code>Gitlab</code>、<code>GitHub</code>、<code>SourceTree</code> 上进行 <code>CodeReview</code> 的时候，只能看到发生改动的地方，想要查看改动点对应的上下文时非常麻烦(网页上要不断的点展开)。今天给大家介绍一个我们小组内 <code>CodeReview</code> 时用到的工具及其配置，如果你有其它方式，欢迎一起交流探讨。确保配置前已安装好 <code>SourceTree</code> 以及 <code>Kaleidoscope</code>，配置方式如下</p><ul><li>点击 <code>Kaleidoscope</code> 菜单 –&gt; 点击 <code>Integration</code> –&gt; 下载 <code>ksdiff</code>（点击 <code>Read More</code>）</li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/7-1.jpg?raw=true" alt></p><ul><li><p>安装完成之后，删除 <code>~/.gitconfig</code> 文件中 <code>difftool</code> 与 <code>mergetool</code> 相关配置（删之前最好备份一下原文件）</p></li><li><p>打开 <code>SourceTree</code> 的偏好设置，按下图的方式配置。两处 <code>Command</code> 都填 <code>/usr/local/bin/ksdiff</code>，<code>Argument</code> 分别为 <code>--partial-changeset --relative-path &quot;$MERGED&quot; -- &quot;$LOCAL&quot; &quot;$REMOTE&quot;</code> 、<code>--merge --output &quot;$MERGED&quot; --base &quot;$BASE&quot; -- &quot;$LOCAL&quot; --snapshot &quot;$REMOTE&quot; --snapshot</code>。这两个参数也可以按自己的需求来配置。</p></li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/7-2.jpg?raw=true" alt></p><ul><li>以上设置完成之后可以给 <code>SourceTree</code> 加一个自定义动作，快捷键按自己的喜好设置，参数项填 <code>difftool -y -t sourcetree $SHA HEAD</code> 即可。</li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/7-3.jpg?raw=true" alt></p><p>以上配置完成之后就大功告成了，使用方式就是在 <code>SourceTree</code> 中选中一个非 <code>HEAD</code> 的 <code>commit</code>，然后按下快捷键，就会在 <code>Kaleidoscope</code> 打开所有改动过的文件。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/7-4.jpg?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gerrit 是阻挡不了你使用 SourceTree</title>
      <link href="/2017/12/01/2017/12/gerrit-shi-zu-dang-bu-liao-ni-shi-yong-sourcetree/"/>
      <url>/2017/12/01/2017/12/gerrit-shi-zu-dang-bu-liao-ni-shi-yong-sourcetree/</url>
      
        <content type="html"><![CDATA[<h2 id="Gerrit-是阻挡不了你使用-SourceTree"><a href="#Gerrit-是阻挡不了你使用-SourceTree" class="headerlink" title="Gerrit 是阻挡不了你使用 SourceTree"></a>Gerrit 是阻挡不了你使用 SourceTree</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>当我们提交的代码需要 Review 的时候，需要用到 Gerrit，具体关于 Gerrit 的介绍可以看 [这里]<br>(<a href="https://gerrit-review.googlesource.com/Documentation/" target="_blank" rel="noopener">https://gerrit-review.googlesource.com/Documentation/</a>) 。使用 Gerrit 后，执行 <code>push</code> 操作的时候，不能直接使用 <code>git push</code> 命令，也就说你不能使用 <code>SourceTree</code> 的 <code>Push</code> 功能，只能在终端乖乖的输入 <code>git push origin HEAD:refs/for/dev</code> 。有些同学可能会问，我特别想使用 <code>SourceTree</code> ，不想使用终端命令，有没有好的方法？其实，<code>SourceTree</code> 提供了一个功能：【自定义操作】（SourceTree – 偏好设置 – 自定义操作 – 添加），导入事先写好的脚本。还可以设置一个快捷键（这里设置了 cmd+p）。脚本如下：</p><pre><code>#!/bin/bashcd /Users/wangsuyan/Desktop/iOSgit push origin HEAD:refs/for/Dev0.0.1</code></pre><p>备注：记得给脚本执行权限。<br>如果你没有给自定义的操作设置快捷键，可以通过【动作 – 自定义操作】选择执行你的 Action。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/3-1.jpg?raw=true" alt></p><p>这样，当你 push 的时候直接 <code>cmd+p</code> 即可提交你的代码，是不是很爽。当然你可以写一些其它的脚本，并自定义为 Action ，来提高你的工作效率。你可以看我以前写的 [脚本教程] (<a href="http://www.jianshu.com/p/8a975f358de8" target="_blank" rel="noopener">http://www.jianshu.com/p/8a975f358de8</a>) 。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CoreAnimation 与 pop 的对比</title>
      <link href="/2017/12/01/2017/12/coreanimation-yu-pop-de-dui-bi/"/>
      <url>/2017/12/01/2017/12/coreanimation-yu-pop-de-dui-bi/</url>
      
        <content type="html"><![CDATA[<h2 id="CoreAnimation-与-pop-的对比"><a href="#CoreAnimation-与-pop-的对比" class="headerlink" title="CoreAnimation 与 pop 的对比"></a>CoreAnimation 与 pop 的对比</h2><p>最近在 <code>Medium</code> 上看到一篇《Should you use POP?》的文章，文章主要通过以下几个方面来对比了 <code>pop</code> 和 <code>Core Animation</code>。</p><ul><li><p><code>Core Animation</code> 工作原理：每次添加动画时 <code>QuartzCore</code> 会打包其参数，然后通过进程间通信的方式传递给一个名为 <code>backboardd</code> 的后台进程。然后该进程通过 <code>OpenGL</code> 渲染和处理 <code>layer</code> 的层级以及 <code>layer</code> 上的动画。最重要的一点就是该进程完全独立于你的应用，应用只会拿到动画开始和结束的回调（<code>CAAnimationDelegate</code>），不负责动画的渲染（显式动画除外）。也就是主线程和 <code>CoreAnimation</code> 不会互相影响，也就是即使主线程阻塞了，<code>CoreAnimation</code> 依旧在执行。</p></li><li><p><code>pop</code> 的工作原理：使用 <code>CADisplayLink</code> 来开启一个 <code>fps=60</code> 的渲染工作。每当 <code>CADisplayLink</code> 回调触发时，更新一下动画的进度。也就是每一帧发生改变时都需要通知 <code>backboardd</code> 来渲染，因为它对于 <code>layer</code> 的变化并不知情。</p></li><li><p>由于 <code>pop</code> 必须在主线程上处理动画，所以 <code>pop</code> 动画很有可能发生卡顿。作者写了一个 <code>Demo</code> 来演示对应效果，效果如下图，左边为 <code>Core Animation</code> 的方式，右边为 <code>pop</code> 的方式。</p></li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/9-1.gif?raw=true" alt></p><ul><li>作者对比了 <code>Core Animation</code> 和 <code>pop</code> 的性能。同样动画效果情况下(运行10s)，使用 <code>Time Profiler</code> 看 <code>backboardd</code> (<code>CoreAnimation</code>) 和应用(<code>pop</code>) <code>CPU</code> 消耗，<code>iPhone4 iOS7.1.2</code> 和 <code>iPhone6 iOS8.1.1</code> 的对比结果下图所示（左边 <code>iPhone4</code>，右边 <code>iPhone6</code>）。可以看出两者 <code>backboardd</code> 进程的 <code>CPU</code> 耗时差别在 <code>100ms</code> 左右，但是应用的 <code>CPU</code> 耗时差距十分明显，<code>Core Animation</code> 应用 <code>CPU</code> 耗时接近于0。</li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/9-2.jpg?raw=true" alt></p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/9-3.jpg?raw=true" alt></p><ul><li>结论如下图所示。<code>Core Animation</code> 优点为：①单独进程运行 ②不会阻塞主线程。缺点为：①复杂动画效果要写冗长的代码 ②手势驱动动画比较复杂。 <code>pop</code> 的优点为：①丰富的 API ②内置很多的动画 缺点为：①在主线程上执行 ②动画过程可能卡顿 ③消耗更高的 <code>CPU</code></li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/12/9-4.jpg?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>判断代码在哪个队列中运行</title>
      <link href="/2017/11/01/2017/11/pan-duan-dai-ma-zai-na-ge-dui-lie-zhong-yun-xing/"/>
      <url>/2017/11/01/2017/11/pan-duan-dai-ma-zai-na-ge-dui-lie-zhong-yun-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="判断代码在哪个队列中运行"><a href="#判断代码在哪个队列中运行" class="headerlink" title="判断代码在哪个队列中运行"></a>判断代码在哪个队列中运行</h2><p>之前分享了可以用<code>dispatch_queue_set_specific</code>和<code>dispatch_get_specific</code>来判断代码是否运行在主队列上。除了这种方法外，还可以使用<code>dispatch_queue_get_label</code>获取当前队列的<code>label</code>，与主队列的<code>label</code>比较，如图代码所示：</p><pre class=" language-objc"><code class="language-objc">- (void)viewDidLoad {    [super viewDidLoad];    NSLog(@"%d", [self isMainQueue]);       // 1    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{        NSLog(@"%d", [self isMainQueue]);   // 0    });}- (BOOL)isMainQueue {    return strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0;}</code></pre><p>主队列的<code>label</code>是<code>com.apple.main-thread</code>。当然也可以用这种方式来判断其它队列。全局队列的<code>label</code>与其<code>QOS</code>类型相关，<code>label</code>值主要有以下几个：</p><pre class=" language-objc"><code class="language-objc">com.apple.root.user-interactive-qos //com.apple.root.user-initiated-qos   // DISPATCH_QUEUE_PRIORITY_HIGHcom.apple.root.default-qos          // DISPATCH_QUEUE_PRIORITY_DEFAULTcom.apple.root.utility-qos          // DISPATCH_QUEUE_PRIORITY_LOWcom.apple.root.background-qos       // DISPATCH_QUEUE_PRIORITY_BACKGROUND</code></pre><p>我们可以使用<code>dispatch_get_global_queue(qos_class_self(), 0)</code>来获取代码所在的的全局队列，进而获取其<code>label</code>值。</p><p>参考</p><ol><li><a href="https://stackoverflow.com/questions/17475002/get-current-dispatch-queue" target="_blank" rel="noopener">Get current dispatch queue?</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>判断子类是否实现父类的方法</title>
      <link href="/2017/11/01/2017/11/pan-duan-zi-lei-shi-fou-shi-xian-fu-lei-de-fang-fa/"/>
      <url>/2017/11/01/2017/11/pan-duan-zi-lei-shi-fou-shi-xian-fu-lei-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="判断子类是否实现父类的方法"><a href="#判断子类是否实现父类的方法" class="headerlink" title="判断子类是否实现父类的方法"></a>判断子类是否实现父类的方法</h2><p>想在程序运行时判断一个子类是否实现了父类的某个方法，可以比较两个类对应方法的指针是否相等。以 <code>-init</code> 方法为例，如下代码所示:</p><pre class=" language-objc"><code class="language-objc">@interface Test: NSObject@end@implementation Test@endBOOL check() {    SEL sel = @selector(init);    IMP baseInit = [NSObject instanceMethodForSelector:sel];    IMP testInit = [Test instanceMethodForSelector:sel];    return baseInit == testInit;}NSLog(@"%@", check() ? @"true" : @"false");            // true</code></pre><p>按照 <code>Objective-C</code> 查找方法的规则，对象会先在自己的方法列表中查找，如果有，则调用；如果没有，则向上去父类里面查找，依此一直到 <code>NSObject</code>。</p><p>需要注意的是，如果是多层继承体系，即使某个子类没有实现某个方法，也不能确定这个子类和某个父类是同一个实现，如下代码所示：</p><pre class=" language-objc"><code class="language-objc">@interface Base: NSObject@end@implementation Base- (id)init {    return [super init];}@end@interface Test: Base@end@implementation Test@endBOOL check() {    SEL sel = @selector(init);    IMP baseInit = [NSObject instanceMethodForSelector:sel];    IMP testInit = [Test instanceMethodForSelector:sel];    return baseInit == testInit;    }NSLog(@"%@", check() ? @"true" : @"false");         // false</code></pre><p><a href="https://m.weibo.cn/u/2623148742" target="_blank" rel="noopener">ParsifalC</a>童鞋之前也分享过相关的内容，提供了几种方法，具体可以参考<a href="https://m.weibo.cn/status/4087697620330623" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用Attach方式调试推送、Today、3DTouch</title>
      <link href="/2017/11/01/2017/11/li-yong-attach-fang-shi-diao-shi-tui-song-today-3dtouch/"/>
      <url>/2017/11/01/2017/11/li-yong-attach-fang-shi-diao-shi-tui-song-today-3dtouch/</url>
      
        <content type="html"><![CDATA[<h2 id="利用Attach方式调试推送、Today、3DTouch"><a href="#利用Attach方式调试推送、Today、3DTouch" class="headerlink" title="利用Attach方式调试推送、Today、3DTouch"></a>利用Attach方式调试推送、Today、3DTouch</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p>在调试推送、<code>Today</code>、<code>3DTouch</code> 等唤起测试 App 的时候（此时App未启动），我们通常 <code>Run</code> 的方式是不行的，因为 <code>Run</code> 后 <code>App</code> 就启动了，不满足调试环境。<code>Xcode</code> 为我们提供了 <code>Attach</code> 的方式进行调试，使用起来也是超简单的。操作方式如下：</p><p>前提：已经加了断点（比如 <code>application: didFinishLaunchingWithOptions:</code> 方法里加断点）</p><ul><li><p><code>Attach</code> 之前需要把测试 <code>App</code> 的进程杀掉（如果不杀掉进程，这种方式是无法断点调试的）；</p></li><li><p>选择你要 <code>Attach</code> 的测试 <code>App</code> ,有两种方式：在 <code>Debug</code> 下拉菜单下面有 <code>Attach to Process</code> 选项（直接选择你的测试 <code>App</code>，如图1）和 <code>Attach to Process by PID or Name</code> 选项（输入名称，如图2）；</p></li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/15-1.jpg?raw=true" alt="15-1"></p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/15-2.jpg?raw=true" alt="15-2"></p><ul><li>用推送、<code>Today</code>、<code>3DTouch</code> 等方式唤起，就大功告成了，如下图所示</li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/15-2.jpg?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git恢复被删除的Stash代码</title>
      <link href="/2017/11/01/2017/11/git-hui-fu-bei-shan-chu-de-stash-dai-ma/"/>
      <url>/2017/11/01/2017/11/git-hui-fu-bei-shan-chu-de-stash-dai-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="Git恢复被删除的Stash代码"><a href="#Git恢复被删除的Stash代码" class="headerlink" title="Git恢复被删除的Stash代码"></a>Git恢复被删除的Stash代码</h2><p><strong>作者</strong>: <a href="https://weibo.com/517082456" target="_blank" rel="noopener">高老师很忙</a></p><p><code>Git</code> 的 <code>Stash</code> 功能很方便的帮我们存一些临时代码，如果不小心把 <code>Stash</code> 代码删除了如何恢复呢？使用 <code>git fsck --lost-found</code> 查看我们最近删除的 <code>Stash</code> ；找到你需要恢复的 <code>dangling commit</code>（只需关注 <code>dangling commit</code> ）；再使用 <code>git merge</code> 命令即可恢复。如下两图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/12-1.jpg?raw=true" alt></p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/12-2.jpg?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NSFetchedResultsController兼容性问题</title>
      <link href="/2017/11/01/2017/11/nsfetchedresultscontroller-jian-rong-xing-wen-ti/"/>
      <url>/2017/11/01/2017/11/nsfetchedresultscontroller-jian-rong-xing-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="NSFetchedResultsController兼容性问题"><a href="#NSFetchedResultsController兼容性问题" class="headerlink" title="NSFetchedResultsController兼容性问题"></a>NSFetchedResultsController兼容性问题</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>熟悉 <code>CoreData</code> 的都知道 <code>NSFetchedResultsController</code> 这个类，与 <code>tableView</code> 和 <code>collectionView</code> 结合起来使用非常方便。</p><p>但是这个类在 <code>iOS10</code> 中有个比较坑爹的地方，如果使用的是下图的方式初始化</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/18-1.jpg?raw=true" alt></p><p>并且传入的 <code>cacheName</code> 不为 <code>nil</code>，那么在 <code>iOS10</code> 下面可能会产生各种莫名其妙的崩溃。详细原因如下图描述：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/18-2.jpg?raw=true" alt></p><p>简单翻译一下就是：修改了 <code>vc</code> 的 <code>fetchRequest</code> 之后，<code>context</code> 的 <code>save</code> 操作会打开一个或多个文件描述符，当打开的文件描述符数目超过<code>255</code>(真机)后，后续的资源加载都会导致崩溃。</p><p>当初遇到这个问题的时候，整个应用都处于随机崩溃的情况，看日志都是加载 <code>storyboard</code> 或者 <code>xib</code> 等资源时的崩溃，但是死活复现不出来，看崩溃日志也找不到原因。然后无意间发现 <code>Xcode console</code> 中一直不断输出如下警告信息：</p><pre class=" language-objc"><code class="language-objc">(NSFetchedResultsController): couldn't read cache file to update store info timestamps</code></pre><p>然后 google 了一下，找到了一个相同的问题，并且有完整的复现 <code>Demo</code> 及复现步骤，然后全局代码搜索果然发现有一个地方初始化的时候传入了 <code>cacheName</code>，将其置 <code>nil</code> 后就再也没有那段 <code>warning</code> 同时上线之后也没有再收到资源加载的崩溃了。</p><p>所以 <code>Xcode</code> 的 <code>warning</code> 还是值的注意的。附上这个 <code>radar</code> 的<a href="http://www.openradar.me/28361550" target="_blank" rel="noopener">链接</a>，里面包含 <code>Demo</code> 地址。</p><p>今天再去复现的时候，试了两台 <code>iOS10</code> 的设备，<code>Xcode 9.1</code> 下 <code>iPhone5S iOS10.2</code> 这个 bug 已经不存在了，但是 <code>iPhone7 iOS10.0</code> 还是存在的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift总结</title>
      <link href="/2017/11/01/2017/11/rxswift-zong-jie/"/>
      <url>/2017/11/01/2017/11/rxswift-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="RxSwift总结"><a href="#RxSwift总结" class="headerlink" title="RxSwift总结"></a>RxSwift总结</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p><code>ReactiveX</code>（<code>Reactive Extensions</code>）是通过可观察的流实现异步编程的一种<code>API</code>，它结合了观察者模式、迭代器模式和函数式编程的精华。<code>RxSwift</code>是<code>ReactiveX</code>编程思想的一种实现，几乎每一种语言都会有那么一个<code>Rx[xxxx]</code>框架，比如 <code>RxJava</code>，<code>RxJS</code> 等。Rx 可以概括为，对某些数据流（很广，可以是一些事件等）进行处理，使其变成可观察对象（<code>Observable</code>）序列，这样观察者（<code>observer</code>）就可以订阅这些序列【观察者模式】。然而对于订阅者来说（<code>observer</code>）某些选项（<code>items</code>）并不是自己需要的（需要过滤），某些选项（<code>items</code>）需要转换才能达到自己的目的【操作符 <code>filter</code>, <code>map</code> 等】。为了提升用户体验，或其它目的，有些操作需要放到特定的线程去执行，比如 UI 操作需要放到主线程，这就涉及到了调度器【调度器 <code>Scheduler</code>】。所以Rx可以这样概括，<code>Rx = Observables + LINQ + Schedulers</code>，其中 <code>LINQ（Language Integrated Query）</code>语言集成查询，比如那些操作符号。</p><p>下图是 <code>RxSwift</code> 的简单的应用，从数组中找出 <code>Lefe_x</code> 并显示到 <code>Label</code> 上。</p><pre class=" language-Swift"><code class="language-Swift">override func viewDidLoad() {  super.viewDidLoad()  DispatchQueue.global().async {      self.from()  }}func from() {  Observable.from(["Lefe", "Lefe_x", "lefex", "wsy", "Rx"])     .subscribeOn(MainScheduler.instance)     .filter({ (text) -> Bool in    return text == "Lefe_x"     })     .map({ (text) -> String in    return "我的新浪微博是: " + text     })     .subscribe(onNext: { [weak self] (text) in    self?.nickNameLabel.text = text     })     .disposed(by: disposeBag)}</code></pre><p>流程如下图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/1-2.JPG?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本在iOS中的应用</title>
      <link href="/2017/11/01/2017/11/shell-jiao-ben-zai-ios-zhong-de-ying-yong/"/>
      <url>/2017/11/01/2017/11/shell-jiao-ben-zai-ios-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="Shell脚本在iOS中的应用"><a href="#Shell脚本在iOS中的应用" class="headerlink" title="Shell脚本在iOS中的应用"></a>Shell脚本在iOS中的应用</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>使用 Pod 的同学经常会遇到 <code>&quot;error: The sandbox is not in sync with the Podfile.lock. Run &#39;pod install&#39; or update your CocoaPods installation.&quot;</code> 错误，如下图所示。其实是 <code>[CP] Check Pods Manifest.lock</code> 这个脚本所起的作用。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/5-1.PNG?raw=true" alt></p><p>Pod 中有 <code>Manifest.lock</code> 和 <code>Podfile.lock</code> 这两个文件，只要这两个文件的内容不一样就会报错上面这个错误。<code>Podfile.lock</code> 是大家共用的文件（用来保证我们每个人的Pod库版本一样），而 <code>Manifest.lock</code> 是本地的文件（自己用）。下图中这个脚本正是做这样的事情。</p><pre class=" language-shell"><code class="language-shell">diff "${PODS_PODFILE_DIR_PATH}/Podfile.lock" "${PODS_ROOT}/Manifest.lock" > /dev/nullif [ $? != 0 ] ; then    # print error to STDERR    echo "error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation." >&2    exit 1fi# This output is used by Xcode 'outputs' to avoid re-running this script phase.echo "SUCCESS" > "${SCRIPT_OUTPUT_FILE_0}"</code></pre><p><strong>解释下这个脚本</strong></p><p><code>shell</code> 脚本总是以：<code>#!/bin/bash</code> 或者 <code>#!/bin/sh</code> 开头，它主要告诉系统执行这个文件需要哪个解释器，进入 <code>/bin</code> 目录下可以看到 bash 和 sh 解释器；</p><ul><li><code>diff</code> 命令：判断两个文件的不同，比如 <code>diff /Users/lefe/Desktop/project/Kmart/Podfile.lock /Users/lefe/Desktop/project/Kmart/pods/Manifest.lock &gt;~/Desktop/shell.log</code> 比较两个文件的不同，并重定向到 <code>shell.log</code> 文件中；</li><li><code>&gt;</code> 重定向符号，可以把输出命令输出到某个文件中而不是控制台；</li><li><code>echo</code> 是脚本的输出，相当于 <code>printf</code>；</li><li><code>exit 1</code> 退出，有了这个命令 Xcode 就会报错，你可以在 Xcode 中新建一个脚本，试试下面这个脚本：</li></ul><pre class=" language-shell"><code class="language-shell">echo "This is a test shell created by Lefe_x"exit 1</code></pre><ul><li><p><code>$?：</code> 指上条命令执行的结果，也就是 <code>diff</code> 执行的结果；</p></li><li><p>下面是 shell 中的 if 语句：</p></li></ul><pre class=" language-shell"><code class="language-shell">if 条件 ; thenfi</code></pre><p><strong>如何在终端执行脚本</strong></p><p>假如有个叫 <code>podlgsk.sh</code> 的脚本，只要给予它执行权限（<code>chmod +x podlgsk.sh</code>），注意只需要给一次执行权限就行，下次运行脚本时就不需要给予执行权限了，然后直接 <code>./podlgsk.sh</code> 即可。</p><p><strong>小结</strong></p><p>其实 <code>Shell</code> 脚本就是把一些 <code>linux</code> 命令组合到一起，经过一些处理（比如：if 判断，循环等）后所形成的文件。（不知道总结的是否恰当）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 11中隐藏section头尾的实现</title>
      <link href="/2017/11/01/2017/11/ios-11-zhong-yin-cang-section-tou-wei-de-shi-xian/"/>
      <url>/2017/11/01/2017/11/ios-11-zhong-yin-cang-section-tou-wei-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-11中隐藏section头尾的实现"><a href="#iOS-11中隐藏section头尾的实现" class="headerlink" title="iOS 11中隐藏section头尾的实现"></a>iOS 11中隐藏section头尾的实现</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5549095051" target="_blank" rel="noopener">iOS_OneByte</a></p><p>iOS 中 <code>UITableView</code> 中有一种比较常用的样式 <code>UITableViewStyleGrouped</code>。有时我们要隐去 <code>section</code> 头尾的话，经常实现如下：</p><pre class=" language-objc"><code class="language-objc">- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{    return 0.1f;}- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section{    return 0.1f;}</code></pre><p>如果只实现这2段代码的话，在 <code>iOS 11</code> 之前是不会出现问题的，但 <code>iOS 11</code> 之后需要同时实现如下：</p><pre class=" language-objc"><code class="language-objc">- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section{    return nil;}-(UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section{    return nil;}</code></pre><p><code>Base SDK</code> 路径设置： <code>Xcode</code> &lt; <code>Build Settings</code> &lt;  <code>Base SDK</code></p><p><code>Base SDK</code>：指得是当前编译应用的和构建 <code>.ipa</code> 的 <code>SDK</code> 的版本，并且手机的 <code>SDK</code> 版本是向前兼容。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ViewController关联XIB文件时初始化方法的调用</title>
      <link href="/2017/11/01/2017/11/viewcontroller-guan-lian-xib-wen-jian-shi-chu-shi-hua-fang-fa-de-diao-yong/"/>
      <url>/2017/11/01/2017/11/viewcontroller-guan-lian-xib-wen-jian-shi-chu-shi-hua-fang-fa-de-diao-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="ViewController关联XIB文件时初始化方法的调用"><a href="#ViewController关联XIB文件时初始化方法的调用" class="headerlink" title="ViewController关联XIB文件时初始化方法的调用"></a>ViewController关联XIB文件时初始化方法的调用</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>在新建一个 <code>ViewController</code> 文件时，如果同时也勾选了 <code>Also create XIB file</code>，那么<code>ViewController *viewController = [[ViewController alloc] init]</code> 得到的是和 <code>initWithNibName:bundle:</code> 初始化得到的 UI 一致的。原因是 <code>init</code> 方法最终都会调到指定构造器 <code>initWithNibName:bundle:</code>，但此时 <code>nibName</code> 为 <code>nil</code>，而且没有 VC 复写 <code>loadView</code> 的情况下，则系统会有一套自己的寻找机制来看是否有对应的 xib 文件，如果有，则加载 xib 文件。具体可参考苹果官方文档的<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621487-nibname?language=objc" target="_blank" rel="noopener">解释</a>：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/9-1.jpg?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 清理 cookies</title>
      <link href="/2017/11/01/2017/11/ios-qing-li-cookies/"/>
      <url>/2017/11/01/2017/11/ios-qing-li-cookies/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-清理-cookies"><a href="#iOS-清理-cookies" class="headerlink" title="iOS 清理 cookies"></a>iOS 清理 cookies</h2><p>在手机端开发 <code>web</code> 页面时，有时候我们可能需要删除一些 <code>cookie</code> 值。JS 删除 <code>cookie</code> 主要是将 <code>cookie</code> 的 <code>expires</code> 属性设置为一个早于当前时间的值。不过如果 <code>cookie</code> 是 <code>HttpOnly</code> 的话，表示这个 <code>cookie</code> 值不能通过非 <code>HTTP</code> 方式来访问，而无法通过 JS 来访问，<code>document.cookie</code> 获取不到，所以也无法通过 JS 来删除这样的 <code>cookie</code> 值。</p><p>不过除了通过 <code>server</code> 端来处理外，我们也可以借助 <code>native</code> 端来执行删除操作。iOS 端使用 <code>NSHTTPCookie</code> 对象来表示一个 <code>cookie</code> ，并通过 <code>NSHTTPCookieStorage</code> 来管理当前应用的所有 <code>cookie</code>，包括 <code>HttpOnly/secure</code> 类型的 <code>cookie</code> 。所有想要删除 <code>cookie</code> ，只需要依据给定的条件(如域、path等属性)来找出对应的 <code>NSHTTPCookie</code> 对象，并删除就行。以下代码是清空当前应用程序所有 <code>cookie</code> 的操作：</p><pre class=" language-objc"><code class="language-objc">NSArray<NSHTTPCookie *> *cookies = [NSHTTPCookieStorage sharedHTTPCookieStorage].cookies;for (NSHTTPCookie *cookie in cookies) {    [[NSHTTPCookieStorage sharedHTTPCookieStorage] deleteCookie:cookie];}</code></pre><p>当然，如果要在 <code>web</code> 端触发操作，还需要提供 <code>Hybrid</code> 接口。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS10之后多边形绘制</title>
      <link href="/2017/11/01/2017/11/ios10-zhi-hou-duo-bian-xing-hui-zhi/"/>
      <url>/2017/11/01/2017/11/ios10-zhi-hou-duo-bian-xing-hui-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS10之后多边形绘制"><a href="#iOS10之后多边形绘制" class="headerlink" title="iOS10之后多边形绘制"></a>iOS10之后多边形绘制</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>众所周知，对于一些多边形的绘制，我们可以使用 <code>CAShapeLayer</code> 配合 <code>UIBezierPath</code>，然后再用这个 <code>layer</code> 给 <code>View</code> 做 <code>mask</code> 即可。但是一种情况是不行的，对于 <code>UIVisualEffectView</code>，iOS10 之前 <code>self.blurView.layer.mask = someShapeLayer</code> 这一句是 ok 的，但是 iOS10 之后，这样设将无效，而应该使用 <code>self.blurView.maskView = maskView</code>。具体代码如下图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/6-1.JPG?raw=true" alt></p><p>详细解释可参考<a href="https://forums.developer.apple.com/thread/50854" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pod install 和 pod update 的区别</title>
      <link href="/2017/11/01/2017/11/pod-install-he-pod-update-de-qu-bie/"/>
      <url>/2017/11/01/2017/11/pod-install-he-pod-update-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="pod-install-和-pod-update-的区别"><a href="#pod-install-和-pod-update-的区别" class="headerlink" title="pod install 和 pod update 的区别"></a>pod install 和 pod update 的区别</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>首先 <code>podfile.lock</code> 和 <code>podfile</code> 必须加入版本控制。</p><p><code>install</code> 并不是第一次创建 <code>podfile</code> 时运行一次，后面就不再使用了。<code>install</code> 命令不仅在初始时使用，在新增或删除 <code>repo</code> 时也需要运行。每次添加或删除 <code>repo</code> 后应该执行 <code>install</code> 命令，这样其它的 <code>repo</code> 不会更新。<code>update</code> 仅仅在只需更新某一个 <code>repo</code> 或所有时才使用。每次执行 <code>install</code> 时，会将每个 <code>repo</code> 的版本信息写入到 <code>podfile.lock</code>，已存在于 <code>podfile.lock</code> 的 <code>repo</code> 不会被更新只会下载指定版本，不在 <code>podfile.lock</code> 中的 <code>repo</code> 将会搜索与 <code>podfile</code> 里面对应 <code>repo</code> 匹配的版本。即使某个 <code>repo</code> 指定了版本，如 <code>pod &#39;A&#39;, &#39;1.0.0&#39;</code>，最好也是不要使用 <code>update</code>，因为 <code>repo A</code> 可能有依赖，如果此时使用 <code>update</code> 会更新其依赖。</p><p>参考：</p><ol><li><a href="https://guides.cocoapods.org/using/pod-install-vs-update.html" target="_blank" rel="noopener">pod install vs. pod update</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么我放弃使用系统自带的终端</title>
      <link href="/2017/11/01/2017/11/wei-shi-me-wo-fang-qi-shi-yong-xi-tong-zi-dai-de-zhong-duan/"/>
      <url>/2017/11/01/2017/11/wei-shi-me-wo-fang-qi-shi-yong-xi-tong-zi-dai-de-zhong-duan/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么我放弃使用系统自带的终端"><a href="#为什么我放弃使用系统自带的终端" class="headerlink" title="为什么我放弃使用系统自带的终端"></a>为什么我放弃使用系统自带的终端</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>用过 <code>iTerm</code> 后，我再也不想使用系统自带的终端了。 <code>iTerm</code> 是终端的一个替代品，而且开源免费。它支持非常棒的特性：</p><ul><li>设置一个可爱的背景图 <code>Preference -&gt; Profiles -&gt; Window -&gt; Background Image</code> ，如下图所示；</li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/16-1.png?raw=true" alt></p><ul><li><p><code>Hotkey Window</code>，让终端立刻出现在你的面前。比如当你使用 <code>Xcode</code> 正在编码时，这时需要执行 <code>Pod install</code>，使用快捷键 <code>command+i</code>（需要设置） 直接调出 <code>iTerm</code>；</p></li><li><p>选择即复制，当你选择终端中的文本后，它会自动复制；</p></li><li><p>点击可跳转，如下图中，按住 <code>command</code> 并点击 <code>/Users/apple/Desktop/project/lefeDemo</code> 就会跳转到这个文件夹下。 按住 <code>command</code> 并点击 <code>www.baidu.com</code>，就会在浏览器中打开 <code>www.baidu.com</code>;</p></li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/16-2.png?raw=true" alt></p><ul><li><p>自动提示你所输过的命令，这样可以快速输入你所敲过的命令；</p></li><li><p>快照功能，可以回退到某一时刻你所输过的命令；</p></li></ul><p>想了解 iTerm 更多特性，可以查看 <a href="https://iterm2.com/features.html" target="_blank" rel="noopener">官网</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用NSLog可能出现的安全问题</title>
      <link href="/2017/11/01/2017/11/shi-yong-nslog-ke-neng-chu-xian-de-an-quan-wen-ti/"/>
      <url>/2017/11/01/2017/11/shi-yong-nslog-ke-neng-chu-xian-de-an-quan-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="使用NSLog可能出现的安全问题"><a href="#使用NSLog可能出现的安全问题" class="headerlink" title="使用NSLog可能出现的安全问题"></a>使用NSLog可能出现的安全问题</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5549095051" target="_blank" rel="noopener">iOS_OneByte</a></p><p>iOS 经常定义类似如下的输出宏:</p><pre class=" language-objc"><code class="language-objc">#ifdef DEBUG    #define ZJLog(fmt, ...) NSLog((fmt), ##__VA_ARGS__)#else    #define ZJLog(...)#endif</code></pre><p>但是大部分人可能只是遵循国际惯例，并不知道如果直接使用 <code>NSLog</code> 的危害或者如何去查看别人家的应用输出，其实很简单，只是 <code>Xcode</code> 隐藏的很深,路径如下</p><pre><code>Xcode8 - Window - DevicesXcode9 - Window - Devices And Simulators</code></pre><p>如下图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/13-2.jpg?raw=true" alt></p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/13-3.jpg?raw=true" alt></p><p>这个利用好的话,对于调试自己或者查(po)看(jie)别人家的应用都很有用,效果如下图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/13-4.jpg?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小程序和iOS数据绑定</title>
      <link href="/2017/11/01/2017/11/xiao-cheng-xu-he-ios-shu-ju-bang-ding/"/>
      <url>/2017/11/01/2017/11/xiao-cheng-xu-he-ios-shu-ju-bang-ding/</url>
      
        <content type="html"><![CDATA[<h2 id="小程序和iOS数据绑定"><a href="#小程序和iOS数据绑定" class="headerlink" title="小程序和iOS数据绑定"></a>小程序和iOS数据绑定</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>在微信小程序中，开发 UI 功能模块，绝对比的上 iOS 原生开发。它已经提供了一套成熟的数据绑定方式，而不需要引入其它库。而在 iOS 中我们同样可以做数据绑定，然而需要花费一定的时间来学习一些数据绑定的框架，比如 RAC，RxSwift。这里主要以 <code>RxSwift</code> 为例说明。在小程序中，假如实现一个功能，点击按钮修改昵称，可以这样实现：</p><pre class=" language-objc"><code class="language-objc">Page({  data: {    nickName: 'Lefe_x'  },  changeNickNameAction: function () {    this.setData ({      nickName: 'Lefe'    })  }})</code></pre><p>直接修改数据源 <code>data</code> 中的 <code>nickName</code> 即可让新的昵称(Lefe)显示到控件上。看看具体的数据绑定实现：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main-container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   {{nickName}}   修改昵称<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">></span></span></code></pre><p><code>nickName</code> 与一个 <code>Text</code> 的控件绑定到了一起，这样只要 <code>nickName</code> 发生改变，就会显示到 <code>Text</code> 控件上。而在 iOS 中我们可以使用 <code>RxSwift</code> 做数据绑定。比如：当 <code>nickNameTextField</code> 输入内容后，将显示在 <code>nickNameLabel</code> 上。</p><pre class=" language-objc"><code class="language-objc">class MiniViewController: UIViewController {    let disposeBag = DisposeBag()    @IBOutlet weak var nickNameTextField: UITextField!    @IBOutlet weak var nickNameLabel: UILabel!    override func viewDidLoad() {        super.viewDidLoad()        nickNameTextField.rx.text.bind(to: nickNameLabel.rx.text).disposed(by: disposeBag)    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决React Native引入realm导致编译卡顿问题</title>
      <link href="/2017/11/01/2017/11/jie-jue-react-native-yin-ru-realm-dao-zhi-bian-yi-qia-dun-wen-ti/"/>
      <url>/2017/11/01/2017/11/jie-jue-react-native-yin-ru-realm-dao-zhi-bian-yi-qia-dun-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="解决React-Native引入realm导致编译卡顿问题"><a href="#解决React-Native引入realm导致编译卡顿问题" class="headerlink" title="解决React Native引入realm导致编译卡顿问题"></a>解决React Native引入realm导致编译卡顿问题</h2><p>在<code>React Native</code>项目中引入<code>realm</code>后，在编译阶段，网络状况不好的时候会卡在realm模块下载的地方。现象是如果在终端用<code>react-native run-ios</code>，则会卡在<code>Download realm-sync-cocoa-${version}.tar.xz</code>，如果是Xcode，则会卡在<code>Build ${ProjectName}: RealmJS</code>这一块。</p><p>这主要是因为realm的库太大(<code>realm-sync-cocoa-${version}.tar.xz</code>包大概是50+M)。所以我们可以考虑把包先下载到本地，以减少每次编译的时间。</p><ol><li>我们可以从<code>realm-cocoa</code>的<a href="https://github.com/realm/realm-cocoa/blob/master/build.sh#L289" target="_blank" rel="noopener">build.sh文件</a>中找到<code>realm-sync-cocoa-${version}.tar.xz</code>的下载地址(注：${version}是具体的版本号)，下载文件。</li><li>在命令行输入<code>getconf DARWIN_USER_TEMP_DIR</code>，获取文件下载的临时目录</li><li>将下载的文件拷贝到临时目录</li><li>这样基本就OK。</li></ol><p>如果还不行，则可以考虑以下操作：</p><ol><li>修改下载的脚本代码了。找到<code>node_modules/realm/scripts/download_realm.js</code>；</li><li>找到<code>download()</code>函数，将其中的<code>saveFile()</code>函数作如下修改；</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">saveFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>isTTY<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printProgress</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>body<span class="token punctuation">,</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>headers<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'Content-Length'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> archive<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Downloading </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>archive<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// const file = fs.createWriteStream(destination);</span>        <span class="token comment" spellcheck="true">// response.body.pipe(file).once('finish', () => file.close(resolve));</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> fs<span class="token punctuation">.</span><span class="token function">utimes</span><span class="token punctuation">(</span>destination<span class="token punctuation">,</span> lastModified<span class="token punctuation">,</span> lastModified<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最后运行<code>react-native run-ios</code>。</p><p>参考</p><ol><li><a href="https://github.com/realm/realm-cocoa/issues/2713" target="_blank" rel="noopener">Core occasionally cannot be downloaded from China</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>当 iTerm 遇上 ZSH，他们相爱了</title>
      <link href="/2017/11/01/2017/11/dang-iterm-yu-shang-zsh-ta-men-xiang-ai-liao/"/>
      <url>/2017/11/01/2017/11/dang-iterm-yu-shang-zsh-ta-men-xiang-ai-liao/</url>
      
        <content type="html"><![CDATA[<h2 id="当-iTerm-遇上-ZSH，他们相爱了"><a href="#当-iTerm-遇上-ZSH，他们相爱了" class="headerlink" title="当 iTerm 遇上 ZSH，他们相爱了"></a>当 iTerm 遇上 ZSH，他们相爱了</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><blockquote><p>Your terminal never felt this good before.</p></blockquote><p>上一条 <code>iOS知识小集</code> 主要说了下使用 <code>iTerm</code> 可以改善我们的终端，评论中 <a href="https://weibo.com/crespoxiao" target="_blank" rel="noopener">@CrespoXiao</a> 和 <a href="https://weibo.com/u/3106903737" target="_blank" rel="noopener">@struggleend</a> 提到了 <code>iTerm + ZSH</code> 使用起来更方便。搜了下 <code>ZSH</code>，发现 Star 数 62476 个，确实是好东西，和大家分享下，目前使用时间不长，姑且总结几条我认为比较好的，有熟悉的同学在评论中分享给大家吧 🤝，相信同学们不会吝啬的。<a href="https://github.com/robbyrussell/oh-my-zsh/" target="_blank" rel="noopener">安装看这里</a> 。<code>Oh My Zsh</code> 它是基于 zsh 命令行的一个扩展工具集。</p><p>提示：根目录下有 <code>~/.zshrc</code> 文件，可以修改配置，比如主题，插件等。</p><ul><li>设置一个主题，如果你有洁癖，选择一个你认为比较好的<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">主题</a> ；</li><li>使用插件，比如有 Git 插件，当记不住命令的时候，按 Tab 键可以提示，比如 <code>git p [tab]</code> 将会提示，如下图所示；</li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/17-1.png?raw=true" alt></p><ul><li>支持简写，比如省略 cd，回到上级目录直接输入：.. ；</li><li><code>ls *.jpeg</code>  显示当前目录下所有 jpeg 文件；</li><li><code>cd &lt;TAB&gt;</code> 简显示当前目录下的文件，继续按 <tab> 可以选择你所要进入的目录；</tab></li><li><code>git &lt;UP&gt;</code> 可以找到最近输入的 Git 命令；</li></ul><p>想了解 <code>ZSH</code> 更多特性，可以查看 <a href="http://ohmyz.sh/" target="_blank" rel="noopener">官网</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>通过导入DSYM使用Instruments做性能分析</title>
      <link href="/2017/11/01/2017/11/tong-guo-dao-ru-dsym-shi-yong-instruments-zuo-xing-neng-fen-xi/"/>
      <url>/2017/11/01/2017/11/tong-guo-dao-ru-dsym-shi-yong-instruments-zuo-xing-neng-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="通过导入DSYM使用Instruments做性能分析"><a href="#通过导入DSYM使用Instruments做性能分析" class="headerlink" title="通过导入DSYM使用Instruments做性能分析"></a>通过导入DSYM使用Instruments做性能分析</h2><p><strong>作者</strong>: <a href="https://weibo.com/VongLo" target="_blank" rel="noopener">Vong_HUST</a></p><p>通常情况下，使用 <code>Instruments</code> 做性能分析，看调用栈时，是能够直接看到对应方法调用堆栈的，而不是一串的地址，但这个前提是 Xcode 用编译过这个应用。如果是用同事或者打包服务器上的安装包做性能分析时，就无法看到对应的方法调用堆栈信息了，只能看到一串地址。这个时候可以通过导入 <code>dSYM</code> 的方式来查看对应的方法调用堆栈，方式如下（见图）：打开 <code>Instruments</code> -&gt; <code>运行一遍你的应用</code> -&gt; <code>停止</code> -&gt; <code>File</code> -&gt; <code>Symbols</code> -&gt; <code>dSYM Path : Locate</code>即可。如下图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/4-1.JPG?raw=true" alt="图一"></p><p>但是有些时候可能应用中包含 <code>extension</code>，则直接 <code>locate</code> 会提示无法定位到 dSYM 文件</p><blockquote><p>The specified path didn’t locate a dSYM for any of the selected libraries.</p></blockquote><p>这个时候需要把你的 <code>dSYM.zip</code> 解压，右键显示其内容将对应的 <code>.app.dSYM</code> 拷出，然后 <code>locate</code> 到这个拷出的 <code>dSYM</code> 文件即可或者按照下图操作也是可行的。具体流程见图：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/11/4-2.GIF?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Extract Function/Extract Method</title>
      <link href="/2017/10/01/2017/10/extract-function-extract-method/"/>
      <url>/2017/10/01/2017/10/extract-function-extract-method/</url>
      
        <content type="html"><![CDATA[<h2 id="Extract-Function-Extract-Method"><a href="#Extract-Function-Extract-Method" class="headerlink" title="Extract Function/Extract Method"></a>Extract Function/Extract Method</h2><p>当我们写代码写得飞起的时候，很可能在一个函数/方法里面堆积大量代码。当然，从美学的角度来讲，我们更希望写一些小而职责单一的函数/方法，所以这时候可以考虑重构。</p><p>Xcode为我们提供了一个简便的方法：<code>Extract Function/Extract Method</code>，来将代码提取成一个函数/方法。</p><p>具体操作是：首先选中要提取的代码，然后右键点击出现菜单，选择<code>Refactor</code> -&gt; <code>Extract Function/Extract Method</code>，如下图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/10/26-1-1.jpg?raw=true" alt></p><p>可以看到选中的代码被提取成一个单独的方法，我们可以给方法命个名，如下图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/10/26-1-2.jpg?raw=true" alt></p><p>而且这个操作可以识别新方法需要哪些参数，是不是很方便？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何找出国际化文件(xxxx.strings)中未国际化的文件</title>
      <link href="/2017/10/01/2017/10/ru-he-zhao-chu-guo-ji-hua-wen-jian-xxxx.strings-zhong-wei-guo-ji-hua-de-wen-jian/"/>
      <url>/2017/10/01/2017/10/ru-he-zhao-chu-guo-ji-hua-wen-jian-xxxx.strings-zhong-wei-guo-ji-hua-de-wen-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="如何找出国际化文件-xxxx-strings-中未国际化的文件"><a href="#如何找出国际化文件-xxxx-strings-中未国际化的文件" class="headerlink" title="如何找出国际化文件(xxxx.strings)中未国际化的文件"></a>如何找出国际化文件(xxxx.strings)中未国际化的文件</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>国际化的时候难免会由于不小心，会出现某个<code>.strings</code>文件中存在没有添加的国际化字符串。比如某个项目中支持中文和英文。在中文国际化文件（<code>zh-Hans.lproj/Localizable.strings</code>）中含有 ：</p><pre><code>&quot;HOM_home&quot; = &quot;首页&quot;;&quot;GRB_groupBuy&quot; = &quot;团购&quot;;&quot;SHC_shopnCart&quot; = &quot;购物车&quot;;&quot;PER_personal&quot; = &quot;我的&quot;;</code></pre><p>而在英文国际化文件（en.lproj/Localizable.strings）中含有 ：</p><pre><code>&quot;HOM_home&quot; = &quot;home&quot;;&quot;PER_personal&quot; = &quot;my&quot;;</code></pre><p>这样导致，英文环境下，<code>SHC_shopnCart</code>和<code>GRB_groupBuy</code>未国际化，使用这个脚本会检测出这些错误。</p><p>【如何使用】</p><ol><li>修改 <code>DESPATH</code> 为你项目的路径；</li><li>直接在脚本所在的目录下，打开终端执行 <code>python checkLocalizable.py</code>，这里的 <code>checkLocalizable.py</code> 为脚本文件名。你可以在<a href="https://github.com/lefex/TCZLocalizableTool/blob/master/LocalToos/checkLocalizable.py" target="_blank" rel="noopener">这里</a>找到脚本文件；</li><li>执行完成后，桌面会出现一个文件 <code>checkLocalizable.log</code>，记录了未国际化的行：</li></ol><pre><code>/en.lproj/Localizable.stringsSHC_shopnCartGRB_groupBuy</code></pre><p>截止到目前，关于国际化的一些技巧，到这里基本告一段落了。下一篇打算写一篇关于正则表达式的，记录了我学习正则表达式的一些方法技巧，从此脱离复制粘贴，可以看懂，还可以写正则表达式。</p><p>可以从<a href="https://github.com/lefex/TCZLocalizableTool" target="_blank" rel="noopener">这里</a>找到这些脚本源码。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查找未国际化的文字</title>
      <link href="/2017/10/01/2017/10/cha-zhao-wei-guo-ji-hua-de-wen-zi/"/>
      <url>/2017/10/01/2017/10/cha-zhao-wei-guo-ji-hua-de-wen-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="查找未国际化的文字"><a href="#查找未国际化的文字" class="headerlink" title="查找未国际化的文字"></a>查找未国际化的文字</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>对于支持多语言的App来说，国际化非常麻烦，而找出项目中未国际化的文字非常耗时（如果单纯的靠手动查找）。虽然可以使用<code>Xcode</code>自带的工具（<code>Show not-localized strings</code>）或者 <code>Analyze</code> 找出未国际化的文本，但是它们都不够灵活，而且比较耗时。如果能直接把项目中未国际化的文本导入到一个文件中，直接给产品，然后再使用 <a href="https://github.com/lefex/TCZLocalizableTool" target="_blank" rel="noopener">TCZLocalizableTool</a>，岂不是事半功倍。下图中就是通过一个 Python 脚本获得的部分未国际化的文本。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/10/10-1-1.jpg?raw=true" alt></p><p>使用很简单</p><ol><li>修改 <code>DESPATH</code> 路径为你项目的路径</li><li>直接在脚本所在的目录下，执行 <code>python unLocalizable.py</code>，这里的 <code>unLocalizable.py</code> 为脚本文件名。你可以在<a href="https://github.com/lefex/TCZLocalizableTool/blob/master/LocalToos/TCZLocalizable/unLocalizable.py" target="_blank" rel="noopener">这里</a>找到脚本文件。</li><li><code>BLACKDIRLIST</code> 你可以过滤掉和国际化无关的文件，比如某些第三方库。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dictionary的mapValue(_:)方法</title>
      <link href="/2017/10/01/2017/10/dictionary-de-mapvalue-fang-fa/"/>
      <url>/2017/10/01/2017/10/dictionary-de-mapvalue-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="Dictionary的mapValue-方法"><a href="#Dictionary的mapValue-方法" class="headerlink" title="Dictionary的mapValue(_:)方法"></a>Dictionary的mapValue(_:)方法</h2><p>Swift 4中的Dictionary字典新增了一个mapValue(_:)方法，来转换字典的值，同时保留key。如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> original <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">:</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"F"</span><span class="token punctuation">:</span> <span class="token string">"Facebook"</span><span class="token punctuation">,</span> <span class="token string">"G"</span><span class="token punctuation">:</span> <span class="token string">"Google"</span><span class="token punctuation">]</span><span class="token keyword">let</span> result <span class="token operator">=</span> original<span class="token punctuation">.</span>mapValues <span class="token punctuation">{</span> <span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token keyword">in</span>    <span class="token keyword">return</span> item<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// ["G": 6, "A": 5, "F": 8]</span></code></pre><p>其中original和result有相同的key，只是值不同，所以它们有相同的内部布局，不需要重新计算hash值，因此这种方式创建字典会比重新构建一个字典更快。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React Native中自定义iconfont图标库</title>
      <link href="/2017/10/01/2017/10/react-native-zhong-zi-ding-yi-iconfont-tu-biao-ku/"/>
      <url>/2017/10/01/2017/10/react-native-zhong-zi-ding-yi-iconfont-tu-biao-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Native中自定义iconfont图标库"><a href="#React-Native中自定义iconfont图标库" class="headerlink" title="React Native中自定义iconfont图标库"></a>React Native中自定义iconfont图标库</h2><p>接上一条。</p><p>使用<code>Unicode</code>码显得不直观，所以我们可以自定义图标库。<code>react-native-vector-icons</code>有一些内置的图标库，我们参考其创建方式，我们以Zocial为例，如下代码所示：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> createIconSet <span class="token keyword">from</span> <span class="token string">'./lib/create-icon-set'</span><span class="token punctuation">;</span><span class="token keyword">import</span> glyphMap <span class="token keyword">from</span> <span class="token string">'./glyphmaps/Zocial.json'</span><span class="token punctuation">;</span><span class="token keyword">const</span> iconSet <span class="token operator">=</span> <span class="token function">createIconSet</span><span class="token punctuation">(</span>glyphMap<span class="token punctuation">,</span> <span class="token string">'zocial'</span><span class="token punctuation">,</span> <span class="token string">'Zocial.ttf'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> iconSet<span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> Button <span class="token operator">=</span> iconSet<span class="token punctuation">.</span>Button<span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> TabBarItem <span class="token operator">=</span> iconSet<span class="token punctuation">.</span>TabBarItem<span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> TabBarItemIOS <span class="token operator">=</span> iconSet<span class="token punctuation">.</span>TabBarItemIOS<span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> ToolbarAndroid <span class="token operator">=</span> iconSet<span class="token punctuation">.</span>ToolbarAndroid<span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> getImageSource <span class="token operator">=</span> iconSet<span class="token punctuation">.</span>getImageSource<span class="token punctuation">;</span></code></pre><p>最主要的就是createIconSet函数，它接受三个参数：字形映射表、字体名、字体文件名。</p><p>首先我们需要制作一个字形映射表，这是一个json文件，其内容如下代码所示：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  <span class="token string">"home"</span><span class="token punctuation">:</span> <span class="token number">58981</span><span class="token punctuation">,</span>  <span class="token string">"setting"</span><span class="token punctuation">:</span> <span class="token number">58928</span><span class="token punctuation">,</span>  <span class="token string">"stack-overflow"</span><span class="token punctuation">:</span> <span class="token number">59479</span><span class="token punctuation">}</span></code></pre><p>key是我们可以在代码中直接使用的字符串，value是Unicode码对应的10进制数字，其中Unicode码可以在iconfont.cn上查看(实际就是就<code>&amp;#xe665;</code>串中有<code>e665</code>)。</p><p>然后我们创建一个js文件，参考Zocial.js，依葫芦画瓢，如下代码所示：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> createIconSet <span class="token keyword">from</span> <span class="token string">'react-native-vector-icons/lib/create-icon-set'</span><span class="token punctuation">;</span><span class="token keyword">import</span> glyphMap <span class="token keyword">from</span> <span class="token string">'./iconfont.json'</span><span class="token punctuation">;</span><span class="token keyword">const</span> iconSet <span class="token operator">=</span> <span class="token function">createIconSet</span><span class="token punctuation">(</span>glyphMap<span class="token punctuation">,</span> <span class="token string">'iconfont'</span><span class="token punctuation">,</span> <span class="token string">'iconfont.ttf'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> iconSet<span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> Button <span class="token operator">=</span> iconSet<span class="token punctuation">.</span>Button<span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> TabBarItem <span class="token operator">=</span> iconSet<span class="token punctuation">.</span>TabBarItem<span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> TabBarItemIOS <span class="token operator">=</span> iconSet<span class="token punctuation">.</span>TabBarItemIOS<span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> ToolbarAndroid <span class="token operator">=</span> iconSet<span class="token punctuation">.</span>ToolbarAndroid<span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> getImageSource <span class="token operator">=</span> iconSet<span class="token punctuation">.</span>getImageSource<span class="token punctuation">;</span></code></pre><p>在工程中，我们就可以直接使用这个自定义图标库了，如下代码所示：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> Icon <span class="token keyword">from</span> <span class="token string">'./assets/fonts/iconfont'</span><span class="token punctuation">;</span><span class="token keyword">const</span> setTabBarIcon <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>tintColor<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>Icon name<span class="token operator">=</span><span class="token string">'home'</span> size<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">30</span><span class="token punctuation">}</span> color<span class="token operator">=</span><span class="token punctuation">{</span>tintColor<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>比使用Unicode直观多了。</p><p>参考</p><ol><li><a href="https://github.com/oblador/react-native-vector-icons" target="_blank" rel="noopener">Github react-native-vector-icons</a></li><li><a href="https://github.com/MrErHu/blog/issues/15" target="_blank" rel="noopener">React Native与Iconfont</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode 9.1对崩溃提示的改进</title>
      <link href="/2017/10/01/2017/10/xcode-9.1-dui-beng-kui-ti-shi-de-gai-jin/"/>
      <url>/2017/10/01/2017/10/xcode-9.1-dui-beng-kui-ti-shi-de-gai-jin/</url>
      
        <content type="html"><![CDATA[<h2 id="Xcode-9-1对崩溃提示的改进"><a href="#Xcode-9-1对崩溃提示的改进" class="headerlink" title="Xcode 9.1对崩溃提示的改进"></a>Xcode 9.1对崩溃提示的改进</h2><p><code>Xcode 9.1</code>改进了Swift程序崩溃时的错误提示信息：在<code>debug</code>模式下运行程序，崩溃时将在编辑区的崩溃位置显示崩溃的原因，如下图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/10/12-1-1.jpg?raw=true" alt></p><p>而在此之前，只是显示简单的诸<code>EXC_BAD_INSTRUCTION</code>或<code>EXC_BREAKPOINT</code>这样的偏底层的<code>Mach</code>异常信息，无法获取到实际的信息。</p><p>这一改进包含了以下崩溃类型的提示：</p><ul><li>强制解包nil</li><li>try!导致的错误</li><li>数组越界</li><li>precondition失败</li><li>断言失败</li><li>fatalError调用</li></ul><p>不过需要注意的是只有在程序入口是用Swift来写的应用中(<code>@UIApplicationMain/@NSApplicationMain</code>)才有效。</p><p>参考</p><p><a href="https://swift.org/blog/xcode-9-1-improves-display-of-fatal-errors/?utm_campaign=This%2BWeek%2Bin%2BSwift&amp;utm_medium=email&amp;utm_source=This_Week_in_Swift_146" target="_blank" rel="noopener">Xcode 9.1 Improves Display of Fatal Errors</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>判断是否在主队列运行</title>
      <link href="/2017/10/01/2017/10/pan-duan-shi-fou-zai-zhu-dui-lie-yun-xing/"/>
      <url>/2017/10/01/2017/10/pan-duan-shi-fou-zai-zhu-dui-lie-yun-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="判断是否在主队列运行"><a href="#判断是否在主队列运行" class="headerlink" title="判断是否在主队列运行"></a>判断是否在主队列运行</h2><p>在iOS中，如果我们要判断代码是否运行在主线程，可以直接使用<code>NSThread.isMainThread()</code>方法。但如果要判断是否运行在主队列(main queue)呢？</p><p>需要注意的是，每个应用都只有一个主线程，但主线程中可能有多个队列，则不仅仅只有主队列，所以<code>NSThread.isMainThread()</code>方法并没有办法判断是否是在主队列运行。而GCD也没有提供相应的方法。那该如何处理呢？</p><p>来看看React Native的处理方式：</p><pre class=" language-objc"><code class="language-objc">BOOL RCTIsMainQueue(){  static void *mainQueueKey = &mainQueueKey;  static dispatch_once_t onceToken;  dispatch_once(&onceToken, ^{    dispatch_queue_set_specific(dispatch_get_main_queue(),                                mainQueueKey, mainQueueKey, NULL);  });  return dispatch_get_specific(mainQueueKey) == mainQueueKey;}</code></pre><p>可以看到这里使用了<code>dispatch_queue_set_specific</code>和<code>dispatch_get_specific</code>。实际上是通过<code>dispatch_queue_set_specific</code>方法给主队列(main queue)关联了一个key-value对，再通过<code>dispatch_get_specific</code>从当前队列中取出<code>mainQueueKey</code>对应的value。如果是主队列，取出来的值就是写入的值，如果是其它主队列，取出的值就是另一个值或者是NULL。这样就OK了。</p><p>当然，同样可以用类似的方式来设置其它的队列(设置全局并发队列无效)。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>删除iOS项目中未使用的图片</title>
      <link href="/2017/10/01/2017/10/shan-chu-ios-xiang-mu-zhong-wei-shi-yong-de-tu-pian/"/>
      <url>/2017/10/01/2017/10/shan-chu-ios-xiang-mu-zhong-wei-shi-yong-de-tu-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="删除iOS项目中未使用的图片"><a href="#删除iOS项目中未使用的图片" class="headerlink" title="删除iOS项目中未使用的图片"></a>删除iOS项目中未使用的图片</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>【痛点】</p><p>删除 iOS 项目中没有用到的图片市面上已经有很多种方式，但是我试过几个都不能很好地满足需求，因此使用 Python 写了这个脚本，它可能也不能很好的满足你的需求，因为这种静态查找始终会存在问题，每个人写的代码风格不一，导致匹配字符不一。所以只有掌握了脚本的写法，才能很好的满足自己的需求。如果你的项目中使用Objective-C，而且使用纯代码布局，使用这个脚本完全没有问题。当然你可以修改脚本来达到自己的需求。本文主要希望能够帮助更多的读者节省更多时间做一些有意义的工作，避免那些乏味重复的工作。</p><p>【如何使用】</p><ol><li>修改 <code>DESPATH</code> 为你项目的路径；</li><li>直接在脚本所在的目录下，打开终端执行 <code>python unUseImage.py</code>，这里的<code>unUseImage.py</code>为脚本文件名。你可以在<a href="https://github.com/lefex/TCZLocalizableTool/blob/master/LocalToos/unUseImage.py" target="_blank" rel="noopener">这里</a>找到脚本文件；</li><li>执行完成后，桌面会出现一个 <code>unUseImage</code> 文件夹。文件夹中的 <code>error.log</code> 文件记录了可能存在未匹配到图片的文件目录，<code>image.log</code> 记录了项目中没使用的图片路径，<code>images</code>存放了未使用到的图片。</li></ol><p>【重要提示】</p><p>当确认 <code>images</code> 文件夹中含有正在使用的图时，复制图片名字到<code>EXCEPT_IMAGES</code>中，再次执行脚本，确认 <code>images</code> 文件夹中不再包含使用的图后，修改<code>IS_OPEN_AUTO_DEL</code>为<code>True</code>，执行脚本，脚本将自动清除所有未使用的图。</p><p>更好的阅读体验，请移步<a href="http://www.jianshu.com/p/dca77c25bf5d" target="_blank" rel="noopener">更人性化的找出 iOS 中未使用的图</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何1秒找出国际化文件(en.lproj/Localizable.strings)语法错误</title>
      <link href="/2017/10/01/2017/10/ru-he-1-miao-zhao-chu-guo-ji-hua-wen-jian-en.lproj-localizable.strings-yu-fa-cuo-wu/"/>
      <url>/2017/10/01/2017/10/ru-he-1-miao-zhao-chu-guo-ji-hua-wen-jian-en.lproj-localizable.strings-yu-fa-cuo-wu/</url>
      
        <content type="html"><![CDATA[<h2 id="如何1秒找出国际化文件-en-lproj-Localizable-strings-语法错误"><a href="#如何1秒找出国际化文件-en-lproj-Localizable-strings-语法错误" class="headerlink" title="如何1秒找出国际化文件(en.lproj/Localizable.strings)语法错误"></a>如何1秒找出国际化文件(en.lproj/Localizable.strings)语法错误</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>国际化的时候难免会由于不小心，会出现语法错误，如果国际化文件有几千行的时候，无非是一场灾难。有时为了解决一个语法错误可能会耗费几个小时。使用这个脚本可以<code>1秒</code>定位到报错的代码行。比如 <code>&quot;HOM_Lefe&quot; = &quot;wsy“;</code> 由于错误使用了汉语双引号，导致编译失败。</p><p>【如何使用】</p><ol><li>修改 <code>DESPATH</code> 为你项目的路径；</li><li>直接在脚本所在的目录下，打开终端执行 <code>python localizableError.py</code>，这里的 <code>localizableError.py</code> 为脚本文件名。你可以在<a href="https://github.com/lefex/TCZLocalizableTool/blob/master/LocalToos/localizableError.py" target="_blank" rel="noopener">这里</a>找到脚本文件；</li><li>执行完成后，控制台会打印报错的代码行。如</li></ol><pre><code>/en.lproj/Localizable.strings:line[11] : &quot;HOM_Lefe&quot; = &quot;wsy“;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JSManagedValue对底层Javascript值的引用</title>
      <link href="/2017/09/01/2017/9/jsmanagedvalue-dui-di-ceng-javascript-zhi-de-yin-yong/"/>
      <url>/2017/09/01/2017/9/jsmanagedvalue-dui-di-ceng-javascript-zhi-de-yin-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="JSManagedValue对底层Javascript值的引用"><a href="#JSManagedValue对底层Javascript值的引用" class="headerlink" title="JSManagedValue对底层Javascript值的引用"></a>JSManagedValue对底层Javascript值的引用</h2><p>使用<code>JSManagedValue</code>保存值时，需要注意其底层的<code>Javascript</code>值的使用。</p><p><code>JSManagedValue</code>添加了”条件保留(<code>conditional retain</code>)”机制为值提供自动内存管理，不过需要使用<code>JSVirtualMachine</code>的<code>addManagedReference(_:withOwner:)</code>方法。如果没有的话可能会导致一些问题，因为<code>JSManagedValue</code>行为类似于<code>ARC</code>的<code>weak</code>引用，所以当<code>Javascript</code>的垃圾收集器把<code>JSManagedValue</code>的底层<code>Javascript</code>值销毁时，<code>JSManagedValue</code>对象的<code>value</code>属性会自动变成<code>nil</code>。</p><p>下面是我写的一个Bug：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// action为局部变量</span><span class="token keyword">const</span> action <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">'https://www.baidu.com'</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        api<span class="token punctuation">.</span><span class="token function">setMenu</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>appApi<span class="token punctuation">.</span><span class="token function">setMenu</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span>    menuTitle<span class="token punctuation">:</span> <span class="token string">'订单'</span><span class="token punctuation">,</span>    menuAction<span class="token punctuation">:</span> action<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>menuAction</code>是一个<code>Javascript</code>回调函数，在<code>iOS</code>代码中用一个<code>JSManagedValue</code>来包装<code>menuAction</code>值，但由于<code>menuAction</code>是一个局部变量，所以一定时间会被回收；这时如果想再从<code>JSManagedValue</code>中取出<code>menuAction</code>回调来执行，由于其值已变成<code>nil</code>，所以不会产生任何效果。</p><p>还是得多读读文档啊。</p><p>参考</p><ol><li><a href="https://developer.apple.com/documentation/javascriptcore/jsmanagedvalue" target="_blank" rel="noopener">JSManagedValue Reference</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UITextFile和UITextView的textContentType属性新类型</title>
      <link href="/2017/09/01/2017/9/uitextfile-he-uitextview-de-textcontenttype-shu-xing-xin-lei-xing/"/>
      <url>/2017/09/01/2017/9/uitextfile-he-uitextview-de-textcontenttype-shu-xing-xin-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="UITextFile和UITextView的textContentType属性新类型"><a href="#UITextFile和UITextView的textContentType属性新类型" class="headerlink" title="UITextFile和UITextView的textContentType属性新类型"></a>UITextFile和UITextView的textContentType属性新类型</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p><code>UITextFile</code>和<code>UITextView</code>的<code>textContentType</code>属性新加了<code>UITextContentTypeUsername</code>和 <code>UITextContentTypePassword</code>类型，这样当你登录<code>App</code>时可以自动填充你的账号和密码，前提是你保存过密码到<code>Safari</code>或钥匙串。<code>App</code>可以和你的网站进行关联，如果在网站上登录过，可以自动填充密码和账户到你的<code>App</code>。</p><pre class=" language-objc"><code class="language-objc">_textField.textContentType = UITextContentTypeUsername;_textField.textContentType = UITextContentTypePassword;</code></pre><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017-09-22-1-1.jpg?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 11中的New Color Set</title>
      <link href="/2017/09/01/2017/9/ios-11-zhong-de-new-color-set/"/>
      <url>/2017/09/01/2017/9/ios-11-zhong-de-new-color-set/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-11中的New-Color-Set"><a href="#iOS-11中的New-Color-Set" class="headerlink" title="iOS 11中的New Color Set"></a>iOS 11中的New Color Set</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>适配 iOS 11 时意外发现个<code>New Color Set</code>，仔细研究了下，发现比较爽。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/20-1-1.jpg?raw=true" alt></p><p>它集中管理项目中的颜色，项目中有多少颜色一目了然。不过按目前的实现方式<code>Color</code>的名字必须使用【16 进制】颜色的名字。当然你可以自己加个前缀之类的，比如：<code>gray_50E3C2</code>，这样在方法中<code>mtColorWithHexString:</code> 中去掉前缀即可。</p><p>使用的时候，直接使用：</p><pre class=" language-objc"><code class="language-objc">[UIColor colorNamed:name];</code></pre><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/20-1-2.jpg?raw=true" alt></p><p>但是这个方法只有在 iOS 11 以上系统有效，我们可以自己实现一个方法，或者把系统的方法替换掉。</p><pre class=" language-objc"><code class="language-objc">@implementation UIColor (main)+ (UIColor *)mtColorNamed:(NSString *)name{    if (name.length == 0) {        return [UIColor clearColor];    }    NSString *cString = [[name stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] uppercaseString];    if (cString.length != 6) {        return [UIColor clearColor];    }    if (@available(iOS 11.0, *)) {        return [UIColor colorNamed:name];    } else {        return [self mtColorWithHexString:name];    }}+ (UIColor *)mtColorWithHexString:(NSString *)color{    unsigned int r, g, b;    [[NSScanner scannerWithString:[color substringWithRange:NSMakeRange(0, 2)]] scanHexInt:&r];    [[NSScanner scannerWithString:[color substringWithRange:NSMakeRange(2, 2)]] scanHexInt:&g];    [[NSScanner scannerWithString:[color substringWithRange:NSMakeRange(4, 2)]] scanHexInt:&b];    return [UIColor colorWithRed:((CGFloat) r / 255.0f) green:((CGFloat) g / 255.0f) blue:((CGFloat) b / 255.0f) alpha:1.0f];}@end</code></pre><p>使用时，直接调用我们自定义的方法即可：</p><pre class=" language-objc"><code class="language-objc">static NSString* const k50E3C2Color = @"50E3C2";static NSString* const k10AEFFColor = @"10AEFF";- (void)viewDidLoad {    [super viewDidLoad];    _label = [[UILabel alloc] initWithFrame:CGRectMake(40, 100, 100, 50)];    _label.text = k50E3C2Color;    _label.textAlignment = NSTextAlignmentCenter;    _label.textColor = [UIColor mtColorNamed:k10AEFFColor];    _label.backgroundColor = [UIColor mtColorNamed:k50E3C2Color];    [self.view addSubview:_label];}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iPhone X屏幕基本信息</title>
      <link href="/2017/09/01/2017/9/iphone-x-ping-mu-ji-ben-xin-xi/"/>
      <url>/2017/09/01/2017/9/iphone-x-ping-mu-ji-ben-xin-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="iPhone-X屏幕基本信息"><a href="#iPhone-X屏幕基本信息" class="headerlink" title="iPhone X屏幕基本信息"></a>iPhone X屏幕基本信息</h2><p>适配iPhone X时，需要了解一些屏幕的基本信息：</p><ol><li>iPhone X是真正的3x设备，1个point代表屏幕上的<strong>3×3</strong>个像素；而iPhone 7 plus 大概是<strong><em>2.88×2.88</em></strong>个像素；</li><li>iPhone X屏幕大小是<strong>375×812</strong>个点 (<strong><em>1125×2436</em></strong>像素)；</li><li>iPhone X屏幕的长宽比大约是<strong>9:19.5</strong>，iPhone 5~8的长宽比都是<strong><em>9:16</em></strong>；不过iPhone X与iPhone 6/6s/7/8的屏幕宽度是一样的；</li><li>大刘海，这应该是最直观的，导致状态栏被分割在刘海两侧</li></ol><p>参考</p><ol><li><a href="https://medium.com/@hacknicity/how-ios-apps-adapt-to-the-iphone-x-screen-size-a00bd109bbb9" target="_blank" rel="noopener">How iOS Apps Adapt to the iPhone X Screen Size</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Xcode自带的运行时工具发现代码中的漏洞</title>
      <link href="/2017/09/01/2017/9/shi-yong-xcode-zi-dai-de-yun-xing-shi-gong-ju-fa-xian-dai-ma-zhong-de-lou-dong/"/>
      <url>/2017/09/01/2017/9/shi-yong-xcode-zi-dai-de-yun-xing-shi-gong-ju-fa-xian-dai-ma-zhong-de-lou-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Xcode自带的运行时工具发现代码中的漏洞"><a href="#使用Xcode自带的运行时工具发现代码中的漏洞" class="headerlink" title="使用Xcode自带的运行时工具发现代码中的漏洞"></a>使用Xcode自带的运行时工具发现代码中的漏洞</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>我们可以使用 <code>Xcode</code> 自带的 运行时工具发现代码中的漏洞，有些难以复现的 Bug 往往使用这些工具很容易定位到，比如线程引发的资源竞争问题，内存问题等。</p><ul><li><strong>Main thread checker</strong>【Xcode 9 新增特性】：当某些代码必须在主线程执行时，而你没有在主线程执行，那么 Xcode 9 会提示。<code>XXX must be used from thread only.</code>。这个工具 <code>Xcode 9</code> 是默认打开的，建议开启。如下两图Xcode 9前后对比。</li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/26-1-2.jpg?raw=true" alt></p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/26-1-3.jpg?raw=true" alt></p><ul><li><p><strong>Address Sanitizer</strong>：发生内存异常时可以使用这个工具调试，比如 <code>buffer overflow</code>, <code>use-after-free</code>, <code>double free</code>, <code>use after end of scope</code>。</p></li><li><p><strong>Thread Sanitizer</strong>：定位多线程问题，比如数据争用（<code>Data race</code>），想要打开这个开关，需要关闭 <code>Address Sanitizer</code> ，<code>Malloc Stack</code> 和 <code>Memory Management</code> 选项。下面这段代码会出现资源竞争的问题。勾选后，将会提示：</p></li></ul><pre class=" language-objc"><code class="language-objc">Race on a library object in -[ViewController testThreadRace] at 0x7b080000db20for (int i = 0; i < 10; i++) {   dispatch_async(dispatch_get_global_queue(0, 0), ^{      [self testThreadRace];   });}- (void)testThreadRace{    BOOL found = [_dict objectForKey:@"lefe"];        // Race on a library object in -[ViewController testThreadRace] at 0x7b080004b520    if (found) {        NSLog(@"Found");    }    [_dict setObject:@"WangSuyan" forKey:@"lefe"];}</code></pre><ul><li><strong>Undefined Behavior Sanitizer 【Xcode 9新增特性】</strong>：检测未定义的行为，这些多数服务于 C 语言，因为 OC 和 Swift 相对比较安全，在语言设计时就消除了大多数未定义的行为，如下图。它可以检测到大约 15 种未定义的行为，比如常见的有数组越界，未初始化，无效的枚举值，除数为零和空值判断等。我们用例子来列举几个未定义的行为（想了解更多看<a href="https://developer.apple.com/documentation/code_diagnostics/undefined_behavior_sanitizer" target="_blank" rel="noopener">官方文档</a>）：</li></ul><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/26-1-1.jpg?raw=true" alt></p><pre class=" language-objc"><code class="language-objc">- (NSInteger)testUndefinedBehavior{    NSInteger value;    if (self.name.length > 0) {        value = 12;    }    return value;}</code></pre><p>如果勾选 <code>Undefined Behavior Sanitizer</code> 这样选项，Xcode 会提示</p><pre><code>Variable &#39;value&#39; is used uninitialized whenever &#39;if&#39; condition is false</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查看Swift函数/方法编译时间</title>
      <link href="/2017/09/01/2017/9/cha-kan-swift-han-shu-fang-fa-bian-yi-shi-jian/"/>
      <url>/2017/09/01/2017/9/cha-kan-swift-han-shu-fang-fa-bian-yi-shi-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="查看Swift函数-方法编译时间"><a href="#查看Swift函数-方法编译时间" class="headerlink" title="查看Swift函数/方法编译时间"></a>查看Swift函数/方法编译时间</h2><p>我们可以使用<code>-debug-time-function-bodies</code>标识来查看Swift中每个函数/方法的编译时间。添加方式与<code>-warn-long-expression-type-checking</code>一样，在<code>Other Swift Flags</code>添加中<code>-Xfrontend -debug-time-function-bodies</code>。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/28-1-1.png?raw=true" alt></p><p>这样，我们就可以在<code>Report navigator</code>的编译日志里面看到。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/27-1-2.png?raw=true" alt></p><p>另外，如果是用<code>xcodebuild</code>命令行，则可以如下将日志格式化输出到文本文件：</p><p><code>xcodebuild -workspace App.xcworkspace -scheme App clean build OTHER_SWIFT_FLAGS=&quot;-Xfrontend -debug-time-function-bodies&quot; | grep .[0-9]ms | grep -v ^0.[0-9]ms | sort -nr &gt; log.txt</code></p><p>知道每个函数/方法的编译时间后，就可以有针对性的做优化了。</p><p>参考</p><ol><li><a href="http://irace.me/swift-profiling" target="_blank" rel="noopener">Profiling your Swift compilation times</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自动记住键盘类型</title>
      <link href="/2017/09/01/2017/9/zi-dong-ji-zhu-jian-pan-lei-xing/"/>
      <url>/2017/09/01/2017/9/zi-dong-ji-zhu-jian-pan-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="自动记住键盘类型"><a href="#自动记住键盘类型" class="headerlink" title="自动记住键盘类型"></a>自动记住键盘类型</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>自动记住你选择的键盘类型。比如在【密语】中，你和A聊天用英文，切换到英文键盘；和B聊天，切换到中文键盘；那么当你退出聊天后。与A再次聊天时，显示的是英文键盘，与B聊天显示的是中文键盘。你只需要在<code>UIViewController</code>中实现：</p><pre class=" language-objc"><code class="language-objc">- (NSString *)textInputContextIdentifier{    return self.conversation.conversationId;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode 9支持开启多个模拟器</title>
      <link href="/2017/09/01/2017/9/xcode-9-zhi-chi-kai-qi-duo-ge-mo-ni-qi/"/>
      <url>/2017/09/01/2017/9/xcode-9-zhi-chi-kai-qi-duo-ge-mo-ni-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="Xcode-9支持开启多个模拟器"><a href="#Xcode-9支持开启多个模拟器" class="headerlink" title="Xcode 9支持开启多个模拟器"></a>Xcode 9支持开启多个模拟器</h2><p><code>Xcode 9</code>开始可以同时开启多个模拟器了。这样我们就可以同时看不同模拟器下App的显示效果。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/25-1-1.png?raw=true" alt></p><p>可以在模拟器的<code>Hardware-&gt;Device</code>中启动新的模拟器。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/25-1-2.png?raw=true" alt></p><p>当然，在Xcode 9上切换模拟器时，也不会强制关闭之前打开的模拟器了。不过，开启多个模拟器的代价是会影响到电脑的速度。</p><p>在Xcode 9之前尝试同时打开多个模拟器，则需要一些<code>trick</code>方法，可以参考<a href="https://www.youtube.com/watch?v=0aS_zEYvQY4" target="_blank" rel="noopener">How to Run Multiple iOS Simulator Instances Xcode 8.2</a></p><p>参考</p><ol><li><a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/xcode_9/xcode_9.html" target="_blank" rel="noopener">What’s New in Xcode</a></li><li><a href="https://medium.com/@guydaher/whats-new-in-xcode-9-top-5-features-to-look-forward-to-c2e64868270b" target="_blank" rel="noopener">What’s New in Xcode 9: Top 5 features to look forward to.</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode 9全屏模式下与模拟器分屏</title>
      <link href="/2017/09/01/2017/9/xcode-9-quan-ping-mo-shi-xia-yu-mo-ni-qi-fen-ping/"/>
      <url>/2017/09/01/2017/9/xcode-9-quan-ping-mo-shi-xia-yu-mo-ni-qi-fen-ping/</url>
      
        <content type="html"><![CDATA[<h2 id="Xcode-9全屏模式下与模拟器分屏"><a href="#Xcode-9全屏模式下与模拟器分屏" class="headerlink" title="Xcode 9全屏模式下与模拟器分屏"></a>Xcode 9全屏模式下与模拟器分屏</h2><p>在<code>Xcode 9</code>之前，如果<code>Xcode</code>是全屏模式，那么使用模拟器时会有些不方便，看效果时需要切换屏幕（壕的话可以用双屏幕）。在<code>Xcode 9</code>中，添加了一个新功能，即在全屏模式下，可以和模拟器在同一屏幕上分屏操作，如下图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/29-1-1.png?raw=true" alt></p><p>这需要模拟器开启“允许全屏模式”，只需要勾选上<code>Internal</code>-&gt;<code>Allow Fullscreen Mode</code>，再把模拟器拖入<code>Xcode</code>所在屏幕即可。如下图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/29-1-2.png?raw=true" alt></p><p>至于模拟器的位置，可以在左右两侧，看个人习惯。也可以改变两者的屏幕占比。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>-warn-long-expression-type-checking标识</title>
      <link href="/2017/09/01/2017/9/warn-long-expression-type-checking-biao-shi/"/>
      <url>/2017/09/01/2017/9/warn-long-expression-type-checking-biao-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="warn-long-expression-type-checking标识"><a href="#warn-long-expression-type-checking标识" class="headerlink" title="-warn-long-expression-type-checking标识"></a>-warn-long-expression-type-checking标识</h2><p>Swift的类型检测(<code>type-checker</code>)是编译时的一个性能瓶颈。</p><p>在Xcode 9中添加了一个编译器标识位<code>-warn-long-expression-type-checking</code>，可以对那些耗时长的类型检测操作给出警告。</p><p>我们可以在<code>Build Settings</code>-&gt;<code>Swift Compiler - Custom Flags</code>-&gt;<code>Other Swift Flags</code>中添加这个标识：<code>-Xfrontend -warn-long-expression-type-checking=&lt;limit&gt;</code>；其中<code>&lt;limit&gt;</code>是个阈值，以毫秒为单位，超出这个值的类型检测就给出警告。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/27-1-1.png?raw=true" alt></p><p>编译的警告信息如下图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/09/27-1-2.png?raw=true" alt></p><p>获取警告信息之后，就可以根据需要去优化对应的操作。至于<code>&lt;limit&gt;</code>，可以凭经验设置，设置低了，可能会产生大量的警告信息。建议从高到低设置，先优化耗时高的。另外，建议只在<code>DEBUG</code>模式下开启。</p><p>另外，在Xcode 9之前可以使用<code>-warn-long-function-bodies</code>标识(Xcode 9仍然保留)，这个是警告哪个方法的类型检测超过阈值。可以尝试一下。</p><p>参考</p><ol><li><a href="https://www.jessesquires.com/blog/measuring-compile-times-xcode9/" target="_blank" rel="noopener">Measuring Swift compile times in Xcode 9</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WKWebView检测首屏渲染时间</title>
      <link href="/2017/09/01/2017/9/wkwebview-jian-ce-shou-ping-xuan-ran-shi-jian/"/>
      <url>/2017/09/01/2017/9/wkwebview-jian-ce-shou-ping-xuan-ran-shi-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="WKWebView检测首屏渲染时间"><a href="#WKWebView检测首屏渲染时间" class="headerlink" title="WKWebView检测首屏渲染时间"></a>WKWebView检测首屏渲染时间</h2><p><strong>作者</strong>: <a href="https://weibo.com/bestswifter" target="_blank" rel="noopener">bestswifter</a></p><p>调研了一下<code>WKWebView</code>如何检测首屏渲染的时间，经过阅读<code>WebKit</code>源码和尝试，发现这样可以（需要调用私有方法，可以<code>base64</code>加密一下）：</p><pre class=" language-objc"><code class="language-objc">// 注册[self.webview performSelectorOnMainThread:@selector(_setObservedRenderingProgressEvents:) withObject:@(127) waitUntilDone:NO];// 回调- (void)_webView:(WKWebView *)webView renderingProgressDidChange:(int)progressEvents {    // progressEvents == 64 表示首屏渲染结束}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 11中applicationDidEnterBackground:延迟执行</title>
      <link href="/2017/09/01/2017/9/ios-11-zhong-applicationdidenterbackground-yan-chi-zhi-xing/"/>
      <url>/2017/09/01/2017/9/ios-11-zhong-applicationdidenterbackground-yan-chi-zhi-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-11中applicationDidEnterBackground-延迟执行"><a href="#iOS-11中applicationDidEnterBackground-延迟执行" class="headerlink" title="iOS 11中applicationDidEnterBackground:延迟执行"></a>iOS 11中applicationDidEnterBackground:延迟执行</h2><p><strong>作者</strong>: <a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefe_x</a></p><p>App 进入后台后, <code>applicationDidEnterBackground:</code>这个方法将延迟大约 1000 毫秒执行, 那么如果在进入后台时做一些任务，可能会达不到预期的效果。如果 App 刚进入应用立即启动，<code>applicationDidEnterBackground:</code> 和 <code>applicationWillEnterForeground:</code> 这两个方法都不会调用。如果有这么一个场景，进入后台后给应用设置手势密码，当 App 刚进入后就立即启动，那么 <code>applicationDidEnterBackground</code>：这个方法不会立即执行，从而手势密码也就不会设置。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数值类型的failable initializers</title>
      <link href="/2017/04/01/2017/4/shu-zhi-lei-xing-de-failable-initializers/"/>
      <url>/2017/04/01/2017/4/shu-zhi-lei-xing-de-failable-initializers/</url>
      
        <content type="html"><![CDATA[<h2 id="数值类型的failable-initializers"><a href="#数值类型的failable-initializers" class="headerlink" title="数值类型的failable initializers"></a>数值类型的failable initializers</h2><p><code>Swift 3.1</code>为数值类型(<code>Int, Int8, Int16, Int32, Int64, UInt, UInt8, UInt16, UInt32, UInt64, Float, Float80, Double</code>)实现了<code>failable initializers: init?(exactly value:)</code>。这些<code>initializer</code>在创建数值类型失败时会返回<code>nil</code>，对于处理一些从诸如<code>json</code>这样松散的数据类型的数值时非常有用。</p><p>如下代码是<a href="(https://www.raywenderlich.com/156352/whats-new-in-swift-3-1">raywenderlich</a>)中的一段示例。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>  <span class="token keyword">let</span> grade<span class="token punctuation">:</span> <span class="token builtin">Int</span>  <span class="token keyword">init</span><span class="token operator">?</span><span class="token punctuation">(</span>json<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">guard</span> <span class="token keyword">let</span> name <span class="token operator">=</span> json<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">String</span><span class="token punctuation">,</span>          <span class="token keyword">let</span> gradeString <span class="token operator">=</span> json<span class="token punctuation">[</span><span class="token string">"grade"</span><span class="token punctuation">]</span> <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">String</span><span class="token punctuation">,</span>          <span class="token keyword">let</span> gradeDouble <span class="token operator">=</span> <span class="token function">Double</span><span class="token punctuation">(</span>gradeString<span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token keyword">let</span> grade <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span>exactly<span class="token punctuation">:</span> gradeDouble<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// &lt;-- 3.1 feature here</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">nil</span>    <span class="token punctuation">}</span>    <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">self</span><span class="token punctuation">.</span>grade <span class="token operator">=</span> grade  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">makeStudents</span><span class="token punctuation">(</span>with data<span class="token punctuation">:</span> <span class="token builtin">Data</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Student</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>  <span class="token keyword">guard</span> <span class="token keyword">let</span> json <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> <span class="token builtin">JSONSerialization</span><span class="token punctuation">.</span><span class="token function">jsonObject</span><span class="token punctuation">(</span>with<span class="token punctuation">:</span> data<span class="token punctuation">,</span> options<span class="token punctuation">:</span> <span class="token punctuation">.</span>allowFragments<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">let</span> jsonArray <span class="token operator">=</span> json <span class="token keyword">as</span><span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> jsonArray<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token builtin">Student</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> rawStudents <span class="token operator">=</span> "<span class="token punctuation">[</span><span class="token punctuation">{</span>\"name\"<span class="token punctuation">:</span>\"<span class="token builtin">Ray</span>\"<span class="token punctuation">,</span> \"grade\"<span class="token punctuation">:</span>\"<span class="token number">5.0</span>\"<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\"name\"<span class="token punctuation">:</span>\"<span class="token builtin">Matt</span>\"<span class="token punctuation">,</span> \"grade\"<span class="token punctuation">:</span>\"<span class="token number">6</span>\"<span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token punctuation">{</span>\"name\"<span class="token punctuation">:</span>\"<span class="token builtin">Chris</span>\"<span class="token punctuation">,</span> \"grade\"<span class="token punctuation">:</span>\"<span class="token number">6.33</span>\"<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\"name\"<span class="token punctuation">:</span>\"<span class="token builtin">Cosmin</span>\"<span class="token punctuation">,</span> \"grade\"<span class="token punctuation">:</span>\"<span class="token number">7</span>\"<span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token punctuation">{</span>\<span class="token string">"name\":\"Steven\", \"grade\":\"7.5\"}]"</span><span class="token keyword">let</span> data <span class="token operator">=</span> rawStudents<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span>using<span class="token punctuation">:</span> <span class="token punctuation">.</span>utf8<span class="token punctuation">)</span><span class="token operator">!</span><span class="token keyword">let</span> students <span class="token operator">=</span> <span class="token function">makeStudents</span><span class="token punctuation">(</span>with<span class="token punctuation">:</span> data<span class="token punctuation">)</span><span class="token function">dump</span><span class="token punctuation">(</span>students<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [(name: "Ray", grade: 5), (name: "Matt", grade: 6), (name: "Cosmin", grade: 7)]</span></code></pre><p>这里过滤了<code>json</code>中<code>grade</code>值转换成<code>Int</code>值时不准确的数据。</p><p>参考</p><ol><li><a href="https://www.raywenderlich.com/156352/whats-new-in-swift-3-1" target="_blank" rel="noopener">What’s New in Swift 3.1?</a></li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0080-failable-numeric-initializers.md" target="_blank" rel="noopener">Swift evolution: Failable Numeric Conversion Initializers</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sequence prefix(while:)</title>
      <link href="/2017/04/01/2017/4/sequence-prefix/"/>
      <url>/2017/04/01/2017/4/sequence-prefix/</url>
      
        <content type="html"><![CDATA[<h2 id="Sequence-prefix-while"><a href="#Sequence-prefix-while" class="headerlink" title="Sequence prefix(while:)"></a>Sequence prefix(while:)</h2><p>Swift的<code>Sequence</code>协议提供了一个<code>prefix(_:)</code>方法，返回序列前面n个元素组成的序列，与之对应的是<code>suffix(_:)</code>方法，返回序列后面n个元素组成的序列。如果指定的长度大于序列的长度，则返回整个序列。如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token number">20</span> <span class="token punctuation">{</span>    arr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>arr<span class="token punctuation">.</span><span class="token keyword">prefix</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">// [0, 1, 2, 3, 4]</span>arr<span class="token punctuation">.</span><span class="token function">suffix</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">// [15, 16, 17, 18, 19]</span>arr<span class="token punctuation">.</span><span class="token keyword">prefix</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span>arr<span class="token punctuation">.</span><span class="token function">suffix</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span></code></pre><p>在<code>Swift 3.1</code>中新增了一个<code>prefix</code>方法，即<code>prefix(while:)</code>，它返回满足给定谓词的连续元素的子序列，直到第一个不满足的元素为止。同时还提供了一个类似的方法，即<code>drop(while:)</code>，不同的是这个方法是抛弃满足给定谓词的连续元素，而返回以第一个不满足谓词的元素为起始元素，后续元素组成的子序列，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// [2, 4, 6]</span>arr<span class="token punctuation">.</span><span class="token keyword">prefix</span> <span class="token punctuation">{</span>    $<span class="token number">0</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// [7, 10, 3, 9, 19]</span>arr<span class="token punctuation">.</span>drop <span class="token punctuation">{</span>    $<span class="token number">0</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">}</span></code></pre><p><a href="https://www.raywenderlich.com/156352/whats-new-in-swift-3-1" target="_blank" rel="noopener">raywenderlich</a> 中给了一个<code>Fibonacci</code>的例子，如下所示，可以参考一下：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> fibonacci <span class="token operator">=</span> <span class="token function">sequence</span><span class="token punctuation">(</span>state<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">(</span>state<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span><span class="token operator">?</span> <span class="token keyword">in</span>  <span class="token keyword">defer</span> <span class="token punctuation">{</span>state <span class="token operator">=</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">+</span> state<span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span>  <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Swift 3.1</span><span class="token keyword">let</span> interval <span class="token operator">=</span> fibonacci<span class="token punctuation">.</span><span class="token keyword">prefix</span><span class="token punctuation">(</span><span class="token keyword">while</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>$<span class="token number">0</span> <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">drop</span><span class="token punctuation">(</span><span class="token keyword">while</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>$<span class="token number">0</span> <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">for</span> element <span class="token keyword">in</span> interval <span class="token punctuation">{</span>  <span class="token function">print</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 144 233 377 610 987</span><span class="token punctuation">}</span></code></pre><p>参考</p><ol><li><a href="https://www.raywenderlich.com/156352/whats-new-in-swift-3-1" target="_blank" rel="noopener">What’s New in Swift 3.1?</a></li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0045-scan-takewhile-dropwhile.md" target="_blank" rel="noopener">Swift evolution: Add prefix(while:) and drop(while:) to the stdlib</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Core Animation中CPU操作的影响因素</title>
      <link href="/2017/03/01/2017/3/core-animation-zhong-cpu-cao-zuo-de-ying-xiang-yin-su/"/>
      <url>/2017/03/01/2017/3/core-animation-zhong-cpu-cao-zuo-de-ying-xiang-yin-su/</url>
      
        <content type="html"><![CDATA[<h2 id="Core-Animation中CPU操作的影响因素"><a href="#Core-Animation中CPU操作的影响因素" class="headerlink" title="Core Animation中CPU操作的影响因素"></a>Core Animation中CPU操作的影响因素</h2><p><code>Core Animation</code>中CPU的操作在动画开始前执行，所以通常不会影响到动画的帧率，但是会影响到动画的开始。以下一些操作会延迟动画的开始时间：</p><ol><li>布局计算：这可以理解，视图越复杂，需要的计算量越大。特别注意<code>auto layout</code>是一种CPU密集型操作，比传统的<code>autoresizing</code>更耗CPU；</li><li>延迟加载视图机制：这个机制带有两面性，优点是优化内存使用和启动时间；缺点的涉及到IO操作；</li><li><code>Core Graphics</code>绘制：自定义的<code>-drawRect:</code>或<code>-drawLayer:inContext:</code>会引入显著的性能开销；因为<code>Core Animation</code>会在内存中创建一个与视图等大小的<code>backing image</code>用来绘制，然后再通过<code>IPC</code>将这个图片数据发送给<code>render server</code>；</li><li>图片解压。</li></ol><p>参考</p><p>iOS Core Animation Advanced Techniques</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>判断字节序</title>
      <link href="/2017/03/01/2017/3/pan-duan-zi-jie-xu/"/>
      <url>/2017/03/01/2017/3/pan-duan-zi-jie-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="判断字节序"><a href="#判断字节序" class="headerlink" title="判断字节序"></a>判断字节序</h2><p><code>Swift</code>中的整型类型提供了两个属性分别获取其大端字节序表示(<code>bigEndian</code>)和小端字节序表示(<code>littleEndian</code>)。如果想在Swift判断当前平台的字节序是大端还是小端，可以简单的使用如下语句：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> isLittleEndian <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">.</span>littleEndian</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>string view</title>
      <link href="/2017/03/01/2017/3/string-view/"/>
      <url>/2017/03/01/2017/3/string-view/</url>
      
        <content type="html"><![CDATA[<h2 id="string-view"><a href="#string-view" class="headerlink" title="string view "></a>string view </h2><p><code>Swift</code>中的<code>String</code>本身不是一个集合，不过它提供了一些属性来将其内容表示为集合。不同的属性可以将字符串呈现为不同的可视化及数据表示的视图，主要有4种类型：</p><ol><li><code>Character View</code>(<code>characters</code>属性，类型为<code>String.Character​View</code>)：扩展字符集群的集合，类似于自然语言字符。主要是以<code>Unicode</code>字符来表示；</li><li><code>Unicode Scalar View</code>(<code>unicode Scalars</code>，类型为<code>String.Unicode​Scalar​View</code>)：<code>Unicode</code>标题值的集合，即以<code>21-bit</code>作为<code>Unicode</code>的基本单元的值；</li><li><code>UTF-16 View</code>(<code>utf16</code>属性，类型为<code>String.UTF16View</code>)：<code>UTF-16</code>字符的集合，即以<code>16-bit</code>作为<code>Unicode</code>的基本单元的值；</li><li><code>UTF-8 View</code>(<code>utf8</code>属性，类型为<code>String.UTF8View</code>)：<code>UTF-8</code>字符的集合，即以<code>8-bit</code>作为<code>Unicode</code>的基本单元的值；如果<code>Swift</code>要和<code>C API</code>交互，则<code>String</code>以这种格式传递给C函数；</li></ol><p>官方文档给了一个实例，如图1所示，可以看到这几种表示方式的区别。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> cafe <span class="token operator">=</span> <span class="token string">"Cafe\u{301} du 🌍"</span><span class="token function">print</span><span class="token punctuation">(</span>cafe<span class="token punctuation">.</span>unicodeScalars<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Prints "10"</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">Array</span><span class="token punctuation">(</span>cafe<span class="token punctuation">.</span>unicodeScalars<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Prints "["C", "a", "f", "e", "\u{0301}", " ", "d", "u", " ", "\u{0001F30D}"]"</span><span class="token function">print</span><span class="token punctuation">(</span>cafe<span class="token punctuation">.</span>unicodeScalars<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span><span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Prints "[67, 97, 102, 101, 769, 32, 100, 117, 32, 127757]"</span><span class="token function">print</span><span class="token punctuation">(</span>cafe<span class="token punctuation">.</span>utf16<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Prints "11"</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">Array</span><span class="token punctuation">(</span>cafe<span class="token punctuation">.</span>utf16<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Prints "[67, 97, 102, 101, 769, 32, 100, 117, 32, 55356, 57101]"</span><span class="token function">print</span><span class="token punctuation">(</span>cafe<span class="token punctuation">.</span>utf8<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Prints "14"</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">Array</span><span class="token punctuation">(</span>cafe<span class="token punctuation">.</span>utf8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Prints "[67, 97, 102, 101, 204, 129, 32, 100, 117, 32, 240, 159, 140, 141]"</span></code></pre><p>参考</p><ol><li><a href="https://developer.apple.com/reference/swift/string" target="_blank" rel="noopener">String</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift auto diagram</title>
      <link href="/2017/03/01/2017/3/swift-auto-diagram/"/>
      <url>/2017/03/01/2017/3/swift-auto-diagram/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift-auto-diagram"><a href="#Swift-auto-diagram" class="headerlink" title="Swift auto diagram"></a>Swift auto diagram</h2><p><code>OmniGraffle</code>无法绘制<code>Swift</code>的类图，只能再找个替代工具：<code>swift auto diagram</code>。这是一个ruby写的<a href="https://github.com/yoshimkd/swift-auto-diagram" target="_blank" rel="noopener">开源库</a>。</p><p>下载源码后，可以在工具所在目录下执行命令：</p><pre class=" language-ruby"><code class="language-ruby">ruby generateClassDiagram<span class="token punctuation">.</span>rb <span class="token operator">~</span><span class="token operator">/</span>workspace<span class="token operator">/</span>my<span class="token operator">-</span>swift<span class="token operator">-</span>project</code></pre><p>然后会生成一个静态html页面，如图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/03/6-1.png?raw=true" alt></p><p>可以看到其以不同颜色标出了<code>protocol</code>, <code>class</code>, <code>struct</code>, <code>extension</code>等类型及它们之间的关系。在这个页面里面可以自由地拖动类型框。嗯，不过，谈不上美观啊~~~</p><p>参考</p><p><a href="https://martinmitrevski.com/2016/10/12/swift-class-diagrams-and-more/" target="_blank" rel="noopener">Swift Class Diagrams and more</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS模拟器的Debug菜单</title>
      <link href="/2017/03/01/2017/3/ios-mo-ni-qi-de-debug-cai-dan/"/>
      <url>/2017/03/01/2017/3/ios-mo-ni-qi-de-debug-cai-dan/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS模拟器的Debug菜单"><a href="#iOS模拟器的Debug菜单" class="headerlink" title="iOS模拟器的Debug菜单"></a>iOS模拟器的Debug菜单</h2><p>iOS模拟器的<code>Debug</code>菜单中提供了几个菜单项来检测影响帧率的一些因素：</p><ol><li><code>Color Blended Layers</code>: 高亮显示有混合操作的区域；</li><li><code>Color Copied Images</code>: 高亮显示被拷贝的图片。拷贝图片意味着<code>Core Animation</code>需要拷贝一份图片并发送给<code>render server</code>，这对内存和CPU的使用都是昂贵的；</li><li><code>Color Misaligned Images</code>: 高亮显示缩放或拉伸过的图片，或者没有正确对齐对到像素边界的图片；</li><li><code>Color Offscreen-Rendered</code>: 高亮显示离屏渲染的层对象。</li></ol><p>当然这几个选项在<code>Instrument</code>的<code>Core Animation</code>工具中也可以找到。</p><p>参考</p><p>iOS Core Animation Advanced Techniques</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 10.3移除Keychain中的数据</title>
      <link href="/2017/03/01/2017/3/ios-10.3-yi-chu-keychain-zhong-de-shu-ju/"/>
      <url>/2017/03/01/2017/3/ios-10.3-yi-chu-keychain-zhong-de-shu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-10-3移除Keychain中的数据"><a href="#iOS-10-3移除Keychain中的数据" class="headerlink" title="iOS 10.3移除Keychain中的数据"></a>iOS 10.3移除Keychain中的数据</h2><p>从<code>iOS 10.3</code>(目前还是beta版本)开始，保存在<code>keychain</code>中的App相关的数据，会随着应用的删除而被清除，重新安装App后将无法再从<code>keychain</code>中获取应用相关的数据。而10.3之前删除App并不会清理<code>keychain</code>中的对应数据。</p><p>如果希望App在重新安装后，仍然可以获取到之前的一些数据，则依赖于<code>keychain</code>的方案将变得不可靠。</p><p>不过，如果数据是在多个App间共享，则只有当所有相关的App都被删除后，才会删除<code>keychain</code>中的这些共享数据。</p><p>至于具体原由，可以参考<a href="https://forums.developer.apple.com/thread/72271" target="_blank" rel="noopener">iOS 10.3 Beta 2 autodeletes keychain items after application uninstall?</a>。</p><blockquote><p>This is an intentional change in iOS 10.3 to protect user privacy. Information that can identify a user should not be left on the device after the app that created it has been removed.</p></blockquote><blockquote><p>It has never been a part of the API contract that keychain items created by an app would survive when the app is removed. This has always been an implementation detail.</p></blockquote><blockquote><p>If a keychain item is shared with other apps, it won’t be deleted until those other apps have been deleted as well.</p></blockquote><blockquote><p>There is documentation in the works about this change that should address questions raised in this thread.</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UIWebView打开PDF文件</title>
      <link href="/2017/03/01/2017/3/uiwebview-da-kai-pdf-wen-jian/"/>
      <url>/2017/03/01/2017/3/uiwebview-da-kai-pdf-wen-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="UIWebView打开PDF文件"><a href="#UIWebView打开PDF文件" class="headerlink" title="UIWebView打开PDF文件"></a>UIWebView打开PDF文件</h2><p><code>UIWebView</code>可以直接打开PDF文件，代码很简单，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token atrule">@IBOutlet</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> webView<span class="token punctuation">:</span> <span class="token builtin">UIWebView</span><span class="token operator">!</span>    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> filename <span class="token operator">=</span> <span class="token builtin">Bundle</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span>forResource<span class="token punctuation">:</span> <span class="token string">"test"</span><span class="token punctuation">,</span> ofType<span class="token punctuation">:</span> <span class="token string">"pdf"</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token function">URL</span><span class="token punctuation">(</span>fileURLWithPath<span class="token punctuation">:</span> filename<span class="token operator">!</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> request <span class="token operator">=</span> <span class="token function">URLRequest</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> url<span class="token punctuation">)</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>webView<span class="token punctuation">.</span>scalesPageToFit <span class="token operator">=</span> <span class="token boolean">true</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>webView<span class="token punctuation">.</span><span class="token function">loadRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><p>效果如下图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/03/4-1.png?raw=true" alt></p><p>加载的PDF文件是放置在一个<code>UIWebPDFView</code>视图中，<code>UIWebPDFView</code>应该是一个私有类，可以在 <a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/UIWebPDFView.h" target="_blank" rel="noopener">UIWebPDFView.h</a>查看其声明。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关键字autoclosure</title>
      <link href="/2017/02/01/2017/2/guan-jian-zi-autoclosure/"/>
      <url>/2017/02/01/2017/2/guan-jian-zi-autoclosure/</url>
      
        <content type="html"><![CDATA[<h2 id="autoclosure"><a href="#autoclosure" class="headerlink" title="@autoclosure"></a>@autoclosure</h2><p><code>Swift</code>中的<code>@autoclosure</code>还是一个很有意思的属性，它用于修饰函数中的闭包类型的参数，它主要有两个作用：</p><ul><li>将一个表达式自动封装成一个闭包，从而简化函数/方法的调用方式，如下代码所示；</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> customersInLine <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Chris"</span><span class="token punctuation">,</span> <span class="token string">"Alex"</span><span class="token punctuation">,</span> <span class="token string">"Ewa"</span><span class="token punctuation">,</span> <span class="token string">"Barry"</span><span class="token punctuation">,</span> <span class="token string">"Daniella"</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 显示闭包参数，调用时参数以闭包的方式传入</span><span class="token keyword">func</span> <span class="token function">serve</span><span class="token punctuation">(</span>curstomer customerProvider<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Now serving \(customerProvider())!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">serve</span><span class="token punctuation">(</span>curstomer<span class="token punctuation">:</span> <span class="token punctuation">{</span>customersInLine<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// autoclosure闭包</span><span class="token keyword">func</span> <span class="token function">serve2</span><span class="token punctuation">(</span>curstomer customerProvider<span class="token punctuation">:</span> @<span class="token function">autoclosure</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Now serving \(customerProvider())!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 表达式`customersInLine.remove(at: 0)`被自动封装成一个闭包</span><span class="token function">serve2</span><span class="token punctuation">(</span>curstomer<span class="token punctuation">:</span> customersInLine<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ol start="2"><li>由于表达式封装成了闭包，所以可以延迟表达式的计算，一直到闭包被调用时。关于这一点的好处，可以参考<a href="https://developer.apple.com/swift/blog/?id=4" target="_blank" rel="noopener">这里</a>中对<code>assert</code>实现的介绍。</li></ol><p>需要注意的是，封装后的闭包一般不带参数，而表达式的值就作为返回值。所以声明函数时闭包一般没有输入参数，即使有也会被忽略，实际上在写代码时，<code>Xcode</code>就是将<code>@autoclosure</code>参数当成一个普通的类型</p><p>参考</p><ol><li><a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID543 https://developer.apple.com/swift/blog/?id=4" target="_blank" rel="noopener">The Swift Programming Language (Swift 4) – Closures</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift自定义操作符</title>
      <link href="/2017/02/01/2017/2/swift-zi-ding-yi-cao-zuo-fu/"/>
      <url>/2017/02/01/2017/2/swift-zi-ding-yi-cao-zuo-fu/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift自定义操作符"><a href="#Swift自定义操作符" class="headerlink" title="Swift自定义操作符"></a>Swift自定义操作符</h2><p>在<code>Swift</code>中，自定义操作符就是简单的二步：首先在全局使用<code>operator</code>关键字来声明操作符，同时用<code>prefix</code>、<code>infix</code>或<code>postfix</code>来声明操作符的位置；然后在所需要的类/结构体中实现操作符。如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">postfix</span> <span class="token keyword">operator</span> <span class="token operator">></span><span class="token operator">?</span><span class="token keyword">postfix</span> <span class="token keyword">operator</span> <span class="token operator">></span><span class="token operator">!</span><span class="token keyword">extension</span> <span class="token builtin">MIType</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">postfix</span> <span class="token keyword">func</span> <span class="token operator">></span><span class="token operator">?</span><span class="token punctuation">(</span>type<span class="token punctuation">:</span> <span class="token builtin">MIType</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">MIType</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">MIType</span><span class="token punctuation">(</span><span class="token string">"Optional&lt;<span class="token interpolation"><span class="token delimiter variable">\(</span>type<span class="token punctuation">.</span>name<span class="token delimiter variable">)</span></span>>"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">postfix</span> <span class="token keyword">func</span> <span class="token operator">></span><span class="token operator">!</span><span class="token punctuation">(</span>type<span class="token punctuation">:</span> <span class="token builtin">MIType</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">MIType</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">MIType</span><span class="token punctuation">(</span><span class="token string">"ImplicitlyUnwrappedOptional&lt;<span class="token interpolation"><span class="token delimiter variable">\(</span>type<span class="token punctuation">.</span>name<span class="token delimiter variable">)</span></span>>"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>自定义操作符需要以两类字符开头：</p><ol><li><code>ASCII</code>字符中的<code>/, =, -, +, !, *, %, &lt;, &gt;, &amp;, |, ^, ?, ~</code></li><li><code>Unicode</code>中的<code>Mathematical Operators</code>, <code>Miscellaneous Symbols</code>和<code>Dingbats Unicode blocks</code>这些字符中的字符</li></ol><p>然后后面允许使用组合的<code>Unicode</code>字符。如下代码是以一个<code>Miscellaneous Symbols</code>开头的实现向量加法的操作符。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">infix</span> <span class="token keyword">operator</span> ★<span class="token operator">+</span><span class="token keyword">struct</span> <span class="token builtin">Vector2D</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> x<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span>    <span class="token keyword">var</span> y<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span><span class="token punctuation">}</span><span class="token keyword">extension</span> <span class="token builtin">Vector2D</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> ★<span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">left</span><span class="token punctuation">:</span> <span class="token builtin">Vector2D</span><span class="token punctuation">,</span> <span class="token keyword">right</span><span class="token punctuation">:</span> <span class="token builtin">Vector2D</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Vector2D</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">Vector2D</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">left</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token keyword">right</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">left</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token keyword">right</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> vector1 <span class="token operator">=</span> <span class="token function">Vector2D</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token keyword">let</span> vector2 <span class="token operator">=</span> <span class="token function">Vector2D</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">let</span> vector <span class="token operator">=</span> vector1 ★<span class="token operator">+</span> vector2vector<span class="token punctuation">.</span>x        <span class="token comment" spellcheck="true">// 40.0</span>vector<span class="token punctuation">.</span>y        <span class="token comment" spellcheck="true">// 30.0</span></code></pre><p>参考</p><ol><li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID28" target="_blank" rel="noopener">The Swift Programming Language (Swift 4) – Advanced Operators</a></li><li>[The Swift Programming Language (Swift 4) – Lexical Structure](</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多维下标</title>
      <link href="/2017/02/01/2017/2/duo-wei-xia-biao/"/>
      <url>/2017/02/01/2017/2/duo-wei-xia-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="多维下标"><a href="#多维下标" class="headerlink" title="多维下标"></a>多维下标</h2><p>我们通常看到的下标操作都是一维的，不过如果有需要，我们可以定义多维的下标操作，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// 定义一个三维结构体</span><span class="token keyword">struct</span> <span class="token builtin">Vector3D</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Equatable</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> x<span class="token punctuation">:</span> T    <span class="token keyword">var</span> y<span class="token punctuation">:</span> T    <span class="token keyword">var</span> z<span class="token punctuation">:</span> T<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 向量数组</span><span class="token keyword">struct</span> <span class="token builtin">VectorArray</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Equatable</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> vectors<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Vector3D</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">append</span><span class="token punctuation">(</span>vector<span class="token punctuation">:</span> <span class="token builtin">Vector3D</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        vectors<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>vector<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 此处是根据输入的x, y, z值来确定是否有对应的值，而不是索引</span>    <span class="token comment" spellcheck="true">// 如果有，则返回该向量值；如果没有，返回nil</span>    <span class="token keyword">subscript</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> T<span class="token punctuation">,</span> <span class="token number">_</span> y<span class="token punctuation">:</span> T<span class="token punctuation">,</span> <span class="token number">_</span> z<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Vector3D</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">?</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> vector <span class="token keyword">in</span> vectors <span class="token punctuation">{</span>            <span class="token keyword">if</span> vector<span class="token punctuation">.</span>x <span class="token operator">==</span> x <span class="token operator">&amp;&amp;</span> vector<span class="token punctuation">.</span>y <span class="token operator">==</span> y <span class="token operator">&amp;&amp;</span> vector<span class="token punctuation">.</span>z <span class="token operator">==</span> z <span class="token punctuation">{</span>                <span class="token keyword">return</span> vector            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token constant">nil</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> vectors <span class="token operator">=</span> <span class="token builtin">VectorArray</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>vectors<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>vector<span class="token punctuation">:</span> <span class="token function">Vector3D</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>vectors<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>vector<span class="token punctuation">:</span> <span class="token function">Vector3D</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>vectors<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>vector<span class="token punctuation">:</span> <span class="token function">Vector3D</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>vectors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// nil</span><span class="token function">print</span><span class="token punctuation">(</span>vectors<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// Optional(__lldb_expr_167.Vector3D&lt;Swift.Int>(x: 3, y: 4, z: 6))</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Uninhabited Types</title>
      <link href="/2017/02/01/2017/2/uninhabited-types/"/>
      <url>/2017/02/01/2017/2/uninhabited-types/</url>
      
        <content type="html"><![CDATA[<h2 id="Uninhabited-Types"><a href="#Uninhabited-Types" class="headerlink" title="Uninhabited Types"></a>Uninhabited Types</h2><p><code>Never</code>是一个空枚举，即没有有效的<code>case</code>。所以它是一种<code>uninhabited type</code>，即明显没有值的类型。<code>Swift</code>中，以下两种情况可以看成是<code>uninhabited type</code>：</p><ol><li>一个枚举类型，如果没有<code>case</code>，或者所有<code>case</code>已知，且所有的<code>case</code>都有关联值，而所有的关联值类型都为空；</li><li>元组、结构体或者类，如果有任意的<code>uninhabited type</code>类型的存储属性；</li></ol><blockquote><p>If an expression of uninhabited type is evaluated, it is considered unreachable by control flow diagnostics.</p></blockquote><p>另外，函数和元类型不能是<code>uninhabited type</code>。</p><p>参考</p><ol><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0102-noreturn-bottom-type.md" target="_blank" rel="noopener">Remove @noreturn attribute and introduce an empty Never type</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift打印对象的地址</title>
      <link href="/2017/02/01/2017/2/swift-da-yin-dui-xiang-de-di-zhi/"/>
      <url>/2017/02/01/2017/2/swift-da-yin-dui-xiang-de-di-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift打印对象的地址"><a href="#Swift打印对象的地址" class="headerlink" title="Swift打印对象的地址"></a>Swift打印对象的地址</h2><p>在<code>Swift</code>中，我们可以使用<code>withUnsafePointer(to:_:)</code>函数来获取一个变量的指针，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">3.14</span><span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token string">"foo"</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token function">NSObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">withUnsafePointer</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>ptr <span class="token keyword">in</span> <span class="token function">print</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">withUnsafePointer</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>ptr <span class="token keyword">in</span> <span class="token function">print</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">withUnsafePointer</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token operator">&amp;</span>z<span class="token punctuation">)</span> <span class="token punctuation">{</span>ptr <span class="token keyword">in</span> <span class="token function">print</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">withUnsafePointer</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token operator">&amp;</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>ptr <span class="token keyword">in</span> <span class="token function">print</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出</span><span class="token comment" spellcheck="true">// 0x000000011a145660</span><span class="token comment" spellcheck="true">// 0x000000011a145668</span><span class="token comment" spellcheck="true">// 0x000000011a145670</span><span class="token comment" spellcheck="true">// 0x000000011a145688</span></code></pre><p><code>withUnsafePointer(to:_:)</code>将第一个参数转换为指针，然后将这个指针作为参数去调用第二个参数指定的闭包。如果闭包有返回值，它将作为函数的返回值。</p><p>需要注意的是，生成的指针的生命周期限定于闭包内部，不能将其指定给外部的变量。</p><p>第二种打印变量的指针的方式如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">3.14</span><span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token string">"foo"</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token function">NSObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> printPointer<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>ptr<span class="token punctuation">:</span> <span class="token builtin">UnsafePointer</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">printPointer</span><span class="token punctuation">(</span>ptr<span class="token punctuation">:</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token function">printPointer</span><span class="token punctuation">(</span>ptr<span class="token punctuation">:</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token function">printPointer</span><span class="token punctuation">(</span>ptr<span class="token punctuation">:</span> <span class="token operator">&amp;</span>z<span class="token punctuation">)</span><span class="token function">printPointer</span><span class="token punctuation">(</span>ptr<span class="token punctuation">:</span> <span class="token operator">&amp;</span>obj<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 输出</span><span class="token comment" spellcheck="true">// 0x000000011a145660</span><span class="token comment" spellcheck="true">// 0x000000011a145668</span><span class="token comment" spellcheck="true">// 0x000000011a145670</span><span class="token comment" spellcheck="true">// 0x000000011a145688</span></code></pre><p>参考</p><ol><li>[withUnsafePointer(to:_:)](</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift中操作符优先级</title>
      <link href="/2017/02/01/2017/2/swift-zhong-cao-zuo-fu-you-xian-ji/"/>
      <url>/2017/02/01/2017/2/swift-zhong-cao-zuo-fu-you-xian-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift中操作符优先级"><a href="#Swift中操作符优先级" class="headerlink" title="Swift中操作符优先级"></a>Swift中操作符优先级</h2><p><code>Swift 3</code>中改进了操作符的优先级及结合性的声明方式。</p><p>在<code>Swift 3</code>之前，是使用<code>magic numbers</code>(魔数)的方式来声明操作符的优先级，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span><span class="token operator">~</span> <span class="token punctuation">{</span>    <span class="token keyword">associativity</span> <span class="token keyword">left</span>    <span class="token keyword">precedence</span> <span class="token number">125</span><span class="token punctuation">}</span></code></pre><p><code>magic numbers</code>总归是一个不好的东西，所以<code>Swift 3</code>改用<code>precedence groups</code>(优先级组)的方式来声明操作符的优先级，如下代码所示：</p><pre class=" language-swift"><code class="language-swift">precedencegroup <span class="token builtin">Equivalence</span> <span class="token punctuation">{</span>    <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">left</span>    higherThan<span class="token punctuation">:</span> <span class="token builtin">LogicalConjunctionPrecedence</span>    lowerThan<span class="token punctuation">:</span> <span class="token builtin">ComparisonPrecedence</span><span class="token punctuation">}</span><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">~</span> <span class="token punctuation">:</span> <span class="token builtin">Equivalence</span></code></pre><p>系统为我们提供了一些默认的<code>precedence groups</code>，如下代码所示：</p><pre class=" language-swift"><code class="language-swift">precedencegroup <span class="token builtin">AssignmentPrecedence</span> <span class="token punctuation">{</span>  assignment<span class="token punctuation">:</span> <span class="token boolean">true</span>  <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">right</span><span class="token punctuation">}</span>precedencegroup <span class="token builtin">TernaryPrecedence</span> <span class="token punctuation">{</span>  <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">right</span>  higherThan<span class="token punctuation">:</span> <span class="token builtin">AssignmentPrecedence</span><span class="token punctuation">}</span>precedencegroup <span class="token builtin">DefaultPrecedence</span> <span class="token punctuation">{</span>  higherThan<span class="token punctuation">:</span> <span class="token builtin">TernaryPrecedence</span><span class="token punctuation">}</span>precedencegroup <span class="token builtin">LogicalDisjunctionPrecedence</span> <span class="token punctuation">{</span>  <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">left</span>  higherThan<span class="token punctuation">:</span> <span class="token builtin">TernaryPrecedence</span><span class="token punctuation">}</span>precedencegroup <span class="token builtin">LogicalConjunctionPrecedence</span> <span class="token punctuation">{</span>  <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">left</span>  higherThan<span class="token punctuation">:</span> <span class="token builtin">LogicalDisjunctionPrecedence</span><span class="token punctuation">}</span>precedencegroup <span class="token builtin">ComparisonPrecedence</span> <span class="token punctuation">{</span>  higherThan<span class="token punctuation">:</span> <span class="token builtin">LogicalConjunctionPrecedence</span><span class="token punctuation">}</span>precedencegroup <span class="token builtin">NilCoalescingPrecedence</span> <span class="token punctuation">{</span>  <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">right</span>  higherThan<span class="token punctuation">:</span> <span class="token builtin">ComparisonPrecedence</span><span class="token punctuation">}</span>precedencegroup <span class="token builtin">CastingPrecedence</span> <span class="token punctuation">{</span>  higherThan<span class="token punctuation">:</span> <span class="token builtin">NilCoalescingPrecedence</span><span class="token punctuation">}</span>precedencegroup <span class="token builtin">RangeFormationPrecedence</span> <span class="token punctuation">{</span>  higherThan<span class="token punctuation">:</span> <span class="token builtin">CastingPrecedence</span><span class="token punctuation">}</span>precedencegroup <span class="token builtin">AdditionPrecedence</span> <span class="token punctuation">{</span>  <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">left</span>  higherThan<span class="token punctuation">:</span> <span class="token builtin">RangeFormationPrecedence</span><span class="token punctuation">}</span>precedencegroup <span class="token builtin">MultiplicationPrecedence</span> <span class="token punctuation">{</span>  <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">left</span>  higherThan<span class="token punctuation">:</span> <span class="token builtin">AdditionPrecedence</span><span class="token punctuation">}</span>precedencegroup <span class="token builtin">BitwiseShiftPrecedence</span> <span class="token punctuation">{</span>  higherThan<span class="token punctuation">:</span> <span class="token builtin">MultiplicationPrecedence</span><span class="token punctuation">}</span></code></pre><p>参考</p><ol><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0077-operator-precedence.md" target="_blank" rel="noopener">Improved operator declarations</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift在扩展中重写父类方法</title>
      <link href="/2017/02/01/2017/2/swift-zai-kuo-zhan-zhong-chong-xie-fu-lei-fang-fa/"/>
      <url>/2017/02/01/2017/2/swift-zai-kuo-zhan-zhong-chong-xie-fu-lei-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift在扩展中重写父类方法"><a href="#Swift在扩展中重写父类方法" class="headerlink" title="Swift在扩展中重写父类方法"></a>Swift在扩展中重写父类方法</h2><p><code>Swift</code>在类的<code>extension</code>中，如果想重写父类的方法，会有以下两个限制(不局限于这两个，可能还有其它)：</p><ol><li>类本身必须是NSObject体系下的类，且要重写的方法的参数、返回值不能带有纯Swift的类/结构体/枚举；</li><li>不能使用inout参数；</li></ol><p>当然参数和返回值的类型如果是<code>String</code>、<code>Array</code>、<code>Dictionary</code>、<code>Set</code>这些也是OK的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift中打印线程调用栈</title>
      <link href="/2017/02/01/2017/2/swift-zhong-da-yin-xian-cheng-diao-yong-zhan/"/>
      <url>/2017/02/01/2017/2/swift-zhong-da-yin-xian-cheng-diao-yong-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift中打印线程调用栈"><a href="#Swift中打印线程调用栈" class="headerlink" title="Swift中打印线程调用栈"></a>Swift中打印线程调用栈</h2><p>在<code>Swift 3</code>中，如果想打印线程的调用栈，可以简单的使用<code>Thread.callStackSymbols</code>，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> symbol <span class="token keyword">in</span> <span class="token builtin">Thread</span><span class="token punctuation">.</span>callStackSymbols <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 0   ???                                 0x00000001198270a1 0x0 + 4722946209</span><span class="token comment" spellcheck="true">// 1   MyPlayground                        0x0000000106051730 main + 0</span><span class="token comment" spellcheck="true">// 2   CoreFoundation                      0x000000010989620c __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12</span><span class="token comment" spellcheck="true">// 3   CoreFoundation                      0x000000010987aa3b __CFRunLoopDoBlocks + 203</span><span class="token comment" spellcheck="true">// 4   CoreFoundation                      0x000000010987a214 __CFRunLoopRun + 1300</span><span class="token comment" spellcheck="true">// 5   CoreFoundation                      0x0000000109879a89 CFRunLoopRunSpecific + 409</span><span class="token comment" spellcheck="true">// 6   GraphicsServices                    0x000000010d5e79c6 GSEventRunModal + 62</span><span class="token comment" spellcheck="true">// 7   UIKit                               0x0000000106af5d30 UIApplicationMain + 159</span><span class="token comment" spellcheck="true">// 8   MyPlayground                        0x00000001060517f9 main + 201</span><span class="token comment" spellcheck="true">// 9   libdyld.dylib                       0x00000001062e5d81 start + 1</span><span class="token comment" spellcheck="true">// 10  ???                                 0x0000000000000001 0x0 + 1</span></code></pre><p>如果想使用C函数<code>backtrace</code>，需要在<code>bridging header file</code>中导入<code>execinfo.h</code>头文件，然后如理代码所示，记得最后需要用<code>free</code>释放<code>symbols</code>。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> callstack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">UnsafeMutableRawPointer</span><span class="token operator">?</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token keyword">let</span> frames <span class="token operator">=</span> <span class="token function">backtrace</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>callstack<span class="token punctuation">,</span> <span class="token function">Int32</span><span class="token punctuation">(</span>callstack<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token keyword">let</span> symbols <span class="token operator">=</span> <span class="token function">backtrace_symbols</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>callstack<span class="token punctuation">,</span> frames<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> frame <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token function">Int</span><span class="token punctuation">(</span>frames<span class="token punctuation">)</span> <span class="token keyword">where</span> symbols<span class="token punctuation">[</span>frame<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> symbol <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>cString<span class="token punctuation">:</span> symbols<span class="token punctuation">[</span>frame<span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">)</span>        <span class="token function">print</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">free</span><span class="token punctuation">(</span>symbols<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>参考</p><ol><li><a href="http://stackoverflow.com/questions/40801545/how-to-call-backtrace-symbols-in-swift" target="_blank" rel="noopener">how to call backtrace_symbols() in swift</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SwiftLint</title>
      <link href="/2017/02/01/2017/2/swiftlint/"/>
      <url>/2017/02/01/2017/2/swiftlint/</url>
      
        <content type="html"><![CDATA[<h2 id="SwiftLint"><a href="#SwiftLint" class="headerlink" title="SwiftLint"></a>SwiftLint</h2><p><code>realm</code>开源了一套<code>Swift</code>代码规范检测工具<a href="https://github.com/realm/SwiftLint" target="_blank" rel="noopener">SwiftLint</a>，它可以对代码做静态分析，以确定代码是否遵循所定制的规范(目前主要基于<a href="https://github.com/github/swift-style-guide" target="_blank" rel="noopener">Github的编码规范</a>)。</p><p>SwiftLint目前有70+条<a href="https://github.com/realm/SwiftLint/blob/master/Source/SwiftLintFramework/Rules" target="_blank" rel="noopener">规则</a>，同时社区还在不断贡献新的规则。支持的编辑器包括<code>Xcode</code>、<code>AppCode</code>、<code>Atom</code>，同时还支持命令行。</p><p>其执行的基本效果如下图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/02/04-1-1.png?raw=true" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift RawRepresentable</title>
      <link href="/2017/02/01/2017/2/swift-rawrepresentable/"/>
      <url>/2017/02/01/2017/2/swift-rawrepresentable/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift-RawRepresentable"><a href="#Swift-RawRepresentable" class="headerlink" title="Swift RawRepresentable"></a>Swift RawRepresentable</h2><p><code>Swift</code>编译器自动为带有<code>raw type</code>的<code>enum</code>添加了<code>RawRepresentable</code>协议的实现。<code>RawRepresentable</code>协议的定义如代码清单11-1-1所示，它可以为某个类型定义一个关联的<code>raw value</code>，并在两者之间切换。如下代码所示是一个典型的带<code>raw value</code>的枚举。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> protocol <span class="token builtin">RawRepresentable</span> <span class="token punctuation">{</span>    associatedtype <span class="token builtin">RawValue</span>    <span class="token keyword">public</span> <span class="token keyword">init</span><span class="token operator">?</span><span class="token punctuation">(</span>rawValue<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token builtin">RawValue</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">var</span> rawValue<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token builtin">RawValue</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Counter</span><span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> one <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> two<span class="token punctuation">,</span> three<span class="token punctuation">,</span> four<span class="token punctuation">,</span> five<span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">3</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token function">Counter</span><span class="token punctuation">(</span>rawValue<span class="token punctuation">:</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出</span><span class="token comment" spellcheck="true">// Optional(__lldb_expr_197.Counter.three)</span><span class="token comment" spellcheck="true">// Optional(__lldb_expr_197.Counter.four)</span><span class="token comment" spellcheck="true">// Optional(__lldb_expr_197.Counter.five)</span><span class="token comment" spellcheck="true">// nil</span></code></pre><p>参考</p><ol><li><a href="https://developer.apple.com/reference/swift/rawrepresentable" target="_blank" rel="noopener">RawRepresentable</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS动画应用内处理的4个阶段</title>
      <link href="/2017/02/01/2017/2/ios-dong-hua-ying-yong-nei-chu-li-de-4-ge-jie-duan/"/>
      <url>/2017/02/01/2017/2/ios-dong-hua-ying-yong-nei-chu-li-de-4-ge-jie-duan/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS动画应用内处理的4个阶段"><a href="#iOS动画应用内处理的4个阶段" class="headerlink" title="iOS动画应用内处理的4个阶段"></a>iOS动画应用内处理的4个阶段</h2><p>在iOS中，动画的执行主要分6个阶段，其中4个阶段是在应用内部处理的：</p><ol><li><strong>Layout</strong>: 这一阶段是准备好<code>view/layer</code>的层级结构并设置layer的属性；</li><li><strong>Display</strong>: 这一阶段将绘制<code>layer</code>的内容。绘制操作会调用<code>-drawRect:</code>或<code>-drawLayer:inContext:</code>方法；</li><li><strong>准备阶段</strong>: 这一阶段是<code>Core Animation</code>准备将动画数据发送给<code>render server</code>。另外，还会执行其它一些操作，如解压在动画过程中显示的图片；</li><li><strong>提交</strong>: 这是应用内部处理的最后一个阶段，<code>Core Animation</code>将打包<code>layer</code>及动画属性并通过<code>IPC</code>发送到<code>render server</code>；</li></ol><p>这几个阶段都是由CPU来处理的，而且我们只能控制前面两个阶段，后两个阶段将由<code>Core Animation</code>来控制。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Never类型</title>
      <link href="/2017/02/01/2017/2/never-lei-xing/"/>
      <url>/2017/02/01/2017/2/never-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="Never类型"><a href="#Never类型" class="headerlink" title="Never类型"></a>Never类型</h2><p>之前有一条知识小集讲了可以用 <code>@noreturn</code> 用来修饰函数，以告诉编译器函数永远不返回值给调用方。如下代码是原来的<code>fatalError</code>的声明。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function">fatalError</span><span class="token punctuation">(</span><span class="token number">_</span> message<span class="token punctuation">:</span> @<span class="token function">autoclosure</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">,</span> file<span class="token punctuation">:</span> <span class="token builtin">StaticString</span> <span class="token operator">=</span> #file<span class="token punctuation">,</span> line<span class="token punctuation">:</span> <span class="token builtin">UInt</span> <span class="token operator">=</span> #line<span class="token punctuation">)</span></code></pre><p>不过作为函数类型的一个正交属性，它与函数声明的其它一些属性一起使用时会产生一些歧义，如与<code>@throws</code>和<code>non-void</code>返回值。如当成 <code>@throws</code> 一起使用时，可能会困惑指”无法正常返回，但可以抛出异常”，还是”完全无法返回”？</p><p>所以现在使用Never枚举类型来替代<code>@noreturn</code>，以消除这种歧义，所以<code>fatalError</code>现在声明如下代码所示。这样() throws -&gt; Never就好理解了，即”不能正常返回，但可能抛出异常”。</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">/// Unconditionally prints a given message and stops execution.</span><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// - Parameters:</span><span class="token comment" spellcheck="true">///   - message: The string to print. The default is an empty string.</span><span class="token comment" spellcheck="true">///   - file: The file name to print with `message`. The default is the file</span><span class="token comment" spellcheck="true">///     where `fatalError(_:file:line:)` is called.</span><span class="token comment" spellcheck="true">///   - line: The line number to print along with `message`. The default is the</span><span class="token comment" spellcheck="true">///     line number where `fatalError(_:file:line:)` is called.</span><span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function">fatalError</span><span class="token punctuation">(</span><span class="token number">_</span> message<span class="token punctuation">:</span> @<span class="token function">autoclosure</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">,</span> file<span class="token punctuation">:</span> <span class="token builtin">StaticString</span> <span class="token operator">=</span> #file<span class="token punctuation">,</span> line<span class="token punctuation">:</span> <span class="token builtin">UInt</span> <span class="token operator">=</span> #line<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Never</span></code></pre><p>需要注意的是<code>Never</code>是一个空枚举，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">/// The return type of functions that do not return normally; a type with no</span><span class="token comment" spellcheck="true">/// values.</span><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Use `Never` as the return type when declaring a closure, function, or</span><span class="token comment" spellcheck="true">/// method that unconditionally throws an error, traps, or otherwise does</span><span class="token comment" spellcheck="true">/// not terminate.</span><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">///     func crashAndBurn() -> Never {</span><span class="token comment" spellcheck="true">///         fatalError("Something very, very bad happened")</span><span class="token comment" spellcheck="true">///     }</span><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token builtin">Never</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>参考</p><ol><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0102-noreturn-bottom-type.md" target="_blank" rel="noopener">Remove @noreturn attribute and introduce an empty Never type</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift Compile Warning</title>
      <link href="/2017/02/01/2017/2/swift-compile-warning/"/>
      <url>/2017/02/01/2017/2/swift-compile-warning/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift-Compile-Warning"><a href="#Swift-Compile-Warning" class="headerlink" title="Swift Compile Warning"></a>Swift Compile Warning</h2><p>在<code>Swift</code>中，我们通常会用<code>FIXME/TODO/MARK</code>来做一些注释标注，这些标注在代码的<code>dropdown box</code>中能显示出来，如下图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/02/23-1-1.png?raw=true" alt></p><p>不过，如果我们标注的是一些警告或错误信息的话，这用方式通常比较容易遗忘，不像<code>Objective-C</code>中的<code>#warning</code>一样，在编译时能被检测出来。</p><p>如果我们想在编译时让编译器高亮提示，即如下图所示，</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/02/23-1-2.png?raw=true" alt></p><p>则可以在<code>Build Phases</code>中添加一个<code>Run Script</code>，脚本代码如下图所示：</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/02/23-1-3.png?raw=true" alt></p><p>可以看到，我们还能添加自定义的注释标签，如<code>WARNING/ERROR</code>。</p><p>参考</p><ol><li><a href="https://krakendev.io/blog/generating-warnings-in-xcode" target="_blank" rel="noopener">HOW TO HIGHLIGHT YOUR TODOS, FIXMES, &amp; ERRORS IN XCODE</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Repeated结构体</title>
      <link href="/2017/02/01/2017/2/repeated-jie-gou-ti/"/>
      <url>/2017/02/01/2017/2/repeated-jie-gou-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="Repeated结构体"><a href="#Repeated结构体" class="headerlink" title="Repeated结构体"></a>Repeated结构体</h2><p><code>Swift</code>提供了一个<code>Repeated</code>结构体，用于表示一个所有元素都相同的集合。我们可以使用<code>repeatElement(_:count:)</code>函数来创建<code>Repeated</code>集合，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> repeatedName <span class="token operator">=</span> <span class="token function">repeatElement</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">for</span> name <span class="token keyword">in</span> repeatedName <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出</span><span class="token comment" spellcheck="true">// test</span><span class="token comment" spellcheck="true">// test</span><span class="token comment" spellcheck="true">// test</span><span class="token comment" spellcheck="true">// test</span><span class="token comment" spellcheck="true">// test</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Autolayout Theory</title>
      <link href="/2017/02/01/2017/2/autolayout-theory/"/>
      <url>/2017/02/01/2017/2/autolayout-theory/</url>
      
        <content type="html"><![CDATA[<h2 id="Autolayout-Theory"><a href="#Autolayout-Theory" class="headerlink" title="Autolayout Theory"></a>Autolayout Theory</h2><p><code>View hierarchy</code>的<code>layout</code>可以定义为一系列的线性方程式。每个约束都表示一个方程式，大部分约束定义的是两个视图之间的关系，当然也可以是一个视图的两个不同的属性之间的关系，如高宽比。</p><p>下图是文档中给出的一个等式样例，</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/02/18-1-1.png?raw=true" alt></p><p>下图是一个基本的解释，</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/02/18-1-2.png?raw=true" alt></p><p>参考</p><ol><li><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1" target="_blank" rel="noopener">Auto Layout Guide</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ArraySlice的用途</title>
      <link href="/2017/02/01/2017/2/arrayslice-de-yong-tu/"/>
      <url>/2017/02/01/2017/2/arrayslice-de-yong-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="ArraySlice的用途"><a href="#ArraySlice的用途" class="headerlink" title="ArraySlice的用途"></a>ArraySlice的用途</h2><p><code>Swift</code>提供了<code>ArraySlice</code>来执行数组的切片操作。类似于其它语言中的切片(如Python)，<code>ArraySlice</code>对象复用了原始数组的存储结构，而不是新开辟一块内存区域来将数组片断的元素拷贝过来。因此，它能让我们快速高效地对大数组的片段执行操作。如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token number">1000</span> <span class="token punctuation">{</span>    array<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> slice <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token number">300</span><span class="token punctuation">]</span><span class="token keyword">let</span> result <span class="token operator">=</span> slice<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span>    $<span class="token number">0</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        $<span class="token number">0</span> <span class="token operator">+</span> $<span class="token number">1</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">// 79800</span></code></pre><p><code>ArraySlice</code>与<code>Array</code>有相同的接口，所以通常可以在切片数组上执行与原始数组相同的操作。</p><p>参考</p><ol><li>[ArraySlice](</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ArraySlice使用注意事项</title>
      <link href="/2017/02/01/2017/2/arrayslice-shi-yong-zhu-yi-shi-xiang/"/>
      <url>/2017/02/01/2017/2/arrayslice-shi-yong-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="ArraySlice使用注意事项"><a href="#ArraySlice使用注意事项" class="headerlink" title="ArraySlice使用注意事项"></a>ArraySlice使用注意事项</h2><p>使用<code>ArraySlice</code>时，需要注意两点：</p><ul><li><code>ArraySlice</code>会维持对原始数组的一个强引用，而不仅仅是它所表示的片断。这样即使原始数组对象的生命周期结束了，也可能无法释放。所以不建议长期存储<code>ArraySlice</code>对象，仅用于临时操作。如下代码所示：</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> index<span class="token punctuation">:</span> <span class="token builtin">Int</span>    <span class="token keyword">init</span><span class="token punctuation">(</span>index<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>index <span class="token operator">=</span> index    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ViewController</span><span class="token punctuation">:</span> <span class="token builtin">UIViewController</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> slice<span class="token punctuation">:</span> <span class="token builtin">ArraySlice</span><span class="token operator">&lt;</span><span class="token builtin">MyClass</span><span class="token operator">></span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token constant">nil</span>    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">var</span> array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">MyClass</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token number">100</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> clz <span class="token operator">=</span> <span class="token function">MyClass</span><span class="token punctuation">(</span>index<span class="token punctuation">:</span> i<span class="token punctuation">)</span>            array<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>clz<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        slice <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token number">30</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>array</code>在生命周期结束后不会释放，如下图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/02/08-2-1.png?raw=true" alt="8-1-1"></p><ul><li>与<code>Array</code>不同的是，<code>ArraySlice</code>起始索引不一定是0，而是取决于其创建方式。一般是采用共享索引的方式，即<code>ArraySlice</code>对象的起始索引就是切片的开始位置，如代码清单8-2-2所示，切片是从100开始，所以<code>slice[100]</code>是OK的，而<code>slice[99]</code>会报越界错误。通常建议使用<code>startIndex</code>和<code>endIndex</code>来取代指定的索引值，如下代码所示。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token number">1000</span> <span class="token punctuation">{</span>    array<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> slice <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token number">300</span><span class="token punctuation">]</span>slice<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span>slice<span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true">// fatal error: Index out of bounds</span></code></pre><pre class=" language-swift"><code class="language-swift">slice<span class="token punctuation">[</span>slice<span class="token punctuation">.</span>startIndex<span class="token punctuation">]</span>         <span class="token comment" spellcheck="true">// 100</span>slice<span class="token punctuation">[</span>slice<span class="token punctuation">.</span>endIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true">// 299</span></code></pre><p>参考</p><ol><li>[ArraySlice](</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>导致layer绘制的性能问题</title>
      <link href="/2017/02/01/2017/2/dao-zhi-layer-hui-zhi-de-xing-neng-wen-ti/"/>
      <url>/2017/02/01/2017/2/dao-zhi-layer-hui-zhi-de-xing-neng-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="导致layer绘制的性能问题"><a href="#导致layer绘制的性能问题" class="headerlink" title="导致layer绘制的性能问题"></a>导致layer绘制的性能问题</h2><p><code>CALayer</code>的大部分属性都是通过<code>GPU</code>来绘制的。以下几类操作可能导致<code>layer</code>绘制的性能问题：</p><ol><li><strong>过多的几何形状</strong>：这里的瓶颈主要是在对<code>layer</code>的预处理及通过<code>IPC</code>发送到<code>render server</code>这个过程，即<code>CPU</code>的处理，而不是<code>GPU</code>的绘制；</li><li><strong>过多的重绘</strong>(<code>overdraw</code>)：这主要是由绘制重叠的半透明层引起的；</li><li><strong>离屏渲染</strong>：这个应该比较熟悉，诸如<code>layer</code>的圆角绘制、mask、阴影等操作都会导致离屏渲染，主要是因为需要为离屏绘制的图片分配额外的内存并在绘制上下文之间切换；</li><li><strong>过大的图片</strong>：如果图片大小超过GPU所支持的最大纹理大小，则在绘制前CPU需要去做预处理。</li></ol><p>参考</p><p>iOS Core Animation Advanced Techniques</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>尾调用优化</title>
      <link href="/2017/02/01/2017/2/wei-diao-yong-you-hua/"/>
      <url>/2017/02/01/2017/2/wei-diao-yong-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>尾调用是指一个函数里的最后一个动作是一个函数调用的情形：即这个调用的返回值直接被当前函数返回。我们知道在函数调用时，会在内存中生成一个调用记录，即调用帧(<code>call frame</code>)，用于保存调用位置和内部变量等信息。而尾调用由于是函数的最后一步操作，所以可以不在调用栈上添加一个新的调用帧，而是直接更新外层函数的调用帧，这种处理方式即尾调用优化(<code>Tail Call Optimization, TCO</code>)。</p><p>尾递归也是一种尾调用，通过<code>TCO</code>，可以使原本 <code>O(n)</code>的调用栈空间只需要 <code>O(1)</code>。</p><p>一些语言会针对尾递归做一些<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">优化</a>，但<code>Swift</code>不确保在所有情况下都做了优化。</p><p>参考</p><ol><li><a href="http://stackoverflow.com/questions/24023580/does-swift-implement-tail-call-optimization-and-in-mutual-recursion-case" target="_blank" rel="noopener">Does Swift implement tail call optimization? and in mutual recursion case?</a></li><li><a href="https://www.natashatherobot.com/functional-swift-tail-recursion/" target="_blank" rel="noopener">Functional Swift: Tail Recursion Explained</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">尾调用</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查看一个对象的类型是否为Optional</title>
      <link href="/2017/02/01/2017/2/cha-kan-yi-ge-dui-xiang-de-lei-xing-shi-fou-wei-optional/"/>
      <url>/2017/02/01/2017/2/cha-kan-yi-ge-dui-xiang-de-lei-xing-shi-fou-wei-optional/</url>
      
        <content type="html"><![CDATA[<h2 id="查看一个对象的类型是否为Optional"><a href="#查看一个对象的类型是否为Optional" class="headerlink" title="查看一个对象的类型是否为Optional"></a>查看一个对象的类型是否为Optional</h2><p>在<code>Swift</code>中，如果想在运行时判断一个对象的类型是不是可选类型，则可以使用<code>Mirror</code>，如下代码所示，所有的可选类型都将返回<code>optional</code>。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> value<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token function">Mirror</span><span class="token punctuation">(</span>reflecting<span class="token punctuation">:</span> value<span class="token punctuation">)</span><span class="token punctuation">.</span>displayStyle        <span class="token comment" spellcheck="true">// optional</span></code></pre><p><code>Mirror</code>的<code>displayStyle</code>属性的类型是<code>Mirror.DisplayStyle</code>，这是一个枚举类型，用于为<code>Mirror</code>的主体对象提供一种建议性的解析，其定义如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">/// A suggestion of how a `Mirror`'s `subject` is to be interpreted.</span><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Playgrounds and the debugger will show a representation similar</span><span class="token comment" spellcheck="true">/// to the one used for instances of the kind indicated by the</span><span class="token comment" spellcheck="true">/// `DisplayStyle` case name when the `Mirror` is used for display.</span><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token builtin">DisplayStyle</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> `<span class="token keyword">struct</span>`    <span class="token keyword">case</span> `<span class="token keyword">class</span>`    <span class="token keyword">case</span> `<span class="token keyword">enum</span>`    <span class="token keyword">case</span> tuple    <span class="token keyword">case</span> <span class="token keyword">optional</span>    <span class="token keyword">case</span> collection    <span class="token keyword">case</span> dictionary    <span class="token keyword">case</span> <span class="token keyword">set</span><span class="token punctuation">}</span></code></pre><p>枚举值范围之外的类型，其<code>Mirror</code>的<code>displayStyle</code>属性将返回<code>nil</code>，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> value<span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token function">Mirror</span><span class="token punctuation">(</span>reflecting<span class="token punctuation">:</span> value<span class="token punctuation">)</span><span class="token punctuation">.</span>displayStyle        <span class="token comment" spellcheck="true">// nil</span><span class="token keyword">let</span> str<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token string">"30"</span><span class="token function">Mirror</span><span class="token punctuation">(</span>reflecting<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">.</span>displayStyle        <span class="token comment" spellcheck="true">// nil</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义操作符中的.</title>
      <link href="/2017/02/01/2017/2/zi-ding-yi-cao-zuo-fu-zhong-de./"/>
      <url>/2017/02/01/2017/2/zi-ding-yi-cao-zuo-fu-zhong-de./</url>
      
        <content type="html"><![CDATA[<h2 id="自定义操作符中的"><a href="#自定义操作符中的" class="headerlink" title="自定义操作符中的."></a>自定义操作符中的.</h2><p>在自定义操作符时，可以以dot(.)开头，这种情况下，操作符后面还可以包含其它的dot(.)，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token punctuation">.</span><span class="token operator">+</span><span class="token punctuation">.</span><span class="token keyword">struct</span> <span class="token builtin">Vector2D</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> x<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span>    <span class="token keyword">var</span> y<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span><span class="token punctuation">}</span><span class="token keyword">extension</span> <span class="token builtin">Vector2D</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token punctuation">.</span><span class="token operator">+</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">left</span><span class="token punctuation">:</span> <span class="token builtin">Vector2D</span><span class="token punctuation">,</span> <span class="token keyword">right</span><span class="token punctuation">:</span> <span class="token builtin">Vector2D</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Vector2D</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">Vector2D</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">left</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token keyword">right</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">left</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token keyword">right</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> vector1 <span class="token operator">=</span> <span class="token function">Vector2D</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token keyword">let</span> vector2 <span class="token operator">=</span> <span class="token function">Vector2D</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">let</span> vector <span class="token operator">=</span> vector1 <span class="token punctuation">.</span><span class="token operator">+</span><span class="token punctuation">.</span> vector2vector<span class="token punctuation">.</span>xvector<span class="token punctuation">.</span>y</code></pre><p>但如果操作符不是以<code>dot</code>开头，则后面不能再包含<code>dot</code>，如<code>operator +.+</code>这个声明会被看成是”<code>+</code>“操作符后面跟了个”<code>.+</code>“操作符。编译器会给出如下错误提示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">+</span><span class="token punctuation">.</span><span class="token operator">+</span>        <span class="token comment" spellcheck="true">// error: operator with postfix spacing cannot start a subexpression</span></code></pre><p>参考</p><ol><li>[The Swift Programming Language (Swift 4) – Lexical Structure](</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS动画在系统中处理的2个阶段</title>
      <link href="/2017/02/01/2017/2/ios-dong-hua-zai-xi-tong-zhong-chu-li-de-2-ge-jie-duan/"/>
      <url>/2017/02/01/2017/2/ios-dong-hua-zai-xi-tong-zhong-chu-li-de-2-ge-jie-duan/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS动画在系统中处理的2个阶段"><a href="#iOS动画在系统中处理的2个阶段" class="headerlink" title="iOS动画在系统中处理的2个阶段"></a>iOS动画在系统中处理的2个阶段</h2><p>接上一条。打包的<code>layer</code>和动画发送到<code>render server</code>后，会被反序列化成<code>render tree</code>。<code>Render server</code>将对动画的每一帧执行以下两步操作：</p><ol><li>计算所有<code>layer</code>属性的中间值，并设置<code>OpenGL</code>的几何属性(如纹理三角形)来执行渲染操作；</li><li>渲染可见的三角形到屏幕上</li></ol><p>这两步操作在动画期间不断重复。第一步操作由<code>CPU</code>来完成，第二步操作<code>GPU</code>来完成。两步操作都是由系统控制。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift中的函数值</title>
      <link href="/2017/01/01/2017/1/swift-zhong-de-han-shu-zhi/"/>
      <url>/2017/01/01/2017/1/swift-zhong-de-han-shu-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift中的函数值"><a href="#Swift中的函数值" class="headerlink" title="Swift中的函数值"></a>Swift中的函数值</h2><p>我们知道在Swift中，函数是一等公民，即函数也是一种类型，可充当参数、返回值等角色，当然也可以定义函数类型的常量/变量。利用这个特性，在某些场景下可以简化我们的代码，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> setInt<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span> <span class="token operator">=</span> <span class="token builtin">UserDefaults</span><span class="token punctuation">.</span>standard<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token keyword">let</span> getInt<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token builtin">UserDefaults</span><span class="token punctuation">.</span>standard<span class="token punctuation">.</span>integer<span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">"key"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift的stride操作</title>
      <link href="/2017/01/01/2017/1/swift-zhong-lazy-zuo-duo-xing-qiu-zhi/"/>
      <url>/2017/01/01/2017/1/swift-zhong-lazy-zuo-duo-xing-qiu-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift的stride操作"><a href="#Swift的stride操作" class="headerlink" title="Swift的stride操作"></a>Swift的stride操作</h2><p>在Swift中，如果我们想创建一个一定步长的数组，可以如下代码操作：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Double</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> value <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token number">10</span> <span class="token punctuation">{</span>    array<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token function">Double</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>不过如果想在某个区间创建这样一个序列的话，会比较麻烦。为此，Swift提供了一个便捷函数：<code>stride</code>，可以在某个区间内创建一个任意可变步长的序列，这个步长可以是任意值。所以上面这个问题的实现可以如下代码处理：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token function">stride</span><span class="token punctuation">(</span>from<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> to<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> by<span class="token punctuation">:</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span>    $<span class="token number">0</span><span class="token punctuation">}</span></code></pre><p>实际上，<code>stride</code>的产生的序列如下代码：</p><p><code>start, start + stride, start + 2 * stride, …, start + n * stride</code></p><p><code>stride</code>有两个变种：</p><ol><li><code>stride(from:to:by)</code>，开区间处理，最后一个值严格小于最大值；</li><li><code>stride(from:through:by)</code>，闭区间处理，最后一个值小于或等于最大值</li></ol><p><code>stride</code>函数与<code>map</code>配合起来可以做一些有意思的事情。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift3移除var关键字</title>
      <link href="/2017/01/01/2017/1/swift3-yi-chu-var-guan-jian-zi/"/>
      <url>/2017/01/01/2017/1/swift3-yi-chu-var-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift3移除var关键字"><a href="#Swift3移除var关键字" class="headerlink" title="Swift3移除var关键字"></a>Swift3移除var关键字</h2><p><code>Swift 3</code>中移除了函数参数中的<code>var</code>关键字，<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md" target="_blank" rel="noopener">swift proposals SE-0003</a>中的观点是<code>var</code>标记的参数只是本地复本会变化，不会回传给原始值，因此调用者并不会知道参数值的改变，实际上没有太大的实用性。</p><p>移除<code>var</code>主要有几个原因：</p><ol><li><code>var</code>容易与<code>inout</code>混淆；</li><li><code>var</code>经常被混淆，以使值类型具有引用语义；</li><li>函数参数通常是不可重用的</li></ol><p>参考</p><ol><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md" target="_blank" rel="noopener">Removing var from Function Parameters</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift3移除Optional类型的比较操作</title>
      <link href="/2017/01/01/2017/1/swift3-yi-chu-optional-lei-xing-de-bi-jiao-cao-zuo/"/>
      <url>/2017/01/01/2017/1/swift3-yi-chu-optional-lei-xing-de-bi-jiao-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift3移除Optional类型的比较操作"><a href="#Swift3移除Optional类型的比较操作" class="headerlink" title="Swift3移除Optional类型的比较操作"></a>Swift3移除Optional类型的比较操作</h2><p><code>Swift 3</code>已经移除了<code>Optional</code>类型的比较操作，这在<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0121-remove-optional-comparison-operators.md" target="_blank" rel="noopener">Swift evolution SE-0121: Remove Optional Comparison Operators</a>这条中明确了这一点。</p><p>在<code>Swift 3</code>之前，标准库定义了4个操作符以支持<code>Optional</code>类型，如下图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/14-1-1.png?raw=true" alt></p><p>不过<code>Swift 3</code>中，由于泛型不支持条件一致性判断，即没有通用的方法来定义在比较nil和非nil值时，应该得到怎样的值，所以实际结果可能不是预期的。所以，在<code>Swift 3</code>中，如果去比较两个<code>Optional</code>值，会给出编译错误，如下代码所示。而这一比较在Swift 3之前是没有问题的。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> dic1 <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">"first"</span><span class="token punctuation">:</span> <span class="token string">"123"</span><span class="token punctuation">,</span>    <span class="token string">"last"</span><span class="token punctuation">:</span> <span class="token string">"234"</span><span class="token punctuation">]</span><span class="token keyword">let</span> dic2 <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">"first"</span><span class="token punctuation">:</span> <span class="token string">"123"</span><span class="token punctuation">,</span>    <span class="token string">"last"</span><span class="token punctuation">:</span> <span class="token string">"968"</span><span class="token punctuation">]</span>dic1<span class="token punctuation">[</span><span class="token string">"middle"</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> dic2<span class="token punctuation">[</span><span class="token string">"middle"</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">// value of optional type 'String?' not unwrapped; did you mean to use '!' or '?'?</span></code></pre><p>当然在SE-0121中也说了，等泛型更加成熟后，不排除会将这一特性再添加回来。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift3的#keyPath</title>
      <link href="/2017/01/01/2017/1/swift3-de-keypath/"/>
      <url>/2017/01/01/2017/1/swift3-de-keypath/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift3的-keyPath"><a href="#Swift3的-keyPath" class="headerlink" title="Swift3的#keyPath"></a>Swift3的#keyPath</h2><p>在<code>Objective-C/Swift</code>中使用<code>KVC</code>或<code>KVO</code>总是需要格外小心，因为对于<code>key</code>或<code>keyPath</code>，我们使用的是字符串字面量来处理。这样在编译期无法检测我们的输入是否正确，或许我们会因为一时大意，多写了或少写了一个字符，或拼错了单词。而这个错误只能在运行时，程序崩溃时才能发现，很不爽的吧。</p><p>为此，在<code>Swift 3</code>中引入了<code>#keyPath()</code>这个表达式，它接收<code>Object.property</code>形式的参数，并将其转换成字符串，如下代码所示。因为使用的是对象和属性的方式，所以在编译时，编译器能去检测这个表达式是否有效，从而避免了上面的问题。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">:</span> <span class="token builtin">NSObject</span> <span class="token punctuation">{</span>    <span class="token keyword">dynamic</span> <span class="token keyword">var</span> firstName<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token string">""</span>    <span class="token keyword">init</span><span class="token punctuation">(</span>firstName<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> chris <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span>firstName<span class="token punctuation">:</span> <span class="token string">"Chris"</span><span class="token punctuation">)</span>#<span class="token function">keyPath</span><span class="token punctuation">(</span><span class="token builtin">Person</span><span class="token punctuation">.</span>firstName<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// => "firstName"</span>chris<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>forKeyPath<span class="token punctuation">:</span> #<span class="token function">keyPath</span><span class="token punctuation">(</span><span class="token builtin">Person</span><span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>参考</p><ol><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md" target="_blank" rel="noopener">Referencing Objective-C key-paths</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift3中的AnyHashable</title>
      <link href="/2017/01/01/2017/1/swift3-zhong-de-anyhashable/"/>
      <url>/2017/01/01/2017/1/swift3-zhong-de-anyhashable/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift3中的AnyHashable"><a href="#Swift3中的AnyHashable" class="headerlink" title="Swift3中的AnyHashable"></a>Swift3中的AnyHashable</h2><p>在<code>Swift 3</code>的标准库中添加了<code>AnyHashable</code>这一新类型，其用途是在需要<code>Hash</code>值的集合中，可以混合使用多种<code>Hashable</code>类型。例如，字典的<code>key</code>值，其要求是<code>Hashable</code>类型，如果希望<code>key</code>值是任意实现了<code>Hashable</code>协议的类型，则在声明字典时，可以使用<code>AnyHashable</code>作为<code>key</code>的类型，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> description<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">AnyHashable</span><span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token function">AnyHashable</span><span class="token punctuation">(</span><span class="token string">"😄"</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token string">"emoji"</span><span class="token punctuation">,</span>    <span class="token function">AnyHashable</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token string">"an Int"</span><span class="token punctuation">,</span>    <span class="token function">AnyHashable</span><span class="token punctuation">(</span><span class="token number">34.2</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token string">"a Double"</span><span class="token punctuation">,</span>    <span class="token function">AnyHashable</span><span class="token punctuation">(</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token string">"a set of strings"</span><span class="token punctuation">]</span><span class="token function">print</span><span class="token punctuation">(</span>description<span class="token punctuation">[</span><span class="token function">AnyHashable</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// an Int</span><span class="token function">print</span><span class="token punctuation">(</span>description<span class="token punctuation">[</span><span class="token function">AnyHashable</span><span class="token punctuation">(</span><span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">// nil</span><span class="token function">print</span><span class="token punctuation">(</span>description<span class="token punctuation">[</span><span class="token function">AnyHashable</span><span class="token punctuation">(</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// a set of strings</span></code></pre><p>早先，在<code>ObjC</code>与<code>Swift</code>混合编程中，<code>ObjC</code>的<code>NSDictionary</code>导入到<code>Swift</code>时，是转换成<code>[NSObject: AnyObject]</code>类型。使用<code>NSObject</code>作为<code>key</code>的类型，因为<code>NSObject</code>是最接近于<code>AnyObject</code>且实现了<code>Hashable</code>的类型。不过<code>Swift</code>希望在标准库中限制<code>AnyObject</code>的使用，而更多的使用<code>Any</code>，所以加入了<code>AnyHashable</code>类型。</p><p>参考</p><ol><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0131-anyhashable.md" target="_blank" rel="noopener">Add AnyHashable to the standard library</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NSRecursiveLock递归锁的使用</title>
      <link href="/2017/01/01/2017/1/nsrecursivelock-di-gui-suo-de-shi-yong/"/>
      <url>/2017/01/01/2017/1/nsrecursivelock-di-gui-suo-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="NSRecursiveLock递归锁的使用"><a href="#NSRecursiveLock递归锁的使用" class="headerlink" title="NSRecursiveLock递归锁的使用"></a>NSRecursiveLock递归锁的使用</h2><p><code>NSRecursiveLock</code>定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。它主要是用在循环或递归操作中。我们先来看下面代码示例：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> lock <span class="token operator">=</span> <span class="token function">NSLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> recursiveMethod<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span><span class="token operator">!</span> <span class="token operator">=</span> <span class="token constant">nil</span>recursiveMethod <span class="token operator">=</span> <span class="token punctuation">{</span> value <span class="token keyword">in</span>  <span class="token keyword">defer</span> <span class="token punctuation">{</span>      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">guard</span> value <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span>  <span class="token punctuation">}</span>  <span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token function">recursiveMethod</span><span class="token punctuation">(</span>value <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>async <span class="token punctuation">{</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span>  <span class="token function">recursiveMethod</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这段代码是一个典型的死锁情况。在我们的线程中，<code>RecursiveMethod</code>是递归调用的。所以每次进入这个闭包函数时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出信息如下代码所示：</p><pre class=" language-swift"><code class="language-swift">start<span class="token number">5</span><span class="token number">2017</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">07</span> <span class="token number">12</span><span class="token punctuation">:</span><span class="token number">48</span><span class="token punctuation">:</span><span class="token number">26.580</span> <span class="token builtin">Test111</span><span class="token punctuation">[</span><span class="token number">3633</span><span class="token punctuation">:</span><span class="token number">116345</span><span class="token punctuation">]</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token operator">-</span><span class="token punctuation">[</span><span class="token builtin">NSLock</span> lock<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token function">deadlock</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token builtin">NSLock</span><span class="token punctuation">:</span> <span class="token number">0x6080000c4750</span><span class="token operator">></span> <span class="token string">'(null)'</span><span class="token punctuation">)</span><span class="token number">2017</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">07</span> <span class="token number">12</span><span class="token punctuation">:</span><span class="token number">48</span><span class="token punctuation">:</span><span class="token number">26.581</span> <span class="token builtin">Test111</span><span class="token punctuation">[</span><span class="token number">3633</span><span class="token punctuation">:</span><span class="token number">116345</span><span class="token punctuation">]</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token builtin">Break</span> on <span class="token function">_NSLockError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> to debug<span class="token punctuation">.</span></code></pre><p>在这种情况下，我们就可以使用<code>NSRecursiveLock</code>。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被<code>lock</code>的次数。每次成功的<code>lock</code>都必须平衡调用<code>unlock</code>操作。只有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p><p>所以，使用<code>NSRecursiveLock</code>对图1的代码进行一下改造，这样，程序就能正常运行了，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> lock <span class="token operator">=</span> <span class="token function">NSRecursiveLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> recursiveMethod<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span><span class="token operator">!</span> <span class="token operator">=</span> <span class="token constant">nil</span>recursiveMethod <span class="token operator">=</span> <span class="token punctuation">{</span> value <span class="token keyword">in</span>  <span class="token keyword">defer</span> <span class="token punctuation">{</span>      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">guard</span> value <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span>  <span class="token punctuation">}</span>  <span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token function">recursiveMethod</span><span class="token punctuation">(</span>value <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>async <span class="token punctuation">{</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span>  <span class="token function">recursiveMethod</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出</span><span class="token comment" spellcheck="true">// start</span><span class="token comment" spellcheck="true">// 5</span><span class="token comment" spellcheck="true">// 4</span><span class="token comment" spellcheck="true">// 3</span><span class="token comment" spellcheck="true">// 2</span><span class="token comment" spellcheck="true">// 1</span><span class="token comment" spellcheck="true">// end</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Injection代码注入</title>
      <link href="/2017/01/01/2017/1/injection-dai-ma-zhu-ru/"/>
      <url>/2017/01/01/2017/1/injection-dai-ma-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h2 id="Injection代码注入"><a href="#Injection代码注入" class="headerlink" title="Injection代码注入"></a>Injection代码注入</h2><p><code>Injection</code>是johnno开发的一个<code>Xcode</code>插件，允许我们将代码实现更快注入到模拟器运行的程序或macOS程序。原先可以通过<code>Alcatraz</code>安装到Xcode中，不过现在是独立的App了。可以在<a href="http://johnholdsworth.com/Injection.app.zip" target="_blank" rel="noopener">这里</a>下载安装。启动后会出现在屏幕顶部的工具栏中，如下图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/10-1-1.png?raw=true" alt></p><p>要检测是否有效，可以在某个类里面添加<code>injected</code>方法，然后打个断点。在代码修改后保存，然后注入，如果进入这个断点，则说明安装成功，同时控制器会有相应信息输出，如下图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/10-1-2.png?raw=true" alt></p><p><code>Injection</code>使用<code>AppleScript</code>来和Xcode进行通信，以确定当前的文件与工程，然后将代码注入到模拟器，再加载新代码，并将新代码替换原来的代码。其效果如下图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/10-1-3.gif?raw=true" alt></p><p><code>Injection</code>程序还包含一个<code>Xprobe</code>浏览器，用于查看程序的内存。可以选择图1中的<code>Load Xprobe</code>菜单项，弹出的窗口中显示了当前时间点的对象实例，我们可以在这做一些有意思的事情，如下图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/10-1-4.png?raw=true" alt></p><p><a href="https://github.com/johnno1962/injectionforxcode" target="_blank" rel="noopener">Injection工程源码</a></p><p><a href="https://johntmcintosh.com/blog/2016/10/03/code-injection-ios" target="_blank" rel="noopener">文档</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NSRecursiveLock.lock(before:)</title>
      <link href="/2017/01/01/2017/1/nsrecursivelock.lock/"/>
      <url>/2017/01/01/2017/1/nsrecursivelock.lock/</url>
      
        <content type="html"><![CDATA[<h2 id="NSRecursiveLock-lock-before"><a href="#NSRecursiveLock-lock-before" class="headerlink" title="NSRecursiveLock.lock(before:)"></a>NSRecursiveLock.lock(before:)</h2><p><code>NSRecursiveLock</code>递归锁提供了一个方法<code>lock(before:)</code>，用于在多线程情况下，去尝试请求一个递归锁，然后根据返回的布尔值，来做相应的处理。如下代码所示，是一个正常的递归锁调用过程：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> lock <span class="token operator">=</span> <span class="token function">NSRecursiveLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> recursiveMethod<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span><span class="token operator">!</span> <span class="token operator">=</span> <span class="token constant">nil</span>recursiveMethod <span class="token operator">=</span> <span class="token punctuation">{</span> value <span class="token keyword">in</span>  <span class="token keyword">defer</span> <span class="token punctuation">{</span>      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">guard</span> value <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span>  <span class="token punctuation">}</span>  <span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token function">recursiveMethod</span><span class="token punctuation">(</span>value <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>async <span class="token punctuation">{</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span>  <span class="token function">recursiveMethod</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在这个场景下，如果我们想另起一个线程，并且尝试去获取这个递归锁，则可以如下代码处理：</p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>async <span class="token punctuation">{</span>  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token keyword">let</span> flag <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span>before<span class="token punctuation">:</span> <span class="token function">Date</span><span class="token punctuation">(</span>timeIntervalSinceNow<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> flag <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"lock before date"</span><span class="token punctuation">)</span>      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"fail to lock before date"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当然这种情况下会失败，其输出如下所示。如果将<code>lock(before:)</code>中的时间设置长一点，则会打印出”lock befor date”。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift中的escaping-closure</title>
      <link href="/2017/01/01/2017/1/swift-zhong-de-escaping-closure/"/>
      <url>/2017/01/01/2017/1/swift-zhong-de-escaping-closure/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift中的escaping-closure"><a href="#Swift中的escaping-closure" class="headerlink" title="Swift中的escaping-closure"></a>Swift中的escaping-closure</h2><p>在Swift中使用<code>@escaping</code>来修饰一个逃逸闭包(<code>Escaping Closures</code>)，即闭包作为参数传到一个函数中时，这个闭包可以不在函数中调用，而在函数返回之后的某个时间再调用。如可以在函数中将闭包赋值给一个类的成员变量，或者保存在一个数组中，以备后续异步调用。这类闭包参数需要使用<code>@escaping</code>来修饰，否则会报错，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> handlers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">func</span> <span class="token function">complete</span><span class="token punctuation">(</span>handler<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    handlers<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// error: passing non-escaping parameter 'handler' to function expecting an @escaping closure</span><span class="token punctuation">}</span></code></pre><p>需要注意的一个问题是，如果在类中使用逃逸闭包，且闭包内要调用实例对象的属性或方法时，必须显式地引用<code>self</code>，否则会报错，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span>    <span class="token keyword">func</span> <span class="token function">testEscaping</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        complete <span class="token punctuation">{</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token keyword">in</span>            <span class="token function">print</span><span class="token punctuation">(</span>value <span class="token operator">+</span> x<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// error: reference to property 'x' in closure requires explicit 'self.' to make capture semantics explicit</span>        <span class="token punctuation">}</span>        handlers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Array.contains操作</title>
      <link href="/2017/01/01/2017/1/array.contains-cao-zuo/"/>
      <url>/2017/01/01/2017/1/array.contains-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="Array-contains操作"><a href="#Array-contains操作" class="headerlink" title="Array.contains操作"></a>Array.contains操作</h2><p>Swift中判断一个<code>Array</code>中是否包含某个元素，我们可以使用<code>contains</code>方法，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>array<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// false</span></code></pre><p>不过这个方法要求数组中的元素类型实现了<code>Equatable</code>协议，否则无法使用，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Animal</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> dog    <span class="token keyword">case</span> <span class="token function">cat</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> animals<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Animal</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>dog<span class="token punctuation">,</span> <span class="token punctuation">.</span>dog<span class="token punctuation">]</span><span class="token keyword">let</span> hasCat <span class="token operator">=</span> animals<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">cat</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 编译器错误</span></code></pre><p>还好Swift为我们提供了另一个<code>contains</code>方法，可以自定义谓词条件作为判断依据，其定义如下：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">where</span> predicate<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">Element</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span><span class="token punctuation">)</span> <span class="token keyword">rethrows</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span></code></pre><p>这个方法会查看数组是否包含满足给定的谓词条件的元素。可以看到这个方法是一个高阶函数，其参数是一个尾随闭包，在闭包内我们可以根据实际需要来实现我们自己的判断。所以上面的判断可以如下代码实现：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Animal</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> dog    <span class="token keyword">case</span> <span class="token function">cat</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> animals<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Animal</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>dog<span class="token punctuation">,</span> <span class="token punctuation">.</span>dog<span class="token punctuation">]</span><span class="token keyword">let</span> hasCat <span class="token operator">=</span> animals<span class="token punctuation">.</span><span class="token builtin">contains</span> <span class="token punctuation">{</span> animal <span class="token keyword">in</span>    <span class="token keyword">if</span> <span class="token keyword">case</span> <span class="token punctuation">.</span>cat <span class="token operator">=</span> animal <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当然，对于元素类型实现了<code>Equatable</code>协议的数组，也可以使用这个方法。可以自定义谓词条件，查看数组是否有满足此条件的元素，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>array<span class="token punctuation">.</span><span class="token builtin">contains</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token keyword">in</span>    element <span class="token operator">%</span> <span class="token number">7</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift中lazy作惰性求值</title>
      <link href="/2017/01/01/2017/1/swift-de-stride-cao-zuo/"/>
      <url>/2017/01/01/2017/1/swift-de-stride-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift中lazy作惰性求值"><a href="#Swift中lazy作惰性求值" class="headerlink" title="Swift中lazy作惰性求值"></a>Swift中lazy作惰性求值</h2><p>函数式编程中有惰性求值的概念，即一次计算在真正需要时才执行，尽可能推迟求解表达式。</p><p>假如我们有一个数组，我们对每个元素作<code>element*2</code>的map操作，获取其中某一个元素，我们会如下代码处理:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token keyword">let</span> element <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token function">print</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span></code></pre><p>这个计算对每个元素都*2，最后我们只取了其中一个值，也就是说在这个场景中另外5次计算是无意义的。</p><p>这时使用惰性求值就可以避免这算浪费。我们知道Swift中有个lazy关键字，如果用来修饰属性之类的，可以实现属性的惰性求值。同样，Swift扩展了LazySequenceProtocol协议，提供了一个lazy属性，用于处理map，filter等操作的惰性求值，定义如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">/// Avoid creating multiple layers of `LazySequence` wrapper.</span><span class="token comment" spellcheck="true">/// Anything conforming to `LazySequenceProtocol` is already lazy.</span><span class="token keyword">extension</span> <span class="token builtin">LazySequenceProtocol</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// Identical to `self`.</span>    <span class="token keyword">public</span> <span class="token keyword">var</span> <span class="token keyword">lazy</span><span class="token punctuation">:</span> <span class="token keyword">Self</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>所以，上面这个例子如果要实现惰性求值，则可以如下代码处理：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token keyword">let</span> element <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token keyword">lazy</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token function">print</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span></code></pre><p>我们在Playground中可以看到，整个计算中实际只执行了一次*2操作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tagged-Pointer</title>
      <link href="/2017/01/01/2017/1/tagged-pointer/"/>
      <url>/2017/01/01/2017/1/tagged-pointer/</url>
      
        <content type="html"><![CDATA[<h2 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged-Pointer"></a>Tagged-Pointer</h2><p>苹果在64位ARM架构下，对<code>NSNumber</code>等小对象对象的存储做了优化，即使用<code>Tagged Pointer</code>技术。通过使用这种技术，<code>NSNumber</code>指针变量指向的值不再是单独存储在一块内存中，而是对指针本身做了特殊处理，如下图代码所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/17-1-1.png?raw=true" alt></p><p>可以看到这些指针一部分直接保存数据(如下图蓝色部分)，另一部分作为特殊标记(如图2红色部分)，表示这是个特殊指针，不指向任何地址。这么做大大减少了这类值的存储空间，同时提高了它们的创建及读取效率。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/17-1-2.png?raw=true" alt></p><p>当然，如果数据存储部分(7个字节)无法容纳下变量的值，则会按原始的方式，另辟空间去存储值，指针的值仍然是指向这个空间的地址，如下图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/17-1-3.png?raw=true" alt></p><p>参考</p><ol><li><a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">深入理解Tagged Pointer</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2013/404/" target="_blank" rel="noopener">WWDC 2013 Advanced in Objective-C</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Traits</title>
      <link href="/2017/01/01/2017/1/traits/"/>
      <url>/2017/01/01/2017/1/traits/</url>
      
        <content type="html"><![CDATA[<h2 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h2><p><code>Traits</code>是一个可以实现实时更新代码，而不需要重新运行程序就可以看到效果的库，效果如下图所示，源码地址在<a href="https://github.com/krzysztofzablocki/Traits" target="_blank" rel="noopener">这里</a>。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/09-1-1.gif?raw=true" alt></p><p><code>Traits</code>主要是依赖于<code>Injection</code>的代码注入功能来实现实时更新。它可以是在代码中更新视图对象的属性，也可以在一个<code>json</code>配置文件甚至是远程的配置文件中处理，且做到实时更新。对配置文件的处理，主要依赖于<code>ObjectMapper</code>来实现<code>json</code>数据与属性的映射，同时借助<code>KZFileWatchers</code>库来监听配置文件的更新。</p><p>不过个人感觉有两点稍显麻烦：</p><ol><li><p>需要为每个属性定义一个类并继承<code>Trait</code>类(不同类的相同属性可以定义一个类，如<code>UILabel</code>和<code>UITextFiled</code>的<code>font</code>属性)，如图2代码所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/09-1-2.png?raw=true" alt></p></li><li><p>同时需要为每个元素的每个属性都定义一个标识，如图3代码所示。不过作者提供了一个shell脚本(generateTraitsIdentifiers.sh)来处理。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/09-1-3.png?raw=true" alt></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>filter与flatMap过滤nil</title>
      <link href="/2017/01/01/2017/1/filter-yu-flatmap-guo-lu-nil/"/>
      <url>/2017/01/01/2017/1/filter-yu-flatmap-guo-lu-nil/</url>
      
        <content type="html"><![CDATA[<h2 id="filter与flatMap过滤nil"><a href="#filter与flatMap过滤nil" class="headerlink" title="filter与flatMap过滤nil"></a>filter与flatMap过滤nil</h2><p>使用高阶函数过滤一个数组中的nil可以有两种方法：<code>filter</code>和<code>flatMap</code>。</p><p><code>filter</code>方法如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token operator">?</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token keyword">let</span> result <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span> element <span class="token keyword">in</span>    element <span class="token operator">!=</span> <span class="token constant">nil</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// [Optional(1), Optional(2), Optional(3), Optional(5), Optional(9)]</span></code></pre><p><code>flatMap</code>方法如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token operator">?</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token keyword">let</span> result<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span>    $<span class="token number">0</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// [1, 2, 3, 5, 9]</span></code></pre><p>从输出可以看出，<code>filter</code>返回的仍然是一个<code>Optional</code>数组，而<code>flatMap</code>返回的是一个非<code>Optional</code>数组。一般推荐使用第二种方法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift中lazy作惰性求值static方法与class方法的区别</title>
      <link href="/2017/01/01/2017/1/static-fang-fa-yu-class-fang-fa-de-qu-bie/"/>
      <url>/2017/01/01/2017/1/static-fang-fa-yu-class-fang-fa-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="static方法与class方法的区别"><a href="#static方法与class方法的区别" class="headerlink" title="static方法与class方法的区别"></a>static方法与class方法的区别</h2><p>在Swift中，<code>static</code>和<code>class</code>这两个关键字都可以修饰类的方法，以表明这个方法是一个类方法。不过这两者稍微有一些区别：<code>class</code>修饰的类方法可以被子类重写，而<code>static</code>修饰的类方法则不能。如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">func</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"A.method1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"A.method2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">:</span> A <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">class</span> <span class="token class-name">func</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"B.method1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Error: Cannot override static method</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"B.method2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>B<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>B<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>typealias泛型闭包</title>
      <link href="/2017/01/01/2017/1/typealias-fan-xing-bi-bao/"/>
      <url>/2017/01/01/2017/1/typealias-fan-xing-bi-bao/</url>
      
        <content type="html"><![CDATA[<h2 id="typealias泛型闭包"><a href="#typealias泛型闭包" class="headerlink" title="typealias泛型闭包"></a>typealias泛型闭包</h2><p>在<code>Swift</code>中我们可以用<code>typealias</code>来为已经存在的类型重新定义名字的,通过命名可以使代码变得更加清晰。当然也可以给闭包类型定义一个新名字，给带有泛型的闭包重新定义名字的方式如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">typealias</span> <span class="token builtin">Block</span><span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span>U<span class="token punctuation">,</span> U<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span><span class="token keyword">func</span> compare<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Comparable</span><span class="token operator">></span><span class="token punctuation">(</span>number1<span class="token punctuation">:</span> T<span class="token punctuation">,</span> number2<span class="token punctuation">:</span> T<span class="token punctuation">,</span> algorithm<span class="token punctuation">:</span> <span class="token builtin">Block</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>number1<span class="token punctuation">,</span> number2<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">compare</span><span class="token punctuation">(</span>number1<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> number2<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    $<span class="token number">0</span> <span class="token operator">&lt;</span> $<span class="token number">1</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>路径填充规则</title>
      <link href="/2017/01/01/2017/1/lu-jing-tian-chong-gui-ze/"/>
      <url>/2017/01/01/2017/1/lu-jing-tian-chong-gui-ze/</url>
      
        <content type="html"><![CDATA[<h2 id="路径填充规则"><a href="#路径填充规则" class="headerlink" title="路径填充规则"></a>路径填充规则</h2><p>Quartz在填充区域时有两套规则：<code>非零缠绕数规则(nonzero windingnumber rule)</code>和<code>偶数-奇数规则(Even-odd)</code>。</p><ol><li><p><strong>非零缠绕数规则</strong>：为了确定一个点是否需要绘制，我们从该点开始绘制一条直线穿过绘图的边界。从0开始计数，每次路径片断从左到右穿过直线时，计数加1；而从右到左穿过直线时，计数减1。如果结果为0，则不绘制该点，否则绘制。注意这种规则下，路径片断绘制的方向会影响到结果。</p></li><li><p><strong>偶数-奇数规则</strong>：为了确定一个点是否被绘制，我们从该点开始绘制一条直线穿过绘图的边界。计算穿过该直线的路径片断的数目。如果是奇数，则绘制该点，如果是偶数，则不绘制该点。这种情况下，路径片断绘制的方向不影响结果。</p></li></ol><p>官方文档给出了下图来演示两种规则的效果。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/11-1-1.gif?raw=true" alt></p><p>不过今天测试了一下，发现与文档有出入，可能是理解不对。绘制代码如下图所示，</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/11-1-2.png?raw=true" alt></p><p>测试代码如下图所示，</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/11-1-3.png?raw=true" alt></p><p>绘制结果如下图所示。</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/11-1-4.png?raw=true" alt></p><p>填充规则除了这两种，还有<code>Positive</code>和<code>Negative</code>，有兴趣的可以研究一下。 </p><p>参考</p><ol><li><a href="https://en.wikipedia.org/wiki/Nonzero-rule" target="_blank" rel="noopener">Nonzero-rule</a></li><li><a href="https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule" target="_blank" rel="noopener">Even–odd rule</a></li><li><a href="http://southpeak.github.io/2014/11/16/quartz2d-3/" target="_blank" rel="noopener">Quartz 2D编程指南之三：路径(Path)</a></li><li><a href="http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Types/PolyFillType.htm" target="_blank" rel="noopener">PolyFillType</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Extension-Selector</title>
      <link href="/2017/01/01/2017/1/extension-selector/"/>
      <url>/2017/01/01/2017/1/extension-selector/</url>
      
        <content type="html"><![CDATA[<h2 id="Extension-Selector"><a href="#Extension-Selector" class="headerlink" title="Extension-Selector"></a>Extension-Selector</h2><p>在<code>Swift</code>中，我们可以使用<code>#selector</code>设置<code>target-action</code>模式中的<code>action</code>操作，如下代码所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">ViewController</span><span class="token punctuation">:</span> <span class="token builtin">UIViewController</span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> button <span class="token operator">=</span> <span class="token function">UIButton</span><span class="token punctuation">(</span>type<span class="token punctuation">:</span> <span class="token punctuation">.</span>custom<span class="token punctuation">)</span>        button<span class="token punctuation">.</span><span class="token function">addTarget</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> action<span class="token punctuation">:</span> #<span class="token function">selector</span><span class="token punctuation">(</span>buttonTapped<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token punctuation">.</span>touchUpInside<span class="token punctuation">)</span>        view<span class="token punctuation">.</span><span class="token function">addSubview</span><span class="token punctuation">(</span>button<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">buttonTapped</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果你有代码洁癖，想把<code>#selector</code>集中起来管理，则可以定义一个结构体，来统一归集这样的代码，如下图所示。这样看着是不是会更整洁一些？</p><p><img src="https://github.com/southpeak/iOS-tech-set/blob/master/images/2017/01/21-1-1.png?raw=true" alt></p><p>不过，还有种更好的方式，就是直接扩展<code>Selector</code>结构体，如下代码所示，这样可以在使用时直接用<code>.buttonTapped</code>这种方式来引用，就像我们使用<code>.red</code>这样的<code>UIColor</code>属性一样简洁。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token builtin">Selector</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">let</span> buttonTapped <span class="token operator">=</span> #<span class="token function">selector</span><span class="token punctuation">(</span><span class="token builtin">ViewController</span><span class="token punctuation">.</span>buttonTapped<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ViewController</span><span class="token punctuation">:</span> <span class="token builtin">UIViewController</span> <span class="token punctuation">{</span>    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> button <span class="token operator">=</span> <span class="token function">UIButton</span><span class="token punctuation">(</span>type<span class="token punctuation">:</span> <span class="token punctuation">.</span>custom<span class="token punctuation">)</span>        button<span class="token punctuation">.</span><span class="token function">addTarget</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> action<span class="token punctuation">:</span> <span class="token punctuation">.</span>buttonTapped<span class="token punctuation">,</span> <span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token punctuation">.</span>touchUpInside<span class="token punctuation">)</span>        view<span class="token punctuation">.</span><span class="token function">addSubview</span><span class="token punctuation">(</span>button<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">buttonTapped</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>参考</p><p><a href="https://medium.com/swift-programming/swift-selector-syntax-sugar-81c8a8b10df3#.md6860mmq" target="_blank" rel="noopener">Swift: Selector Syntax Sugar</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
